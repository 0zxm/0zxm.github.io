<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="JavaScript学习, 0zxm">
    <meta name="description" content="">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>JavaScript学习 | 0zxm</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 7.2.0"></head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">0zxm</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">0zxm</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    
<script src="/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/15.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">JavaScript学习</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/JavaScript/">
                                <span class="chip bg-color">JavaScript</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E5%89%8D%E7%AB%AF/" class="post-category">
                                前端
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2024-10-14
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2024-10-26
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    40.7k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    176 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="计算机入门"><a href="#计算机入门" class="headerlink" title="计算机入门"></a>计算机入门</h2><h3 id="1-计算机编程基础"><a href="#1-计算机编程基础" class="headerlink" title="1.计算机编程基础"></a>1.计算机编程基础</h3><h4 id="1-1-编程"><a href="#1-1-编程" class="headerlink" title="1.1 编程"></a>1.1 编程</h4><p><strong>编程:</strong> 就是让计算机为解决某个问题而使用某种程序设计语言编写程序代码，并最终得到结果的过程</p>
<p><strong>计算机程序</strong>:就是计算机所执行的一系列的指令集合，而程序全部都是用我们所掌握的语言来编写的，所以人们要控制计算机一定要通过计算机语言向计算机发出命令。</p>
<p><strong>注意:</strong> 上面所定义的计算机指的是任何能够执行代码的设备，可能是智能手机、ATM 机、黑莓 P1、服务器等等。</p>
<h4 id="1-2-计算机语言"><a href="#1-2-计算机语言" class="headerlink" title="1.2 计算机语言"></a>1.2 计算机语言</h4><p><strong>计算机语言</strong>指用于<strong>人与计算机之间</strong>通讯的语言，它是人与计算机之间传递信息的<strong>媒介</strong></p>
<p>计算机语言的种类非常的多，总的来说可以分成<strong>机器语言</strong>，<strong>汇编语言</strong>和<strong>高级语言</strong>三大类。实际上计算机最终所执行的都是<strong>机器语言</strong>，它是由”0”和”1”组成的二进制数，<strong>二进制是计算机语介言的基础。</strong></p>
<pre><code class="txt">0=00000000 	1=00000001	2=00000010
3=00000011	4=00000100	5=00000101	6=00000110
7=00000111	8=00001000	9=00001001	10=00001010
</code></pre>
<h4 id="1-3-编程语言"><a href="#1-3-编程语言" class="headerlink" title="1.3 编程语言"></a>1.3 编程语言</h4><p>可以通过类似于人类语言的”语言”来控制计算机，让计算机为我们做事情,这样的语言就叫做 **编程语言(ProarammingLanguage)**。</p>
<p><strong>编程语言</strong>是用来控制计算机的一系列指令，它有固定的格式和词汇(不同编程语言的格式和词汇不一样)，必须遵守。</p>
<p>如今通用的编程语言有两种形式:汇编语言和高级语言。</p>
<ul>
<li><strong>汇编语言和机器语言</strong>实质是相同的，都是直接对硬件操作，只不过指令采用了英文缩写的标识符，容易识别和记忆.</li>
<li><strong>高级语言</strong>主要是相对于低级语言而言，它并不是特指某一种具体的语言，而是包括了很多编程语言，常用的有 C 语言、C++、Java、C#、Python、PHP、JavaScript、Go 语言、ObjectiveC、Swift 等。</li>
</ul>
<h4 id="1-4-翻译器"><a href="#1-4-翻译器" class="headerlink" title="1.4 翻译器"></a>1.4 翻译器</h4><p>高级语言所编制的程序不能直接被计算机识别，必须经过转换才能被执行，为此，我们需要一个翻译器。</p>
<p>翻译器可以将我们所编写的源代码转换为机器语言，这也被称为二进制化。记住 1 和 0。<br><img src="/2024/10/14/javascript-xue-xi/%E7%BF%BB%E8%AF%91%E5%99%A8.png" alt="image-20240828215818211"></p>
<h4 id="1-5-编程语言和标记语言区别"><a href="#1-5-编程语言和标记语言区别" class="headerlink" title="1.5 编程语言和标记语言区别"></a>1.5 编程语言和标记语言区别</h4><p><strong>编程语言有很强的逻辑和行为能力。</strong>在编程语言里,你会看到很多<code>ifelse</code>、<code>for</code>、<code>while</code>等具有逻辑性和行为能力的指令，这是主动的。</p>
<p><strong>标记语言(html)<strong>不用于向计算机发出指令，常用于格式化和链接。标记语言的存在是用来</strong>被读取的</strong>,他是被动的。</p>
<h4 id="1-6-总结"><a href="#1-6-总结" class="headerlink" title="1.6 总结"></a>1.6 总结</h4><ol>
<li>计算机可以帮助人类解决某些问题</li>
<li>程序员利用编程语言编写程序发出指令控制计算机来实现这些任务</li>
<li>编程语言有机器语言、汇编语言、高级语言</li>
<li>高级语言需要一个翻译器转换为计算机识别的机器语言</li>
<li>编程语言是主动的有很强的逻辑性</li>
</ol>
<h4 id="1-7-编译型语言和解释型语言"><a href="#1-7-编译型语言和解释型语言" class="headerlink" title="1.7 编译型语言和解释型语言"></a>1.7 编译型语言和解释型语言</h4><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><p>计算机不能直接理解任何除机器语言以外的语言，所以必须要把程序员所写的程序语言翻译成机器语言才能执行程序。程序语言翻译成机器语言的工具，被称为<strong>翻译器</strong>。</p>
<ul>
<li>翻译器翻译的方式有两种: 一个是<strong>编译</strong>，另外一个是<strong>解释</strong>。两种方式之间的区别在于<strong>翻译的时间点不同</strong></li>
<li>编译器是在<strong>代码执行之前进行编译，生成中间代码文件</strong></li>
<li>解释器是在<strong>运行时进行及时解释，并立即执行</strong>(当编译器以解释方式运行的时候，也称之为解释器)</li>
</ul>
<h5 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h5><p><img src="/2024/10/14/javascript-xue-xi/%E7%BC%96%E8%AF%91%E5%9E%8B%E5%92%8C%E8%A7%A3%E9%87%8A%E5%9E%8B%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.png" alt="image-20240830183214962"></p>
<h4 id="1-8-标识符、关键字、保留字"><a href="#1-8-标识符、关键字、保留字" class="headerlink" title="1.8 标识符、关键字、保留字"></a>1.8 标识符、关键字、保留字</h4><h5 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h5><p><code>标识(zhi)符</code>: 就是指开发人员为变量、属性、函数、参数取的名字。</p>
<p><strong>标识符不能是关键字或保留字</strong></p>
<h5 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h5><p>关键字: 是指 JS 本身已经使用了的字，不能再用它们充当变量名、方法名。</p>
<p>包括: break、case、catch、continue、default、delete、do、else、finally、for、function、if、in、instanceof、new、return、switch、this、throw、try、typeof、var、void、while、with 等。</p>
<h5 id="保留字"><a href="#保留字" class="headerlink" title="保留字"></a>保留字</h5><p><strong>保留字:</strong> 实际上就是预留的”关键字”意思是现在虽然还不是关键字，但是未来可能会成为关键字，同样不能使用它们当变量名或方法名。</p>
<h3 id="2-计算机基础"><a href="#2-计算机基础" class="headerlink" title="2.计算机基础"></a>2.计算机基础</h3><h4 id="2-1-计算机组成"><a href="#2-1-计算机组成" class="headerlink" title="2.1 计算机组成"></a>2.1 计算机组成</h4><p><img src="/2024/10/14/javascript-xue-xi/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%9B%BE.png" alt="image-20240828220424331"></p>
<h4 id="2-2-数据存储"><a href="#2-2-数据存储" class="headerlink" title="2.2 数据存储"></a>2.2 数据存储</h4><ol>
<li>计算机内部使用二进制 0 和 1 来表示数据</li>
<li>所有数据，包括文件、图片等最终都是以二进制数据(0 和 1)的形式存放在硬盘中的。</li>
<li>所有程序，包括操作系统，本质都是各种数据，也以二进制数据的形式存放在硬盘中。平时我们所说的安装软件，其实就是把程序文件复制到硬盘</li>
<li>硬盘、内存都是保存的二进制数据。</li>
</ol>
<h4 id="2-3-数据存储单位"><a href="#2-3-数据存储单位" class="headerlink" title="2.3 数据存储单位"></a>2.3 数据存储单位</h4><ul>
<li>bit &lt; byte &lt; kb &lt; GB &lt; TB&lt;……<ul>
<li>位(bit): 1bit 可以保存一个 0 或者 1(最小的存储单位)</li>
<li>字节(Byte):1B&#x3D;8b</li>
<li>千字节(KB):1KB&#x3D;1024B</li>
<li>兆字节(MB):1MB&#x3D;1024KB</li>
<li>吉字节(GB):1GB&#x3D;1024MB</li>
<li>太字节(TB):1TB&#x3D;1024GB</li>
<li>……</li>
</ul>
</li>
</ul>
<h4 id="2-4-程序运行"><a href="#2-4-程序运行" class="headerlink" title="2.4 程序运行"></a>2.4 程序运行</h4><p><img src="/2024/10/14/javascript-xue-xi/%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.png" alt="image-20240828220826659"></p>
<ol>
<li>打开某个程序时，先从硬盘中把程序的代码加载到内存中</li>
<li>CPU 执行内存中的代码</li>
</ol>
<p>**注意:**之所以要内存的一个重要原因，是因为 cpu 运行太快了,如果只从硬盘中读数据，会浪费 cpu 性能，</p>
<p>所以，才使用存取速度更快的内存来保存运行时的数据。(内存是电，硬盘是机械)</p>
<h2 id="JavaScript-基础"><a href="#JavaScript-基础" class="headerlink" title="JavaScript 基础"></a>JavaScript 基础</h2><h3 id="JavaScript-初始"><a href="#JavaScript-初始" class="headerlink" title="JavaScript 初始"></a>JavaScript 初始</h3><h4 id="1-初识-JavaScript"><a href="#1-初识-JavaScript" class="headerlink" title="1.初识 JavaScript"></a>1.初识 JavaScript</h4><h5 id="1-1-JavaScript-历史"><a href="#1-1-JavaScript-历史" class="headerlink" title="1.1 JavaScript 历史"></a>1.1 JavaScript 历史</h5><ul>
<li>布兰登:艾奇(BrendanEich,1961 年~)</li>
<li>神奇的大哥在 1995 年利用 10 天完成 JavaScript 设计。</li>
<li>网景公司最初命名为<code>LiveScript</code>，后来在与 Sun 合作之后将其改名为 JavaScript</li>
</ul>
<h5 id="1-2-JavaScript-是什么"><a href="#1-2-JavaScript-是什么" class="headerlink" title="1.2 JavaScript 是什么"></a>1.2 JavaScript 是什么</h5><ul>
<li><p>JavaScript 是世界上最流行的语言之一,是一种运行在客户端的脚本语言(Script 是脚本的意思)</p>
</li>
<li><p>脚本语言:不需要编译，运行过程中由<code>js解释器(js引擎)</code>逐行来进行解释并执行</p>
</li>
<li><p>现在也可以基于<code>Node.js</code>技术进行服务器端编程</p>
<p><img src="/2024/10/14/javascript-xue-xi/C_S%E6%A8%A1%E5%BC%8F.png" alt="image-20240828221512945"></p>
</li>
</ul>
<h5 id="1-3-JavaScript-的作用"><a href="#1-3-JavaScript-的作用" class="headerlink" title="1.3 JavaScript 的作用"></a>1.3 JavaScript 的作用</h5><p>表单动态校验(密码强度检测)<strong>(JS 产生最初的目的)</strong></p>
<p>网页特效</p>
<p>服务端开发(Node.js)</p>
<p>桌面程序(Electron)</p>
<p>App(Cordova)</p>
<p>控制硬件-物联网(Ruff)</p>
<p>游戏开发(cocos2d-js)</p>
<h5 id="1-4-HTML-CSS-JS-的关系"><a href="#1-4-HTML-CSS-JS-的关系" class="headerlink" title="1.4 HTML&#x2F;CSS&#x2F;JS 的关系"></a>1.4 HTML&#x2F;CSS&#x2F;JS 的关系</h5><ul>
<li><p>HTML&#x2F;CSS 标记语言–描述类语言</p>
<p>HTML 决定网页结构和内容(决定看到什么)，相当于人的身体</p>
<p>CSS 决定网页呈现给用户的模样(决定好不好看)相当于给人穿衣服、化妆</p>
</li>
<li><p>JS 脚本语言–编程类语言</p>
<p>实现业务逻辑和页面控制(决定功能)，相当于人的各种动作</p>
</li>
</ul>
<h5 id="1-5-浏览器执行-JS-简介"><a href="#1-5-浏览器执行-JS-简介" class="headerlink" title="1.5 浏览器执行 JS 简介"></a>1.5 浏览器执行 JS 简介</h5><p>浏览器分成两部分<code>渲染引擎</code>和<code>JS引擎</code></p>
<ul>
<li>渲染引擎:用来解析 HTML 与 CSS，俗称内核，比如 chrome 浏览器的<code>blink</code>,老版本的<code>webkit</code></li>
<li>JS 引擎:也称<strong>JS</strong>解释器。用来读取网页中的 JavaScript 代码,对其处理后运行，比如 chrome 浏览器的 V8</li>
</ul>
<p><strong>浏览器本身并不会执行 JS 代码,而是通过内置 JavaScript 引擎(解释器)来执行 JS 代码。JS 引擎执行代码时逐行解释每一句源码(转换为机器语言)，然后由计算机去执行,所以 JavaScript 语言归为脚本语言,会逐行解释执行。</strong></p>
<p><img src="/2024/10/14/javascript-xue-xi/js%E5%BC%95%E6%93%8E.png" alt="image-20240828222353856"></p>
<h5 id="1-6-JS-的组成"><a href="#1-6-JS-的组成" class="headerlink" title="1.6 JS 的组成"></a>1.6 JS 的组成</h5><img src="/2024/10/14/javascript-xue-xi/js组成.png" alt="image-20240828222503677" style="zoom:67%;">

<ol>
<li>ECMAScript</li>
</ol>
<p><strong>ECMAScript</strong>是由 ECMA 国际(原欧洲计算机制造商协会)进行标准化的一门编程语言，这种语言在万维网上应用广泛，它往往被称为 JavaScript(网景公司)或 JScript(微软公司)，但实际上后两者是 ECMAScript 语言的实现和扩展。</p>
<p><strong>ECMAScript:ECMAScript 规定了 JS 的编程语法和基础核心知识，是所有浏览器厂商共同遵守的一套 JS 语法工业标准。</strong></p>
<p>更多参看 MDN: <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/JavaScript_technologies_overview">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/JavaScript_technologies_overview</a></p>
<ol start="2">
<li><strong>DOM–文档对象模型</strong></li>
<li><strong>BOM–浏览器对象模型</strong></li>
</ol>
<p><code>BOM(Browser ObjectModel,简称BOM)</code>是指浏览器对象模型,它提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。通过 BOM 可以操作浏览器窗口，比如弹出框、控制浏览器跳转、获取分辨率等</p>
<h5 id="1-7JS-的初体验"><a href="#1-7JS-的初体验" class="headerlink" title="1.7JS 的初体验"></a>1.7JS 的初体验</h5><ol>
<li>行内式的 js,直接写到元素的内部</li>
</ol>
<pre><code class="html">&lt;!-- 1.行内式的js 直接写到元素的内部 --&gt;
&lt;input type=&quot;button&quot; value=&quot;李白&quot; onclick=&quot;alert(&#39;Hello, World!&#39;);&quot; /&gt;
</code></pre>
<ul>
<li>可以将单行或少量 JS 代码写在 HTML 标签的事件属性中(以 on 开头的属性)，如:onclick</li>
<li>注意单双引号的使用:在 HTML 中我们推荐使用双引号,JS 中我们推荐使用单引号</li>
<li>可读性差，在 html 中编写 JS 大量代码时，不方便阅读;</li>
<li>引号易错，引号多层嵌套匹配时，非常容易弄混;</li>
<li>特殊情况下使用</li>
</ul>
<ol start="2">
<li>内嵌式 js</li>
</ol>
<pre><code class="html">&lt;!-- 2.内嵌式js --&gt;
&lt;script&gt;
  alert(&quot;你好,世界!&quot;);
&lt;/script&gt;
</code></pre>
<ul>
<li>可以将多行 JS 代码写到<code>&lt;script&gt;</code>标签中</li>
<li>内嵌 JS 是学习时常用的方式</li>
</ul>
<ol start="3">
<li>外部文件式</li>
</ol>
<pre><code class="html">&lt;!-- 3.外链式js --&gt;
&lt;script src=&quot;my.js&quot;&gt;&lt;/script&gt;
</code></pre>
<pre><code class="javascript">// my.js
alert(&quot;Hello, World!&quot;);
</code></pre>
<ul>
<li>利于 HTML 页面代码结构化，把大段 JS 代码独立到 HTML 页面之外，既美观，也方便文件级别的复用</li>
<li>引用<strong>外部 JS 文件</strong>的<strong>script 标签</strong>中间不可以写代码</li>
<li>适合于 JS 代码量比较大的情况</li>
</ul>
<h4 id="2-JavaScript-注释"><a href="#2-JavaScript-注释" class="headerlink" title="2.JavaScript 注释"></a>2.JavaScript 注释</h4><ul>
<li>单行注释 <strong>使用&#x2F;&#x2F;</strong></li>
<li>多行注释 <code>使用/**/</code></li>
</ul>
<h4 id="3-JavaScript-输入输出语句"><a href="#3-JavaScript-输入输出语句" class="headerlink" title="3.JavaScript 输入输出语句"></a>3.JavaScript 输入输出语句</h4><p>为了方便信息的输入输出，JS 中提供了一些输入输出语句，其常用的语句如下</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
<th>归属</th>
</tr>
</thead>
<tbody><tr>
<td>alert(msg)</td>
<td>浏览器弹出警示框</td>
<td>浏览器</td>
</tr>
<tr>
<td>console.log(msg)</td>
<td>浏览器控制台打印输出信息</td>
<td>浏览器</td>
</tr>
<tr>
<td>prompt(info)</td>
<td>浏览器弹出输入框，用户可以输入</td>
<td>浏览器</td>
</tr>
</tbody></table>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="1-变量概述"><a href="#1-变量概述" class="headerlink" title="1.变量概述"></a>1.变量概述</h4><h5 id="1-1-什么是变量"><a href="#1-1-什么是变量" class="headerlink" title="1.1 什么是变量"></a>1.1 什么是变量</h5><p>变量是用于存放数据的容器。我们通过变量名 获取数据，甚至数据可以修改。</p>
<h5 id="1-2-变量在内存中的存储"><a href="#1-2-变量在内存中的存储" class="headerlink" title="1.2 变量在内存中的存储"></a>1.2 变量在内存中的存储</h5><p>本质:变量是程序在内存中申请的一块用来存放数据的空间。</p>
<h4 id="2-变量的使用"><a href="#2-变量的使用" class="headerlink" title="2.变量的使用"></a>2.变量的使用</h4><p>变量在使用时分为两步: 1.声明变量 2.赋值</p>
<h5 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h5><pre><code class="js">// 声明变量
var age; // 声明一个名称为age的变量
</code></pre>
<ul>
<li>var 是一个 JS 关键字,用来声明变量(<strong>variable 变量</strong>的意思)。使用该关键字声明变量后,计算机会自动为变量分配内存空间，不需要程序员管</li>
<li>age 是程序员定义的变量名，我们要通过变量名来访问内存中分配的空间</li>
</ul>
<h5 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h5><pre><code class="js">age = 10;
//给age 这个变量赋值为10
</code></pre>
<ul>
<li><code>=</code>用来把右边的值赋给左边的变量空间中 此处代表赋值的意思</li>
<li>变量值是程序员保存到变量空间里的值</li>
</ul>
<h5 id="变量的初始化"><a href="#变量的初始化" class="headerlink" title="变量的初始化"></a>变量的初始化</h5><p><code>var age = 18;//声明变量同时赋值为18</code></p>
<h4 id="3-变量语法扩展"><a href="#3-变量语法扩展" class="headerlink" title="3.变量语法扩展"></a>3.变量语法扩展</h4><ol>
<li>更新变量</li>
</ol>
<p>一个变量被重新复赋值后，它原有的值就会被覆盖，变量值将以最后一次赋的值为准。</p>
<ol start="2">
<li>同时声明多个变量</li>
</ol>
<p>同时声明多个变量时，只需要写一个<strong>var</strong>，多个变量名之间使用<strong>英文逗号</strong>隔开。</p>
<pre><code class="js">var age = 10,
  name = &quot;s&quot;,
  sex = 2;
// **英文逗号**隔开
</code></pre>
<ol start="3">
<li>声明变量特殊情况</li>
</ol>
<table>
<thead>
<tr>
<th>情况</th>
<th>说明</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>var age; console.log(age);</td>
<td>只声明 不赋值</td>
<td>undefined</td>
</tr>
<tr>
<td>console.log(age)</td>
<td>不声明 不赋值 直接使用</td>
<td>报错</td>
</tr>
<tr>
<td>age &#x3D; 10; console.log(age);</td>
<td>不声明 只赋值</td>
<td>10</td>
</tr>
</tbody></table>
<h4 id="变量命名规范"><a href="#变量命名规范" class="headerlink" title="变量命名规范"></a>变量命名规范</h4><ul>
<li>由字母(A-Za-z)、数字(0-9)、下划线(_)、美元符号($)组成,如: usrAge, num01, nameR</li>
<li>严格区分大小写。var app;和 var App;是两个变量</li>
<li>不能 以数字开头。 18age 是错误的</li>
<li>不能 是关键字、保留字。例如:var、for、while</li>
<li>变量名必须有意义。MMD BBD <code>nianling → age</code></li>
<li>遵守驼峰命名法。首字母小写，后面单词的首字母需要大写。<code>myFirstName</code></li>
<li>推荐翻译网站:有道 爱词霸</li>
<li><code>name</code>一般不要使用作为变量名,可能在某些浏览器会有特殊含义</li>
</ul>
<h4 id="交换变量案例"><a href="#交换变量案例" class="headerlink" title="交换变量案例"></a>交换变量案例</h4><pre><code class="javascript">// 只对数字类型有效
var a = 10;
var b = 20;
console.log(&quot;Before swapping: a = &quot; + a + &quot;, b = &quot; + b);
a = a + b;
b = a - b;
a = a - b;
console.log(&quot;After swapping: a = &quot; + a + &quot;, b = &quot; + b);

// 字符串类型
var str1 = &quot;hello&quot;;
var str2 = &quot;world&quot;;
console.log(&quot;Before swapping: str1 = &quot; + str1 + &quot;, str2 = &quot; + str2);
str1 = str1 + str2;
str2 = str1.substring(0, str1.length - 5);
str1 = str1.substring(str1.length - 5);
console.log(&quot;After swapping: str1 = &quot; + str1 + &quot;, str2 = &quot; + str2);
</code></pre>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="1-数据类型简介"><a href="#1-数据类型简介" class="headerlink" title="1.数据类型简介"></a>1.数据类型简介</h4><h5 id="1-1-为什么需要数据类型"><a href="#1-1-为什么需要数据类型" class="headerlink" title="1.1 为什么需要数据类型"></a>1.1 为什么需要数据类型</h5><p>在计算机中，不同的数据所需占用的存储空间是不同的，为了便于把数据分成所需内存大小不同的数据，充分利用存储空间，于是定义了不同的数据类型。</p>
<h5 id="1-2-变量的数据类型"><a href="#1-2-变量的数据类型" class="headerlink" title="1.2 变量的数据类型"></a>1.2 变量的数据类型</h5><p>变量是用来存储值的所在处，它们有名字和数据类型。变量的数据类型决定了如何将代表这些值的位存储到计算机的内存中。<strong>JavaScript 是一种弱类型或者说动态语言</strong>。这意味着不用提前声明变量的类型，在程序运行过程中，类型会被自动确定。</p>
<pre><code class="javascript">var age = 10; // 这是一个数字型
var areYouok = &quot;是的&quot;; //这是一个字符串
</code></pre>
<p>在代码运行时，变量的数据类型是由 JS 引擎根据**&#x3D;右边变量值的数据类型来判断**的，运行完毕之后，变量就确定了数据类型<br><strong>JavaScript 拥有动态类型，同时也意味着相同的变量可用作不同的类型</strong></p>
<pre><code class="javascript">var x = 6; //x为数字
var x = &quot;Bill&quot;; //x为字符串
</code></pre>
<h5 id="1-3-数据类型的分类"><a href="#1-3-数据类型的分类" class="headerlink" title="1.3 数据类型的分类"></a>1.3 数据类型的分类</h5><p>JS 把数据类型分为两类:</p>
<ul>
<li>简单数据类型(Number,String,Boolean,Undefined,Null)</li>
<li>复杂数据类型(object)</li>
</ul>
<h4 id="2-简单数据类型"><a href="#2-简单数据类型" class="headerlink" title="2.简单数据类型"></a>2.简单数据类型</h4><h5 id="2-1-简单数据类型-基本数据类型"><a href="#2-1-简单数据类型-基本数据类型" class="headerlink" title="2.1 简单数据类型(基本数据类型)"></a>2.1 简单数据类型(基本数据类型)</h5><p>JavaScript 中的简单数据类型及其说明如下</p>
<table>
<thead>
<tr>
<th>简单数据类型</th>
<th>说明</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>Number</td>
<td>数字型，包含 整型值和浮点型值，如 21、0.21</td>
<td>0</td>
</tr>
<tr>
<td>Boolean</td>
<td>布尔值类型，如 true、false，等价于 1 和 0</td>
<td>false</td>
</tr>
<tr>
<td>String</td>
<td>字符串类型，如 “张三” 注意：在 JS 里面，字符串都带引号</td>
<td>“”</td>
</tr>
<tr>
<td>Undefined</td>
<td>var a; 声明了变量 a 但是没有给值，此时 a &#x3D; undefined</td>
<td>undefined</td>
</tr>
<tr>
<td>Null</td>
<td>var a &#x3D; null; 声明了变量 a 为空值</td>
<td>null</td>
</tr>
</tbody></table>
<h5 id="2-2-数字型-Number"><a href="#2-2-数字型-Number" class="headerlink" title="2.2 数字型 Number"></a>2.2 数字型 Number</h5><p>JavaScript 数字类型既可以用来保存整数值，也可以保存小数(浮点数)。</p>
<pre><code class="javascript">var age = 21; // 整数
var age = 21.3747; // 小数
</code></pre>
<p>1.数字型进制</p>
<p>最常见的进制有二进制、八进制、十进制、十六进制。</p>
<pre><code class="javascript">//1.八进制数字序列范围:0~7
var numl = 07; // 对应十进制的7
var num2 = 019; //对应十进制的19
var num3 = 08; //对应十进制的8

//2.十六进制数字序列范围:0~9以及A~F
var num = 0xa;
</code></pre>
<p>3.数字型三个特殊值</p>
<pre><code class="javascript">alert(Infinity); //Infinity
alert(-Infinity); //-Infinity
alert(NaN); // NaN
</code></pre>
<p><code>Infinity</code> 代表无穷大，大于任何数值</p>
<p><code>-Infinity</code> 代表无穷小，小于任何数值</p>
<p><code>NaN，Not a number </code>代表一个非数值</p>
<ol start="4">
<li>非数值型 NaN</li>
</ol>
<p>使用<code>isNaN()</code>来判断是否是非数字</p>
<h5 id="2-3-String-字符串型"><a href="#2-3-String-字符串型" class="headerlink" title="2.3 String 字符串型"></a>2.3 String 字符串型</h5><ol>
<li>使用引号包裹起来的称为字符串类型</li>
</ol>
<p>字符串型可以是引号中的任意文本，其语法为双引号””和 单引号’</p>
<pre><code class="js">var strMsg=&quot;我爱北京天安门~&quot;;// 使用双引号表示字符串v
var strMsg2=&#39;我爱吃猪蹄~&#39;;	//使用单引号表示字符串
// 常见错误
var strMsg3=我爱大肘子;	//报错，没使用引号，会被认为是js代码，但js没有这些语法
</code></pre>
<p>因为 HTML 标签里面的属性使用的是双引号，JS 这里我们更推荐<strong>使用单引号</strong>。</p>
<pre><code class="javascript">// 引号的嵌套
var str = &#39;Hello, &quot;World&quot;!&#39;;
console.log(str);

// 字符串的拼接
var str1 = &quot;Hello&quot;;
var str2 = &quot;World&quot;;
console.log(str1 + &quot;&quot; + str2);
</code></pre>
<ol start="2">
<li><strong>字符串转义符</strong></li>
</ol>
<p>类似 HTML 里面的特殊字符，字符串中也有特殊字符，我们称之为转义符转义符都是<code>\</code>开头的，常用的转义符及其说明如下</p>
<table>
<thead>
<tr>
<th>转义符</th>
<th>解释说明</th>
</tr>
</thead>
<tbody><tr>
<td>\n</td>
<td>换行符，n 是 newline 的意思</td>
</tr>
<tr>
<td><code>\\</code></td>
<td>斜杠 \</td>
</tr>
<tr>
<td><code>\&#39;</code></td>
<td>‘ 单引号</td>
</tr>
<tr>
<td><code>\&quot;</code></td>
<td>“ 双引号</td>
</tr>
<tr>
<td>\t</td>
<td>tab 缩进</td>
</tr>
<tr>
<td>\b</td>
<td>空格，b 是 blank 的意思</td>
</tr>
</tbody></table>
<ol start="3">
<li>字符串长度</li>
</ol>
<p>字符串是由若干字符组成的，这些字符的数量就是字符串的长度。通过字符串的<strong>length 属性</strong>可以获取整个字符串的长度。</p>
<ol start="4">
<li>字符串拼接</li>
</ol>
<p>多个字符串之间可以使用+进行拼接，其拼接方式为<strong>字符串 + 任何类型 &#x3D; 拼接之后的新字符串</strong></p>
<pre><code class="javascript">// 字符串的拼接
var str1 = &quot;Hello&quot;;
var num = 100;
console.log(str1 + num);
//输出Hello100
</code></pre>
<h5 id="2-4-布尔类型-Boolean"><a href="#2-4-布尔类型-Boolean" class="headerlink" title="2.4 布尔类型 Boolean"></a>2.4 布尔类型 Boolean</h5><p>布尔类型有两个值:<code>true</code>和<code>false</code>，其中 true 表示真(对)，而 false 表示假(错)。</p>
<p>布尔型和数字型相加的时候，<strong>true 的值为 1，false 的值为 0</strong>。</p>
<pre><code class="javascript">console.log(true + 1); //2
console.log(false + 1); //1
</code></pre>
<h5 id="2-5-Undefined-和-Null"><a href="#2-5-Undefined-和-Null" class="headerlink" title="2.5 Undefined 和 Null"></a>2.5 Undefined 和 Null</h5><p>-个声明后没有被赋值的变量会有一个默认值<strong>undefined</strong>(如果进行相连或者相加时，注意结果)</p>
<pre><code class="javascript">var variable;
console.log(variable); //undefined
console.log(&quot;你好:&quot; + variable); //你好:undefined
undefinedconsole.log(11 + variable); // NaN
console.log(true + variable); //NaN
</code></pre>
<p>一个声明变量给 null 值，里面存的值为空(学习对象时，我们继续研究 null)</p>
<pre><code class="javascript">var vari = null;
console.log(&quot;你好&quot; + vari); //你好nu11
console.log(11 + vari); //11
console.log(true + vari); //1
</code></pre>
<h4 id="3-获取检测变量的数据类型"><a href="#3-获取检测变量的数据类型" class="headerlink" title="3.获取检测变量的数据类型"></a>3.获取检测变量的数据类型</h4><h5 id="3-1typeof可用来获取检测变量的数据类型"><a href="#3-1typeof可用来获取检测变量的数据类型" class="headerlink" title="3.1typeof可用来获取检测变量的数据类型"></a>3.1<code>typeof</code>可用来获取检测变量的数据类型</h5><pre><code class="javascript">var a = 10;
console.log(typeof a); // output: number

var b = &quot;hello&quot;;
console.log(typeof b); // output: string

var c = true;
console.log(typeof c); // output: boolean

var d = null;
console.log(typeof d); // output: object

var e = undefined;
console.log(typeof e); // output: undefined

var f = function () &#123;&#125;;
console.log(typeof f); // output: function

var g = &#123;&#125;;
console.log(typeof g); // output: object

var h = [];
console.log(typeof h); // output: object
</code></pre>
<ul>
<li><code>prompt()</code>获取的是<strong>String 类型</strong></li>
</ul>
<h5 id="3-2-字面量"><a href="#3-2-字面量" class="headerlink" title="3.2 字面量"></a>3.2 字面量</h5><p>字面量是在源代码中一个固定值的表示法，通俗来说，就是字面量表示如何表达这个值</p>
<p>数字字面量: 8,9,10</p>
<p>字符串字面量: ‘黑马程序员’，”大前端”</p>
<p>布尔字面量: true，false</p>
<h4 id="4-数据类型转换"><a href="#4-数据类型转换" class="headerlink" title="4.数据类型转换"></a>4.数据类型转换</h4><h5 id="4-1-什么是数据类型转换"><a href="#4-1-什么是数据类型转换" class="headerlink" title="4.1 什么是数据类型转换"></a>4.1 什么是数据类型转换</h5><p>使用表单、prompt 获取过来的数据默认是字符串类型的，此时就不能直接简单的进行加法运算，而需要转换变量的数据类型。通俗来说，就是把<strong>一种数据类型的变量转换成另外一种数据类型</strong></p>
<h5 id="4-2-转换成字符串类型"><a href="#4-2-转换成字符串类型" class="headerlink" title="4.2 转换成字符串类型"></a>4.2 转换成字符串类型</h5><table>
<thead>
<tr>
<th>方式</th>
<th>说明</th>
<th>案例</th>
</tr>
</thead>
<tbody><tr>
<td>toString()</td>
<td>转成字符串</td>
<td><code>var num = 1; alert(num.toString());</code></td>
</tr>
<tr>
<td>String() 强制转换</td>
<td>转成字符串</td>
<td><code>var num = 1; alert(String(num));</code></td>
</tr>
<tr>
<td><strong>加号拼接字符串</strong></td>
<td>和字符串拼接结果都是字符串</td>
<td><code>var num = 1; alert(num + &quot;我是字符串&quot;);</code></td>
</tr>
</tbody></table>
<ul>
<li><code>toString()</code> 和 <code>String()</code> 使用方式不一样。</li>
<li>三种转换方式，我们更喜欢用第三种加号拼接字符串转换方式，这一种方式也称之为<strong>隐式转换</strong></li>
</ul>
<h5 id="4-3-转换成数字型-重点"><a href="#4-3-转换成数字型-重点" class="headerlink" title="4.3 转换成数字型(重点)"></a>4.3 转换成数字型(重点)</h5><ul>
<li><code>parseInt()</code>,取整函数,截断小数部分,返回整数部分</li>
</ul>
<pre><code class="js">// 1.parseInt()
var str1 = &quot;100.5&quot;; // 100
var num1 = parseInt(str1);
console.log(num1);

console.log(parseInt(&quot;120px&quot;)); // 120,会从字符串中取出数字,但必须是以数字开头
</code></pre>
<ul>
<li><code>parseFloat()</code>,转变成浮点数</li>
</ul>
<pre><code class="javascript">// 2.parseFloat()
var str2 = &quot;10.5&quot;;
var num2 = parseFloat(str2);
console.log(num2);
console.log(parseFloat(&quot;120.45px&quot;)); // 120.45,会从字符串中取出数字,但必须是以数字开头
console.log(parseFloat(&quot;rem120.45px&quot;)); // NaN
</code></pre>
<ul>
<li><code>Number()函数</code></li>
</ul>
<pre><code class="javascript">// 3.Number()
var str3 = &quot;10&quot;;
var num3 = Number(str3);
console.log(num3);
</code></pre>
<ul>
<li><code>算数运算符隐式转换</code></li>
</ul>
<pre><code class="javascript">//利用算数 - / *运算符实现转换效果
var str4 = &quot;10&quot;;
var num4 = str4 - 0;
console.log(num4);

var str5 = &quot;10.5&quot;;
var num5 = str5 * 1;
console.log(num5);
</code></pre>
<table>
<thead>
<tr>
<th>方式</th>
<th>说明</th>
<th>案例</th>
</tr>
</thead>
<tbody><tr>
<td>parseInt(string) 函数</td>
<td>将 string 类型转成整数数值类型</td>
<td><code>parseInt(&#39;78&#39;)</code></td>
</tr>
<tr>
<td>parseFloat(string) 函数</td>
<td>将 string 类型转成浮点数数值类型</td>
<td><code>parseFloat(&#39;78.21&#39;)</code></td>
</tr>
<tr>
<td>Number() 强制转换函数</td>
<td>将 string 类型转成数值类型</td>
<td><code>Number(&#39;12&#39;)</code></td>
</tr>
<tr>
<td>js 隐式转换 (- * &#x2F;)</td>
<td>利用算术运算隐式转换为数值类型</td>
<td><code>&#39;12&#39; - 0</code>或者<code>&#39;12&#39; - &#39;0&#39;</code></td>
</tr>
<tr>
<td>Number.isInteger()</td>
<td>检查是否为整数</td>
<td><code>console.log(Number.isInteger(&#39;4&#39;));</code>false</td>
</tr>
</tbody></table>
<h5 id="4-4-转化成布尔类型"><a href="#4-4-转化成布尔类型" class="headerlink" title="4.4 转化成布尔类型"></a>4.4 转化成布尔类型</h5><ul>
<li>代表<strong>空、否定</strong>的值会被转换为<strong>false</strong>,如<code>‘’</code>、<code>0</code>、<code>NaN</code>、<code>null</code>、<code>undefined</code></li>
<li>其余值都会被转换为<strong>true</strong></li>
</ul>
<pre><code class="javascript">console.log(Boolean(&quot;&quot;)); // false
console.log(Boolean(0)); // false
console.log(Boolean(NaN)); // false
console.log(Boolean(null)); // false
console.log(Boolean(undefined)); // false
console.log(Boolean(&quot;小徐&quot;)); // true
console.log(Boolean(12)); // true
</code></pre>
<table>
<thead>
<tr>
<th>方式</th>
<th>说明</th>
<th>案例</th>
</tr>
</thead>
<tbody><tr>
<td>Boolean() 函数</td>
<td>其他类型转成布尔值</td>
<td><code>Boolean(&#39;true&#39;)</code></td>
</tr>
</tbody></table>
<h3 id="JavaScript-运算符"><a href="#JavaScript-运算符" class="headerlink" title="JavaScript 运算符"></a>JavaScript 运算符</h3><h4 id="1-运算符"><a href="#1-运算符" class="headerlink" title="1.运算符"></a>1.运算符</h4><p><code>运算符(operator)</code>也被称为操作符，是用于实现赋值、比较和执行算数运算等功能的符号</p>
<h4 id="2-算数运算符"><a href="#2-算数运算符" class="headerlink" title="2.算数运算符"></a>2.算数运算符</h4><h5 id="2-1-算术运算符概述"><a href="#2-1-算术运算符概述" class="headerlink" title="2.1 算术运算符概述"></a>2.1 算术运算符概述</h5><p>概念: 算术运算使用的符号，用于执行两个变量或值的算术运算。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>加</td>
<td>10 + 20 &#x3D; 30</td>
</tr>
<tr>
<td>-</td>
<td>减</td>
<td>10 - 20 &#x3D; -10</td>
</tr>
<tr>
<td>*</td>
<td>乘</td>
<td>10 * 20 &#x3D; 200</td>
</tr>
<tr>
<td>&#x2F;</td>
<td>除</td>
<td>10 &#x2F; 20 &#x3D; 0.5</td>
</tr>
<tr>
<td>%</td>
<td>取余数 (取模)</td>
<td>返回除法的余数 9 % 2 &#x3D; 1(常用于检测是否能整除)</td>
</tr>
</tbody></table>
<h5 id="2-2-浮点数的精度问题"><a href="#2-2-浮点数的精度问题" class="headerlink" title="2.2 浮点数的精度问题"></a>2.2 浮点数的精度问题</h5><p>浮点数值的最高精度是 17 位小数，但在进行算术计算时其<strong>精确度远远不如整数</strong>。</p>
<pre><code class="javascript">var result = 0.1 + 0.2; //结果不是 0.3,而是:0.30000000000000004
console.log(0.07 * 100); //结果不是7， 而是:7.000000000000001

var num = 0.1 + 0.2;
console.log(num == 0.3); // false
</code></pre>
<p>所以:<strong>不要直接判断两个浮点数是否相等!</strong></p>
<h5 id="2-3-表达式和返回值"><a href="#2-3-表达式和返回值" class="headerlink" title="2.3 表达式和返回值"></a>2.3 表达式和返回值</h5><p><strong>表达式</strong>: 是由数字、运算符、变量等以能求得数值的有意义排列方法所得的组合简单理解:是由数字、运算符、变量等组成的式子</p>
<pre><code class="javascript">var result =  1 + 1; //2
`1+1`是表达式,把值返回给result变量
</code></pre>
<h4 id="3-递增和递减运算符"><a href="#3-递增和递减运算符" class="headerlink" title="3.递增和递减运算符"></a>3.递增和递减运算符</h4><h5 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h5><p>如果需要反复给数字变量添加或减去 1，可以使用<strong>递增(++)和递减(–)运算符</strong>来完成.</p>
<p>在 JavaScript 中，递增(++)和递减(–)既可以放在变量前面，也可以放在变量后面。放在变量前面时我们可以称为<strong>前置递增(递减)运算符</strong>，放在变量后面时，我们可以称为<strong>后置递增(递减)运算符</strong></p>
<h5 id="递增运算符"><a href="#递增运算符" class="headerlink" title="递增运算符"></a>递增运算符</h5><ul>
<li>前置递增运算符**(先加后用)**</li>
</ul>
<pre><code class="javascript">// 前置运算符 先+1在使用
var num = 11;
console.log(++num); // 12
</code></pre>
<ul>
<li>后置递增运算符**(先用后加)**</li>
</ul>
<pre><code class="javascript">// 后置运算符 先使用在+1
var num = 10;
console.log(num++); // 10
console.log(num); // 11
</code></pre>
<h5 id="递减运算符"><a href="#递减运算符" class="headerlink" title="递减运算符"></a>递减运算符</h5><ul>
<li>前置递减运算符**(先加后用)**</li>
</ul>
<pre><code class="javascript">// 前置运算符 先-1在使用
var num = 11;
console.log(++num); // 10
</code></pre>
<ul>
<li>后置递减运算符**(先用后加)**</li>
</ul>
<pre><code class="javascript">// 后置运算符 先使用在-1
var num = 10;
console.log(num--); // 10
console.log(num); // 9
</code></pre>
<h5 id="前置递增和后置递增小结"><a href="#前置递增和后置递增小结" class="headerlink" title="前置递增和后置递增小结"></a>前置递增和后置递增小结</h5><ul>
<li>前置递增和后置递增运算符可以简化代码的编写，让变量的值+1 比以前写法更简单</li>
<li>单独使用时，运行结果相同</li>
<li>与其他代码联用时，执行结果会不同</li>
<li>后置:先原值运算，后自加</li>
<li>前置:先自加，后运算</li>
</ul>
<h4 id="4-比较运算符"><a href="#4-比较运算符" class="headerlink" title="4.比较运算符"></a>4.比较运算符</h4><p>概念:比较运算符(关系运算符)是两个数据进行比较时所使用的运算符比较运算后，会**返回一个布尔值(true&#x2F;false)**作为比较运算的结果。</p>
<table>
<thead>
<tr>
<th>运算符名称</th>
<th>说明</th>
<th>案例</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;</td>
<td>小于号</td>
<td>1 &lt; 2</td>
<td>true</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于号</td>
<td>1 &gt; 2</td>
<td>false</td>
</tr>
<tr>
<td>&gt;&#x3D;</td>
<td>大于等于号 (大于或者等于)</td>
<td>2 &gt;&#x3D; 2</td>
<td>true</td>
</tr>
<tr>
<td>&lt;&#x3D;</td>
<td>小于等于号 (小于或者等于)</td>
<td>3 &lt;&#x3D; 2</td>
<td>false</td>
</tr>
<tr>
<td>&#x3D;&#x3D;</td>
<td>判等号 (会自动转换类型)</td>
<td>‘37’ &#x3D;&#x3D; 37</td>
<td>true</td>
</tr>
<tr>
<td><code>!=</code></td>
<td>不等号</td>
<td>37 !&#x3D; 37</td>
<td>false</td>
</tr>
<tr>
<td><code>===</code> <code>!==</code></td>
<td><strong>全等</strong> 要求值和数据类型都一致</td>
<td>37 &#x3D;&#x3D;&#x3D; ‘37’</td>
<td>false</td>
</tr>
</tbody></table>
<h4 id="小结"><a href="#小结" class="headerlink" title="=小结"></a><code>=</code>小结</h4><table>
<thead>
<tr>
<th>符号</th>
<th>作用</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;</td>
<td>赋值</td>
<td>把右边给左边</td>
</tr>
<tr>
<td>&#x3D;&#x3D;</td>
<td>判断</td>
<td>判断两边值是否相等（注意有隐式转换）</td>
</tr>
<tr>
<td>&#x3D;&#x3D;&#x3D;</td>
<td>全等</td>
<td>判断两边的值和数据类型是否完全相同</td>
</tr>
</tbody></table>
<h4 id="5-逻辑运算符"><a href="#5-逻辑运算符" class="headerlink" title="5.逻辑运算符"></a>5.逻辑运算符</h4><h5 id="5-1-逻辑运算符概述"><a href="#5-1-逻辑运算符概述" class="headerlink" title="5.1 逻辑运算符概述"></a>5.1 逻辑运算符概述</h5><p>概念: 逻辑运算符是用来进行布尔值运算的运算符，其返回值也是布尔值，后面开发中经常用于多个条件的判断</p>
<h5 id="5-2-逻辑运算"><a href="#5-2-逻辑运算" class="headerlink" title="5.2 逻辑运算"></a>5.2 逻辑运算</h5><ul>
<li>布尔值参与逻辑运算</li>
</ul>
<p>| 逻辑运算符 | 说明                     | 案例                    |<br>| ———- | ———————— | ———————– | — | ————- |<br>| &amp;&amp;         | “逻辑与” ，简称 “与” and | <code>true &amp;&amp; false = false</code> |<br>| ||       | “逻辑或” ，简称 “或” or  | <code>true                   |     | false = true</code> |<br>| !          | “逻辑非” ，简称 “非” not | <code>!true = false</code>         |</p>
<ul>
<li><strong>值</strong>或者<strong>表达式</strong>参与逻辑运算</li>
</ul>
<h5 id="5-3-短路运算-逻辑中断"><a href="#5-3-短路运算-逻辑中断" class="headerlink" title="5.3 短路运算(逻辑中断)"></a>5.3 短路运算(逻辑中断)</h5><p><strong>短路运算的原理: 当有多个表达式(值)时左边的表达式值已经可以确定结果时,就不再继续运算右边的表达式的值;</strong></p>
<ul>
<li>逻辑与</li>
</ul>
<p>语法: 表达式 1 &amp;&amp; 表达式 2<br>如果第一个表达式的值为真，则返回表达式 2<br>如果第一个表达式的值为假，则返回表达式 1</p>
<ul>
<li>逻辑或</li>
</ul>
<p>语法: 表达式 1 || 表达式 2<br>如果第一个表达式的值为真，则返回表达式 1<br>如果第一个表达式的值为假，则返回表达式 2</p>
<pre><code class="javascript">// 逻辑与的短路运算：
console.log(123 &amp;&amp; 456); // 输出 456
console.log(0 &amp;&amp; 456); // 输出 0
console.log(0 &amp;&amp; 456 &amp;&amp; 789 * 2); // 输出 0
console.log(123 &amp;&amp; 456 &amp;&amp; 789 * 2); // 输出 789*2 == console.log(123 &amp;&amp; (456 &amp;&amp; (789 * 2)));
// 逻辑或的短路运算：
console.log(123 || 456); // 输出 123
console.log(0 || 456); // 输出 456
console.log(0 || 456 || 789 * 2); // 输出 456
console.log(0 || &quot;&quot; || 789 * 2); // 输出 789*2 == console.log((0 || &quot;&quot;) || (789 * 2));
// 逻辑非的短路运算：如果操作数为假，则返回真，否则返回假
console.log(!123); // 输出 false
console.log(!0); // 输出 true
console.log(!&quot;&quot;); // 输出 true
console.log(!&quot;0&quot;); // 输出 false
</code></pre>
<p><strong>注意点</strong></p>
<pre><code class="javascript">var num=;
console.log(123 || num++);
console.log(num);
//结果为123,根本没有进行到num++
</code></pre>
<h4 id="6-赋值运算符"><a href="#6-赋值运算符" class="headerlink" title="6.赋值运算符"></a>6.赋值运算符</h4><p>概念:用来把数据赋值给变量的运算符。</p>
<table>
<thead>
<tr>
<th>赋值运算符</th>
<th>说明</th>
<th>案例</th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;</td>
<td>直接赋值</td>
<td><code>var usrName = &#39;我是值&#39;;</code></td>
</tr>
<tr>
<td>+&#x3D;, -&#x3D;</td>
<td>加、减一个数后再赋值</td>
<td><code>var age = 10; age += 5; // 15</code></td>
</tr>
<tr>
<td>*&#x3D;, &#x2F;&#x3D;, %&#x3D;</td>
<td>乘、除、取模后再赋值</td>
<td><code>var age = 2; age *= 5; // 10</code></td>
</tr>
</tbody></table>
<h4 id="7-运算符优先级"><a href="#7-运算符优先级" class="headerlink" title="7.运算符优先级"></a>7.运算符优先级</h4><p>| 优先级 | 运算符     | 顺序                |<br>| —— | ———- | ——————- | — | — |<br>| 1      | 小括号     | <code>()</code>                |<br>| 2      | 一元运算符 | <code>++ -- !</code>           |<br>| 3      | 算数运算符 | 先 <code>* / %</code> 后 <code>+ -</code> |<br>| 4      | 关系运算符 | <code>&gt; &gt;= &lt; &lt;=</code>         |<br>| 5      | 相等运算符 | <code>== != === !==</code>     |<br>| 6      | 逻辑运算符 | 先 <code>&amp;&amp;</code> 后 <code>       |     |</code>   |<br>| 7      | 赋值运算符 | <code>=</code>                 |<br>| 8      | 逗号运算符 | <code>,</code>                 |</p>
<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><p>在一个程序执行的过程中，各条代码的<strong>执行顺序对程序的结果</strong>是有直接影响的。很多时候我们要通过控制代码的执行顺序来实现我们要完成的功能。</p>
<p>简单理解:流程控制就是来控制我们的代码按照什么结构顺序来执行</p>
<p>流程控制主要有三种结构，分别是<strong>顺序结构</strong>、<strong>分支结构</strong>和<strong>循环结构</strong>，这三种结构代表三种代码执行的顺序。</p>
<p><img src="/2024/10/14/javascript-xue-xi/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6.png" alt="image-20240831110247247"></p>
<h4 id="1-顺序控制"><a href="#1-顺序控制" class="headerlink" title="1.顺序控制"></a>1.顺序控制</h4><p>顺序结构是程序中最简单、最基本的流程控制，它没有特定的语法结构，程序会按照代码的先后顺序，依次执行程序中大多数的代码都是这样执行的。</p>
<h4 id="2-分支结构"><a href="#2-分支结构" class="headerlink" title="2.分支结构"></a>2.分支结构</h4><p>由上到下执行代码的过程中，<strong>根据不同的条件</strong>，执行不同的路径代码(执行代码多选一的过程)，从而得到不同的结果</p>
<h5 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h5><p><strong>if 语句</strong>是一种控制流语句，用于根据指定条件的真伪来执行不同的代码块。它通常用于简单条件判断，适合处理逻辑表达式的评估，并根据条件的结果执行不同的操作。</p>
<p><strong>语法:</strong></p>
<pre><code class="javascript">if语法结构

if (条件表达式1) &#123;
    // 条件表达式1为true时执行的代码
&#125; else if(条件表达式2) &#123;
    // 条件表达式2满足时执行的代码
&#125;else &#123;
    // 条件表达式为false时执行的代码
&#125;
条件表达式可以是任意表达式，包括变量、运算符、函数调用等
</code></pre>
<h5 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h5><p><strong>switch 语句</strong>也是多分支语句，它用于基于不同的条件来执行不同的代码。当要针对变量设置一系列的<strong>特定值</strong><br>的选项时，就可以使用 switch。</p>
<p><strong>语法:</strong></p>
<pre><code class="javascript">switch语法结构

switch (表达式) &#123;
    case 值1:
        // 值1时执行的代码
        break;
    case 值2:
        // 值2时执行的代码
        break;
    default:
        // 值都不匹配时执行的代码
&#125;
表达式可以是变量、运算符、函数调用等，值可以是任意值


var num = 2;
switch (num) &#123;
    case 1:
        alert(num + &quot;=1&quot;);
        break;
    case 2:	//注意case后面的值要和num全(类型和值)等才行
        alert(num + &quot;=2&quot;);
        break;
&#125;
</code></pre>
<h5 id="switch语句和if-else-if语句的区别"><a href="#switch语句和if-else-if语句的区别" class="headerlink" title="switch语句和if-else-if语句的区别"></a><code>switch</code>语句和<code>if-else-if</code>语句的区别</h5><ol>
<li>一般情况下，它们两个语句可以相互替换</li>
<li>switch..case 语句通常处理 case 为比较确定值的情况，而 if..else..语句更加灵活，常用于范围判断(大于<br>等于某个范围)</li>
<li>switch 语句进行条件判断后直接执行到程序的条件语句，效率更高。而 if..else 语句有几种条件，就得判断多少次。</li>
<li>当分支比较少时，if…else 语句的执行效率比 switch 语句高</li>
<li>当分支比较多时，switch 语句的执行效率比较高，而且结构更清晰，</li>
</ol>
<h4 id="3-三元运算符和三元表达式"><a href="#3-三元运算符和三元表达式" class="headerlink" title="3.三元运算符和三元表达式"></a>3.三元运算符和三元表达式</h4><p><code>三元运算符（Ternary Operator）</code>是一种在编程语言中用于简化条件语句的表达方式。它通常用于根据某个条件返回两个值之一。</p>
<p><strong>三元运算符的语法如下：</strong></p>
<pre><code class="javascript">条件 ? 表达式1 : 表达式2;

let a = 5;
let b = 10;

// 使用三元运算符
let max = a &gt; b ? a : b; // max将会是10
</code></pre>
<ul>
<li>如果条件为真（true），则返回 <code>表达式1</code> 的值。</li>
<li>如果条件为假（false），则返回 <code>表达式2</code> 的值。</li>
</ul>
<h4 id="4-循环结构"><a href="#4-循环结构" class="headerlink" title="4.循环结构"></a>4.循环结构</h4><h5 id="4-1-循环"><a href="#4-1-循环" class="headerlink" title="4.1 循环"></a>4.1 循环</h5><p>在实际问题中，有许多<strong>具有规律性的重复操作</strong>，因此在程序中要完成这类操作就需要<strong>重复执行某些语句</strong></p>
<h5 id="4-2-for-循环"><a href="#4-2-for-循环" class="headerlink" title="4.2 for 循环"></a>4.2 for 循环</h5><p>在程序中，一组被重复执行的语句被称之为循环体，能否继续重复执行，取决于循环的终止条件。由循环体及循环的终止条件组成的语句，被称之为循环语句</p>
<p><strong>语法结构</strong></p>
<pre><code class="javascript">for (初始化变量; 条件表达式; 操作表达式) &#123;
  //循环体
&#125;
</code></pre>
<ol>
<li>初始化变量 就是用<strong>var 声明</strong>的一个普通变量,通常用于作为计数器使用</li>
<li>条件表达式 就是用来决定每一次循环是否继续执行,就是终止的条件</li>
<li>操作表达式 是每次循环最后执行的代码,经常用于我们计数器变量进行更新(递增或者递减)</li>
</ol>
<h5 id="4-3-while-循环"><a href="#4-3-while-循环" class="headerlink" title="4.3 while 循环"></a>4.3 while 循环</h5><pre><code class="javascript">while (条件表达式) &#123;
  //循环体
&#125;
</code></pre>
<p><strong>当条件表达式为真时,执行循环体</strong></p>
<h5 id="4-4-do-while-循环"><a href="#4-4-do-while-循环" class="headerlink" title="4.4 do-while 循环"></a>4.4 do-while 循环</h5><pre><code class="javascript">do &#123;
  //循环体
&#125; while (条件表达式);
</code></pre>
<p><strong>先执行一次循环体,在判断条件表达式,如果为真,再次执行循环体</strong></p>
<p>do…while 循环语句至少会执行一次循环体代码</p>
<h4 id="break-和-continue"><a href="#break-和-continue" class="headerlink" title="break 和 continue"></a>break 和 continue</h4><h5 id="continue-关键字"><a href="#continue-关键字" class="headerlink" title="continue 关键字"></a>continue 关键字</h5><p><code>continue</code>关键字用于<strong>立即跳出本次循环</strong>，<strong>继续下一次循环</strong>(本次循环体中 continue 之后的代码就会少执行一次)。</p>
<p>例如，吃 5 个包子，第 3 个有虫子，就扔掉第 3 个，继续吃第 4 个第 5 个包子，其代码实现如下</p>
<pre><code class="javascript">for (var i = 1; i &lt;= 5; i++) &#123;
  if (i == 3) &#123;
    continue;
  &#125; else &#123;
    console.log(&quot;我吃了第&quot; + i + &quot;个包子&quot;);
  &#125;
&#125;
</code></pre>
<h5 id="break-关键字"><a href="#break-关键字" class="headerlink" title="break 关键字"></a>break 关键字</h5><p><strong>break 关键字用于立即跳出整个循环(循环结束)</strong><br>例如，吃 5 个包子，吃到第 3 个发现里面有半个虫子，其余的不吃了</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="1-数组的概念"><a href="#1-数组的概念" class="headerlink" title="1.数组的概念"></a>1.数组的概念</h4><p><strong>数组是指一组数据的集合</strong>，其中的每个数据被称作元素，在数组中可以存放任意类型的元素。数组是一<br>种将一组数据存储在单个变量名下的优雅方式。</p>
<h4 id="2-创建数组"><a href="#2-创建数组" class="headerlink" title="2. 创建数组"></a>2. 创建数组</h4><ol>
<li>使用 new 关键字创建数组</li>
</ol>
<pre><code class="javascript">var 数组名 = new Arr();
var arr = new Array(); //创建一个新的空数组
</code></pre>
<ol start="2">
<li>利用数组字面量创建数组</li>
</ol>
<pre><code class="javascript">//1.使用数组字面量方式创建空的数组
var 数组名 = [];

//2.使用数组字面量方式创建带初始值的数组
var 数组名 =[&quot;小白&quot;，&#39;小黑&#39;，&#39;大黄&#39;，&quot;瑞奇&quot;];
</code></pre>
<ul>
<li>数组的字面量是<strong>方括号[]</strong></li>
<li>声明数组并赋值称为数组的初始化</li>
</ul>
<h4 id="3-获取数组里的元素"><a href="#3-获取数组里的元素" class="headerlink" title="3.获取数组里的元素"></a>3.获取数组里的元素</h4><h4 id="3-1-数组的索引"><a href="#3-1-数组的索引" class="headerlink" title="3.1 数组的索引"></a>3.1 数组的索引</h4><p>索引(下标):用来访问数组元素的序号(数组下标<strong>从 0 开始</strong>)。</p>
<h4 id="3-2-遍历数组"><a href="#3-2-遍历数组" class="headerlink" title="3.2 遍历数组"></a>3.2 遍历数组</h4><p>使用循环,不断更改索引值,遍历数组</p>
<pre><code class="javascript">for (var i = 0; i &lt; arr.length; i++) &#123;
  console.log(arr[i]);
&#125;
</code></pre>
<h4 id="4-数组中新增元素"><a href="#4-数组中新增元素" class="headerlink" title="4.数组中新增元素"></a>4.数组中新增元素</h4><h5 id="4-1-通过修改-length-长度新增数组元素"><a href="#4-1-通过修改-length-长度新增数组元素" class="headerlink" title="4.1 通过修改 length 长度新增数组元素"></a>4.1 通过修改 length 长度新增数组元素</h5><ul>
<li>可以通过修改 length 长度来实现数组扩容的目的</li>
<li>length 属性是<strong>可读写的</strong></li>
</ul>
<pre><code class="javascript">var arr = [1, 2, 3, 4, 5];
console.log(arr.length); // 5
arr.length = 8;
console.log(arr); // [1, 2, 3, 4, 5, undefined, undefined, undefined]
arr.length = 3;
console.log(arr); // [1, 2, 3]
</code></pre>
<p><strong>声明变量未给值，默认值就是 undefined</strong></p>
<h5 id="4-2-通过数组索引号添加元素"><a href="#4-2-通过数组索引号添加元素" class="headerlink" title="4.2 通过数组索引号添加元素"></a>4.2 通过数组索引号添加元素</h5><pre><code class="javascript">// 数组的索引添加元素
arr[3] = 6;
console.log(arr); // [1, 2, 3, 6]
</code></pre>
<ul>
<li>可以通过修改数组索引的方式追加数组元素</li>
<li>不能直接给数组名赋值，否则会覆盖掉以前的数据</li>
</ul>
<h4 id="5-数组案例"><a href="#5-数组案例" class="headerlink" title="5.数组案例"></a>5.数组案例</h4><h5 id="反转数组"><a href="#反转数组" class="headerlink" title="反转数组"></a>反转数组</h5><pre><code class="javascript">var arr1 = [1, 2, 3, 4];
var arr2 = [];
for (var i = arr1.length - 1; i &gt;= 0; i--) &#123;
  arr2[arr2.length] = arr1[i];
&#125;
</code></pre>
<h5 id="数组排序-冒泡排序"><a href="#数组排序-冒泡排序" class="headerlink" title="数组排序(冒泡排序)"></a>数组排序(冒泡排序)</h5><pre><code class="javascript">var arr = [5, 3, 8, 6, 2, 7, 1, 4];
function bubbleSort(arr) &#123;
  var len = arr.length;
  for (var i = 0; i &lt; len - 1; i++) &#123;
    for (var j = 0; j &lt; len - i - 1; j++) &#123;
      if (arr[j] &gt; arr[j + 1]) &#123;
        var temp = arr[j];
        arr[j] = arr[j + 1];
        arr[j + 1] = temp;
      &#125;
    &#125;
  &#125;
  return arr;
&#125;
console.log(bubbleSort(arr));
</code></pre>
<h3 id="JavaScript-函数"><a href="#JavaScript-函数" class="headerlink" title="JavaScript 函数"></a>JavaScript 函数</h3><h4 id="1-函数的概念"><a href="#1-函数的概念" class="headerlink" title="1.函数的概念"></a>1.函数的概念</h4><p>在 JS 里面，可能会定义非常多的相同代码或者功能相似的代码，这些代码可能需要大量重复使用,虽然 for 循环语句也能实现一些简单的重复操作，但是比较具有局限性，此时我们就可以<strong>使用 JavaScript 中的函数</strong>。</p>
<p><strong>函数:<strong>就是</strong>封装了一段可被重复调用执行的代码块</strong>。通过此代码块可以实现大量代码的重复使用。</p>
<h4 id="2-函数的使用"><a href="#2-函数的使用" class="headerlink" title="2.函数的使用"></a>2.函数的使用</h4><h5 id="声明函数"><a href="#声明函数" class="headerlink" title="声明函数"></a>声明函数</h5><p><strong>语法规范</strong></p>
<pre><code class="javascript">function 函数名(参数...) &#123;
    函数体代码
&#125;
function getSum(a, b) &#123;
    max = a &gt; b ? a : b;
    min = a &lt; b ? a : b;
    var sum = 0;
    for (var i = min; i &lt;= max; i++) &#123;
        sum += i;
    &#125;
    return sum;
&#125;
console.log(getSum(100, 10));
</code></pre>
<h5 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h5><p><strong>函数不调用,自己不调用</strong></p>
<p><strong>调用方法:</strong> <code>函数名();</code></p>
<h4 id="3-函数的参数"><a href="#3-函数的参数" class="headerlink" title="3.函数的参数"></a>3.函数的参数</h4><p>利用函数的参数,实现不同的执行结果</p>
<p>**参数的作用:**在函数内部某些值不能固定，我们可以通过参数在调用函数时传递不同的值进去</p>
<h5 id="3-1-形参和实参"><a href="#3-1-形参和实参" class="headerlink" title="3.1 形参和实参"></a>3.1 形参和实参</h5><p><strong>定义时写形参,调用时传实参</strong>(形参是接收实参的)</p>
<pre><code class="javascript">// a和b是形参
function getSum(a, b) &#123;
  max = a &gt; b ? a : b;
  min = a &lt; b ? a : b;
  var sum = 0;
  for (var i = min; i &lt;= max; i++) &#123;
    sum += i;
  &#125;
  return sum;
&#125;
// 100,10是实参
console.log(getSum(100, 10));
</code></pre>
<h5 id="3-2-形参和实参不匹配的问题"><a href="#3-2-形参和实参不匹配的问题" class="headerlink" title="3.2 形参和实参不匹配的问题"></a>3.2 形参和实参不匹配的问题</h5><pre><code class="javascript">function add(a, b) &#123;
  return a + b;
&#125;
// 1.形参和实参个数匹配,正常输出
console.log(add(1, 2)); // 3

// 2.形参个数小于实参
console.log(add(1, 2, 3)); // 会被截断参数，只取到1和2，3被忽略

//3.如果实参的个数小于形参的个数
//形参可以看做是不用声明的变量，num2 是一个变量但是没有接受值 结果就是undefined
console.log(add(1)); // 1 + undefined = NaN
</code></pre>
<p><strong>注意:在 JavaScript 中，形参的默认值是 undefined.</strong></p>
<h4 id="4-函数的返回值"><a href="#4-函数的返回值" class="headerlink" title="4.函数的返回值"></a>4.函数的返回值</h4><h5 id="4-1return-返回结果"><a href="#4-1return-返回结果" class="headerlink" title="4.1return 返回结果"></a>4.1return 返回结果</h5><p>只要函数<strong>遇到 return</strong>,就把<strong>结果返回给函数的调用者</strong>,后面的代码不执行,函数名() &#x3D; return 后面的结果</p>
<h5 id="4-2return-终止函数"><a href="#4-2return-终止函数" class="headerlink" title="4.2return 终止函数"></a>4.2return 终止函数</h5><pre><code class="javascript">function Sum(a, b) &#123;
  return a + b;
  console.log(&quot;这句话是不会被输出的,因为遇到return就终止函数&quot;);
&#125;
Sum();
</code></pre>
<h5 id="4-3-只能返回一个值"><a href="#4-3-只能返回一个值" class="headerlink" title="4.3 只能返回一个值"></a>4.3 只能返回一个值</h5><pre><code class="javascript">function Sum(a, b) &#123;
  return a, b;
&#125;
console.log(Sum(1, 2)); // 输出2
</code></pre>
<p><strong>return 语句只返回一个值(若有多个,则返回最后一个)</strong></p>
<h5 id="4-4-函数没有-return-语句-返回-undefined"><a href="#4-4-函数没有-return-语句-返回-undefined" class="headerlink" title="4.4 函数没有 return 语句 返回 undefined"></a>4.4 函数没有 return 语句 返回 undefined</h5><pre><code class="javascript">function func() &#123;
  console.log(&quot;hh&quot;);
&#125;
console.log(func()); // undefined
</code></pre>
<h4 id="5-arguments-的使用"><a href="#5-arguments-的使用" class="headerlink" title="5.arguments 的使用"></a>5.arguments 的使用</h4><p>当我们不确定有多少个参数传递的时候，可以用<code>arguments</code>来获取。在 JavaScript 中，arguments 实际上它是当前函数的<code>一个内置对象</code>。<strong>所有函数都内置了一个 arguments 对象</strong>，arguments 对象中<strong>存储了传递的所有实参</strong>。</p>
<pre><code class="javascript">// arguments是一个类数组对象，包含了传递给函数的所有参数
function fn() &#123;
  console.log(arguments);
&#125;

fn(1, 2, 3);
</code></pre>
<h5 id="类数组对象"><a href="#类数组对象" class="headerlink" title="类数组对象"></a>类数组对象</h5><p><strong>arguments 是一个类数组对象,里面有数组的一些属性,但并不是真正的数组</strong></p>
<ol>
<li><strong>length</strong>属性</li>
<li>按照<strong>索引</strong>方式存储</li>
<li>没有真正数组的一些方法,例如<code>pop()</code>,<code>push()</code></li>
</ol>
<h4 id="6-函数案例"><a href="#6-函数案例" class="headerlink" title="6.函数案例"></a>6.函数案例</h4><p>求任意个数的最大值</p>
<pre><code class="javascript">function getMax() &#123;
  var max = arguments[0];
  for (var i = 0; i &lt; arguments.length; i++) &#123;
    max = max &gt; arguments[i] ? max : arguments[i];
  &#125;
  return max;
&#125;
</code></pre>
<h4 id="7-函数的两种声明方式"><a href="#7-函数的两种声明方式" class="headerlink" title="7.函数的两种声明方式"></a>7.函数的两种声明方式</h4><h5 id="7-1-命名函数-function"><a href="#7-1-命名函数-function" class="headerlink" title="7.1 命名函数(function)"></a>7.1 命名函数(function)</h5><p>使用<strong>function</strong>定义函数</p>
<h5 id="7-2-函数表达式-匿名函数"><a href="#7-2-函数表达式-匿名函数" class="headerlink" title="7.2 函数表达式(匿名函数)"></a>7.2 函数表达式(匿名函数)</h5><p>语法: <code>var 变量名 = function()&#123;&#125;;</code></p>
<h4 id="8-函数的内置方法"><a href="#8-函数的内置方法" class="headerlink" title="8. 函数的内置方法"></a>8. 函数的内置方法</h4><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function">Function</a> 实例的 <strong><code>apply()</code></strong> 方法会以给定的 <code>this</code> 值和作为数组（或<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Indexed_collections#%E4%BD%BF%E7%94%A8%E7%B1%BB%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1">类数组对象</a>）提供的 <code>arguments</code> 调用该函数。</p>
<pre><code class="javascript">var arr = [1, 2, 3, 4, 5];
Math.max.apply();
</code></pre>
<h3 id="JavaScript-作用域"><a href="#JavaScript-作用域" class="headerlink" title="JavaScript 作用域"></a>JavaScript 作用域</h3><h4 id="1-作用域"><a href="#1-作用域" class="headerlink" title="1.作用域"></a>1.作用域</h4><h5 id="1-1-作用域的概述"><a href="#1-1-作用域的概述" class="headerlink" title="1.1 作用域的概述"></a>1.1 作用域的概述</h5><p>通常来说，一段程序代码中所用到的名字并不总是有效和可用的，而限定<strong>这个名字的可用性的代码范围就是这个名字的作用域</strong>。作用域的使用提高了<strong>程序逻辑的局部性</strong>，增强了程序的可靠性，<strong>减少了名字冲突</strong>。</p>
<h4 id="2-全局作用域和局部作用域"><a href="#2-全局作用域和局部作用域" class="headerlink" title="2.全局作用域和局部作用域"></a>2.全局作用域和局部作用域</h4><ul>
<li><p><strong>全局作用域: 整个<code>&lt;script&gt;</code>标签,或者是一个单独的<code>js</code>文件</strong></p>
</li>
<li><p><strong>局部作用域: 在函数内部就是局部作用域,这个代码的名字只在函数内部起效果和作用</strong></p>
</li>
</ul>
<h4 id="3-变量的作用域"><a href="#3-变量的作用域" class="headerlink" title="3.变量的作用域"></a>3.变量的作用域</h4><h5 id="3-1-变量作用域的分类"><a href="#3-1-变量作用域的分类" class="headerlink" title="3.1 变量作用域的分类"></a>3.1 变量作用域的分类</h5><p>在 JavaScript 中，根据作用域的不同，变量可以分为两种:</p>
<ul>
<li>局部变量</li>
</ul>
<pre><code class="javascript">// 2.局部变量在局部作用域下的变量 后者在函数内部的变量就是 局部变量
// 函数的形参也可以当作局部变量
function fun(argu) &#123;
  var num1 = 10; // num1就是局部变量 只能在函数内部使用
  var num2 = 20;
  fun();
&#125;
</code></pre>
<ul>
<li>全局变量</li>
</ul>
<pre><code class="javascript">// 1.全局变量: 在全局作用域下的变量 在全局下都可以使用
// 注意 如果在函数内部 没有声明直接赋值的变量也属于全局变量

var num = 10; //num就是一个全局变量
console.log(num);
function fn() &#123;
  console.log(num);
&#125;
fn();
</code></pre>
<h5 id="3-2-从执行效率来看全局变量和局部变量"><a href="#3-2-从执行效率来看全局变量和局部变量" class="headerlink" title="3.2 从执行效率来看全局变量和局部变量"></a>3.2 从执行效率来看全局变量和局部变量</h5><ol>
<li>全局变量只有<strong>浏览器关闭</strong>的时候才会销毁，比较占内存资源</li>
<li>局部变量,当<strong>程序执行完毕</strong>就会销毁</li>
</ol>
<h5 id="4-作用域链"><a href="#4-作用域链" class="headerlink" title="4. 作用域链"></a>4. 作用域链</h5><ul>
<li>只要是代码，就至少有一个作用域</li>
<li>写在函数内部的局部作用域</li>
<li>如果<strong>函数中还有函数</strong>，那么在这个作用域中就又可以诞生一个作用域</li>
<li>根据在<strong>内部函数可以访问外部函数变量</strong>的这种机制，用链式查找决定哪些数据能被内部函数访问，就称作<strong>作用域链</strong></li>
</ul>
<p><strong>链式查找: 内部函数先访问内部变量,如果没有该同名变量,则使用外部函数的变量,再没有则去找全局变量</strong></p>
<pre><code class="javascript">var num = 0;
function fun1() &#123;
    // 外部函数
    var num = 10;
    function fun2() &#123;
        // 内部函数
        var num = 20;
        console.log(num);
    &#125;
    fun2();
    console.log(num);
&#125;
fun1();
console.log(num);

输出结果: 20 10 0
</code></pre>
<h3 id="JavaScript-预解析"><a href="#JavaScript-预解析" class="headerlink" title="JavaScript 预解析"></a>JavaScript 预解析</h3><h4 id="预解析"><a href="#预解析" class="headerlink" title="预解析"></a>预解析</h4><p>JavaScript 代码是由浏览器中的 JavaScript 解析器来执行的。JavaScript 解析器在运行 JavaScript 代码的时候分为两步:<strong>预解析</strong>和<strong>代码执行</strong>。</p>
<p><strong>预解析</strong>:js 引擎会把 js 里面所有的<code>var</code>还有<code>function</code>提升到当前作用域的最前面</p>
<p><strong>代码执行</strong>:按照代码书写的顺序从上往下执行</p>
<h4 id="变量预解析和函数预解析"><a href="#变量预解析和函数预解析" class="headerlink" title="变量预解析和函数预解析"></a>变量预解析和函数预解析</h4><h5 id="变量提升-预解析"><a href="#变量提升-预解析" class="headerlink" title="变量提升(预解析)"></a>变量提升(预解析)</h5><p>**变量提升:**就是把所有的变量声明提升到当前的作用域最前面,不提升赋值操作</p>
<pre><code class="javascript">console.log(num); // undefined
var num = 10;
</code></pre>
<p>首先进行变量提升,相当于把所有变量(num)定义,执行<code>var num</code>步骤</p>
<p>然后才开始按顺序执行代码,所以输出 undefined</p>
<pre><code class="javascript">var fun = function () &#123;
  console.log(&quot;fun是一个函数变量&quot;);
&#125;;
fun(); // 报错: fun不是函数

相当于以下代码;
var fun;
var fun = function () &#123;
  console.log(&quot;fun是一个函数变量&quot;);
&#125;;
fun(); // &quot;fun是一个函数变量&quot;
</code></pre>
<h5 id="函数预解析"><a href="#函数预解析" class="headerlink" title="函数预解析"></a>函数预解析</h5><p><strong>函数提升</strong>:就是把所有的函数声明提升到当前作用域的最前面,<strong>不调用函数</strong></p>
<pre><code class="javascript">fun(); // 可以输出
function fun() &#123;
  console.log(&quot;hello world&quot;);
&#125;
</code></pre>
<h4 id="预解析案例"><a href="#预解析案例" class="headerlink" title="预解析案例"></a>预解析案例</h4><pre><code class="javascript">//案例3
var a = 18;
f1();
function f1() &#123;
  var b = 9;
  console.log(a);
  console.log(b);
  var a = &quot;123&quot;;
&#125;
</code></pre>
<p>相当于以下代码</p>
<pre><code class="javascript">var a;
function() &#123;
    var b;
    var a
    b = 9;
    console.log(a); // undefined
    console.log(b);	// 9
    a = &#39;123&#39;;
&#125;
a = 18;
f1();
</code></pre>
<p><code>var a = b = c = 9;</code> 相当于<code>var a = 9; b = 9; c = 9;</code></p>
<p><strong>b 和 c 直接赋值,没有 var 声明,当全局变量看</strong></p>
<h3 id="JavaScript-对象"><a href="#JavaScript-对象" class="headerlink" title="JavaScript 对象"></a>JavaScript 对象</h3><h4 id="1-什么是对象"><a href="#1-什么是对象" class="headerlink" title="1. 什么是对象?"></a>1. 什么是对象?</h4><p><strong>面向对象(Object Oriented Programming)</strong>,简称<code>oop</code></p>
<p>对象是由<strong>属性和方法</strong>组成的。</p>
<ul>
<li>属性:事物的<strong>特征</strong>，在对象中用属性来表示(常用名词)</li>
<li>方法:事物的<strong>行为</strong>，在对象中用方法来表示(常用动词 )</li>
</ul>
<h4 id="2-为什么需要对象"><a href="#2-为什么需要对象" class="headerlink" title="2. 为什么需要对象"></a>2. 为什么需要对象</h4><p>保存一个值时，可以使用<strong>变量</strong>，保存多个值(一组值)时，可以使用<strong>数组</strong>。如果要保存一个人的完整信息呢?</p>
<p>这个时候,就需要使用到<strong>对象</strong></p>
<h4 id="3-创建对象的三种方式"><a href="#3-创建对象的三种方式" class="headerlink" title="3. 创建对象的三种方式"></a>3. 创建对象的三种方式</h4><h5 id="3-1-利用字面量创建对象"><a href="#3-1-利用字面量创建对象" class="headerlink" title="3.1 利用字面量创建对象"></a>3.1 利用字面量创建对象</h5><p>**对象字面量:**就是<code>花括号&#123;&#125;</code>里面包含了表达这个具体事物(对象)的属性和方法</p>
<pre><code class="javascript">// 创建空对象
var obj = &#123;&#125;;

// 创建对象
var obj = &#123;
  uname: &quot;0zxm&quot;,
  age: 18,
  sayHi: function () &#123;
    console.log(&quot;hello&quot;);
  &#125;,
&#125;;
</code></pre>
<ul>
<li>里面的属性或者方法我们采取<strong>键值对</strong>的形式 <code>键 属性名: 值 属性值</code></li>
<li>多个属性或者方法中间用<strong>逗号</strong>隔开的</li>
<li>方法冒号后面跟的是一个<strong>匿名函数</strong></li>
</ul>
<h6 id="使用对象"><a href="#使用对象" class="headerlink" title="使用对象"></a>使用对象</h6><ol>
<li>调用对象的属性,我们采取<strong>对象名.属性名</strong>或者<strong>对象名[‘属性名’]</strong></li>
<li>调用对象的方法,我们使用<strong>对象名.方法名()</strong></li>
</ol>
<h5 id="3-2-利用-new-Object-关键字创建"><a href="#3-2-利用-new-Object-关键字创建" class="headerlink" title="3.2 利用 new Object 关键字创建"></a>3.2 利用 new Object 关键字创建</h5><p>语法: <code>var obj = new Object();</code> 创建对象,然后使用<code>对象名.属性名</code> 或者 <code>对象名.方法名()</code>来添加属性和方法</p>
<pre><code class="javascript">// 创建空对象
var obj = new Object();
obj.uname = &quot;0zxm&quot;;
obj.age = 18;
obj.sayHi = function () &#123;
  console.log(&quot;hello&quot;);
&#125;;
</code></pre>
<h5 id="3-3-构造函数"><a href="#3-3-构造函数" class="headerlink" title="3.3 构造函数"></a>3.3 构造函数</h5><p><strong>语法:</strong><code>function 构造函数名(形参列表)&#123;this.属性 = 值;this.方法= function()&#123;&#125;&#125;</code></p>
<p>使用 <code>new 构造函数名(实参列表);</code>来创建对象</p>
<ul>
<li>构造函数首字母要大写(规范)</li>
<li>构造函数不需要 return 值</li>
</ul>
<p>利用构造函数创建对象的过程我们也称为<strong>对象的实例化</strong></p>
<h5 id="new-关键字"><a href="#new-关键字" class="headerlink" title="new 关键字"></a>new 关键字</h5><p>new 在执行时会做四件事情:</p>
<ol>
<li>在内存中创建一个新的空对象。</li>
<li>让 this 指向这个新的对象。</li>
<li>执行构造函数里面的代码，给这个新对象添加属性和方法。</li>
<li>返回这个新对象(所以构造函数里面不需要 return)</li>
</ol>
<h4 id="4-遍历对象属性"><a href="#4-遍历对象属性" class="headerlink" title="4. 遍历对象属性"></a>4. 遍历对象属性</h4><h5 id="4-1-新的遍历方式for-in"><a href="#4-1-新的遍历方式for-in" class="headerlink" title="4.1 新的遍历方式for..in.."></a>4.1 新的遍历方式<code>for..in..</code></h5><p><code>for...in</code>语句用于对数组或者对象的属性进行循环操作。</p>
<pre><code class="javascript">// 定义一个对象
var person = &#123;
  name: &quot;John&quot;,
  age: 30,
  city: &quot;New York&quot;,
&#125;;

// 使用for-in语句遍历对象
for (var key in person) &#123;
  console.log(key + &quot; : &quot; + person[key]);
&#125;
</code></pre>
<h3 id="JavaScript-内置对象"><a href="#JavaScript-内置对象" class="headerlink" title="JavaScript 内置对象"></a>JavaScript 内置对象</h3><h4 id="1-内置对象"><a href="#1-内置对象" class="headerlink" title="1. 内置对象"></a>1. 内置对象</h4><ul>
<li><p>JavaScript 中的对象分为 3 种:<strong>自定义对象</strong>、<strong>内置对象</strong>、<strong>浏览器对象</strong></p>
</li>
<li><p>前面两种对象是 JS 基础内容，属于<code>ECMAScript</code>;第三个浏览器对象属于我们 JS 独有的<strong>API</strong></p>
</li>
</ul>
<h4 id="2-查文档"><a href="#2-查文档" class="headerlink" title="2. 查文档"></a>2. 查文档</h4><h5 id="2-1-MDN"><a href="#2-1-MDN" class="headerlink" title="2.1 MDN"></a>2.1 MDN</h5><p>学习一个内置对象的使用，只要学会其常用成员的使用即可，我们可以通过查文档学习，可以通过<strong>MDN</strong>&#x2F;<strong>W3C</strong>来查询。</p>
<p>Mozilla 开发者网络(MDN)提供了有关开放网络技术(Open Web)的信息，包括 HTML、CSS 和万维网及 HTML5 应用的 API</p>
<p>MDN: <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/">https://developer.mozilla.org/zh-CN/</a></p>
<h5 id="2-2-如何学习对象中的方法"><a href="#2-2-如何学习对象中的方法" class="headerlink" title="2.2 如何学习对象中的方法"></a>2.2 如何学习对象中的方法</h5><ol>
<li>查阅该方法的功能</li>
<li>查看里面参数的意义和类型</li>
<li>查看返回值的意义和类型</li>
</ol>
<h4 id="3-Math-对象"><a href="#3-Math-对象" class="headerlink" title="3. Math 对象"></a>3. Math 对象</h4><h5 id="常用方法和成员"><a href="#常用方法和成员" class="headerlink" title="常用方法和成员"></a>常用方法和成员</h5><ul>
<li><p><code>Math.PI</code> - Π 常量</p>
</li>
<li><p><code>Math.max()</code> - 传入任意个数值,如果给定的参数中至少有一个参数无法被转换成数字,则返回<code>NaN</code>,否则返回最大值,如果参数为空,返回<code>-Infinity</code></p>
</li>
<li><p><code>Math.floor()</code> - 向下取整</p>
</li>
<li><p><code>Math.ceil()</code> - 向上取整</p>
</li>
<li><p><code>Math .round()</code> - 四舍五入版,就近取整 注意 -3.5 结果是 -3,<strong>其他数字都是四舍五入，但是 .5 特殊,它往大了取</strong></p>
</li>
<li><p><code>Math.abs()</code> - 绝对值(会把字符串变量<strong>隐式转换</strong>成数字)</p>
</li>
</ul>
<h5 id="random-函数"><a href="#random-函数" class="headerlink" title="random()函数"></a>random()函数</h5><p><strong>返回值</strong>: <code>[0, 1)</code>的一个浮点数</p>
<p><strong>参数</strong>: 不需要带参数</p>
<p>我们想要得到两个数之间的随机整数,包含这两个数,可以使用<code>getRandomIntInclusive</code>方法</p>
<pre><code class="javascript">function getRandomIntInclusive(min, max) &#123;
  const minCeiled = Math.ceil(min);
  const maxFloored = Math.floor(max);
  return Math.floor(Math.random() * (maxFloored - minCeiled + 1) + minCeiled); // 包含最小值和最大值
&#125;
</code></pre>
<h4 id="4-Date-对象"><a href="#4-Date-对象" class="headerlink" title="4.Date 对象"></a>4.Date 对象</h4><p><strong>Date 对象</strong>必须使用<code>new Date();</code>构造函数来创建日期对象</p>
<h5 id="4-1-构造函数"><a href="#4-1-构造函数" class="headerlink" title="4.1 构造函数"></a>4.1 构造函数</h5><ol>
<li>空参构造: 返回系统当前时间</li>
<li>带参(数字)构造: <code>var date = new Date(2019,10,1);</code><strong>输出的却是 Nov,因为是从 0 开始</strong></li>
<li>带参(字符串)构造: <code>var date = new Date(&quot;2018-10-14&quot;);</code></li>
</ol>
<h5 id="4-2-日期格式化"><a href="#4-2-日期格式化" class="headerlink" title="4.2 日期格式化"></a>4.2 日期格式化</h5><table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
<th>代码</th>
</tr>
</thead>
<tbody><tr>
<td>getFullYear()</td>
<td>获取当年</td>
<td><code>dObj.getFullYear()</code></td>
</tr>
<tr>
<td>getMonth()</td>
<td>获取当月（0-11）</td>
<td><code>dObj.getMonth()</code></td>
</tr>
<tr>
<td>getDate()</td>
<td>获取当天日期</td>
<td><code>dObj.getDate()</code></td>
</tr>
<tr>
<td>getDay()</td>
<td>获取星期几（周日 0 到周六 6）</td>
<td><code>dObj.getDay()</code></td>
</tr>
<tr>
<td>getHours()</td>
<td>获取当前小时</td>
<td><code>dObj.getHours()</code></td>
</tr>
<tr>
<td>getMinutes()</td>
<td>获取当前分钟</td>
<td><code>dObj.getMinutes()</code></td>
</tr>
<tr>
<td>getSeconds()</td>
<td>获取当前秒钟</td>
<td><code>dObj.getSeconds()</code></td>
</tr>
</tbody></table>
<h5 id="4-3-获取日期的总的毫秒形式-时间戳"><a href="#4-3-获取日期的总的毫秒形式-时间戳" class="headerlink" title="4.3 获取日期的总的毫秒形式(时间戳)"></a>4.3 获取日期的总的毫秒形式(时间戳)</h5><p>Date 对象是基于 1970 年 1 月 1 日(世界标准时间)起的毫秒数</p>
<p><strong>为什么计算机起始时间从 1970 年开始?</strong></p>
<p>我们经常利用总的毫秒数来计算时间，因为它更精确</p>
<ul>
<li><code>valueOf()函数</code></li>
<li><code>getTime()函数</code></li>
<li><code>var date = +new Date();</code></li>
<li><code>Date.now()</code></li>
</ul>
<pre><code class="javascript">var date = new Date();
console.log(date.valueOf());
console.log(date.getTime());
console.log(+new Date());
console.log(Date.now());
</code></pre>
<h5 id="4-4-案例"><a href="#4-4-案例" class="headerlink" title="4.4 案例"></a>4.4 案例</h5><pre><code class="javascript">function countDown(time) &#123;
  let nowTime = Date.now();
  let inputTime;
  try &#123;
    inputTime = new Date(time).getTime(); // 用户输入的时间
  &#125; catch (e) &#123;
    console.error(&quot;Invalid date format&quot;);
    return &quot;Invalid date format&quot;;
  &#125;
  let times = inputTime - nowTime; // 剩余时间总的毫秒数
  if (times &lt; 0) return &quot;Countdown expired&quot;;

  let d = Math.floor(times / (1000 * 60 * 60 * 24)); // 天
  let h = Math.floor((times / (1000 * 60 * 60)) % 24); // 时
  let m = Math.floor((times / (1000 * 60)) % 60); // 分
  let s = Math.floor((times / 1000) % 60); // 秒

  return `$&#123;d&#125;天$&#123;h&#125;时$&#123;m&#125;分$&#123;s&#125;秒`;
&#125;

console.log(countDown(&quot;2024-12-31&quot;));
</code></pre>
<h4 id="5-Array-数组对象"><a href="#5-Array-数组对象" class="headerlink" title="5.Array 数组对象"></a>5.Array 数组对象</h4><h5 id="5-1-创建数组"><a href="#5-1-创建数组" class="headerlink" title="5.1 创建数组"></a>5.1 创建数组</h5><ul>
<li>利用数组字面量: <code>var arr = [1, 2, 3];</code></li>
<li>利用 new 关键字:<ul>
<li><code>var arr = new Array();</code> 创建一个空数组</li>
<li><code>var arr = new Array(2);</code> 创建一个长度为 2 的空数组,里面有两个空数组元素</li>
<li><code>var arr = new Array(2,3);</code> 创建一个长度为 2 的数组,里面存放 2 和 3</li>
</ul>
</li>
</ul>
<h5 id="5-2-检测是否为数组"><a href="#5-2-检测是否为数组" class="headerlink" title="5.2 检测是否为数组"></a>5.2 检测是否为数组</h5><p><strong>instanceof &#x2F; Array.isArray()</strong> 可以用来检测是否为数组</p>
<pre><code class="javascript">// 检测是否为数组
var arr = [];
var obj = &#123;&#125;;

// 使用 instanceof 检测是否为数组
try &#123;
  console.log(arr instanceof Array); // true
  console.log(obj instanceof Array); // false
&#125; catch (e) &#123;
  console.error(&quot;Error with instanceof check:&quot;, e);
&#125;

// 使用 Array.isArray 检测是否为数组（H5新增的方法，ie9以上版本支持）
try &#123;
  console.log(Array.isArray(arr)); // true
  console.log(Array.isArray(obj)); // false
&#125; catch (e) &#123;
  console.error(&quot;Error with Array.isArray check:&quot;, e);
&#125;
</code></pre>
<h5 id="5-3-数组添加和删除元素"><a href="#5-3-数组添加和删除元素" class="headerlink" title="5.3 数组添加和删除元素"></a>5.3 数组添加和删除元素</h5><table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td>push(参数 1, …)</td>
<td>在数组末尾添加一个或多个元素，会修改原数组。</td>
<td>返回新数组的长度</td>
</tr>
<tr>
<td>pop()</td>
<td>删除数组最后一个元素，数组长度减 1，无需参数，会修改原数组。</td>
<td>返回被删除元素的值</td>
</tr>
<tr>
<td>unshift(参数 1, …)</td>
<td>在数组开头添加一个或多个元素，会修改原数组。</td>
<td>返回新数组的长度</td>
</tr>
<tr>
<td>shift()</td>
<td>删除数组的第一个元素，数组长度减 1，无需参数，会修改原数组。</td>
<td>返回删除的第一个元素的值</td>
</tr>
</tbody></table>
<pre><code class="javascript">// pop() 方法用于删除并返回数组的最后一个元素，并将数组长度减一。
// push() 方法用于在数组的末尾添加一个或多个元素，并返回新的长度。
var arr = new Array(1, 2, 3);
arr.push(4, &quot;pink&quot;); // 添加元素到数组末尾
console.log(arr); // [1, 2, 3, 4]
arr.pop();
console.log(arr); // [1, 2, 3]

// shift() 方法用于删除并返回数组的第一个元素，并将数组长度减一。
// unshift() 方法用于在数组的开头添加一个或多个元素，并返回新的长度。
var arr = new Array(1, 2, 3);
arr.unshift(0, &quot;red&quot;); // 添加元素到数组开头
console.log(arr); // [0, &quot;red&quot;, 1, 2, 3]
arr.shift();
console.log(arr); // [&quot;red&quot;, 1, 2, 3]
</code></pre>
<h5 id="5-4-数组排序"><a href="#5-4-数组排序" class="headerlink" title="5.4 数组排序"></a>5.4 数组排序</h5><ul>
<li><code>reserve()</code>: <strong>翻转函数</strong></li>
<li><code>sort()</code>: <strong>排序函数</strong>,不加任何参数时,只能对个位数进行排序,否则会出错.可以自己<strong>定义排序规则</strong></li>
</ul>
<pre><code class="javascript">// 翻转数组
var arr = [3, 2, 1];
var arr2 = arr.reverse();
console.log(arr2); // [1, 2, 3]

// (数组排序)冒泡排序
var arr3 = [3, 4, 7, 1, 6, 2, 9];
sorted_arr = arr3.sort(function (a, b) &#123;
  return a - b; // 升序
&#125;);
console.log(sorted_arr); // [1, 2, 3, 4, 6, 7, 9]
</code></pre>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/sort">Array.prototype.sort() - JavaScript | MDN (mozilla.org)</a></p>
<h5 id="5-5-数组索引方法"><a href="#5-5-数组索引方法" class="headerlink" title="5.5 数组索引方法"></a>5.5 数组索引方法</h5><table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td>indexOf()</td>
<td>数组中查找给定元素的第一个索引</td>
<td>如果存在返回索引号，如果不存在，则返回 -1。</td>
</tr>
<tr>
<td>lastIndexOf()</td>
<td>在数组中的最后一个的索引</td>
<td>如果存在返回索引号，如果不存在，则返回 -1。</td>
</tr>
</tbody></table>
<h5 id="5-6-数组转换成字符串"><a href="#5-6-数组转换成字符串" class="headerlink" title="5.6 数组转换成字符串"></a>5.6 数组转换成字符串</h5><table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td>toString()</td>
<td>把数组转换成字符串，逗号分隔每一项</td>
<td>返回一个字符串</td>
</tr>
<tr>
<td>join(‘分隔符’)</td>
<td>方法用于把数组中的所有元素转换为一个字符串</td>
<td>返回一个字符串</td>
</tr>
</tbody></table>
<h5 id="5-7-其他方法"><a href="#5-7-其他方法" class="headerlink" title="5.7 其他方法"></a>5.7 其他方法</h5><table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td>concat()</td>
<td>连接两个或多个数组，不影响原数组</td>
<td>返回一个新的数组</td>
</tr>
<tr>
<td>slice()</td>
<td>数组截取，slice(begin, end)</td>
<td>返回被截取项目的新数组</td>
</tr>
<tr>
<td>splice()</td>
<td>数组删除，splice(第几个开始, 要删除个数)</td>
<td>返回被删除项目的新数组（注意：会影响原数组）</td>
</tr>
</tbody></table>
<h4 id="6-字符串对象"><a href="#6-字符串对象" class="headerlink" title="6.字符串对象"></a>6.字符串对象</h4><h5 id="6-1-基本包装类型"><a href="#6-1-基本包装类型" class="headerlink" title="6.1 基本包装类型"></a>6.1 基本包装类型</h5><p><code>var itr = &#39;andy&#39;; console.log(str.length);</code><br>对象才有属性和方法复杂数据类型才有属性和方法,简单数据类型为什么会有<strong>lenght 属性</strong>呢?</p>
<p><strong>基本包装类型: 就是把简单数据类型包装成为了复杂数据类型</strong></p>
<ol>
<li>把简单数据类型包装为复杂数据类型<code>var temp = new String(&#39;andy&#39;);</code></li>
<li>把临时变量的值给 str<code>str = temp;</code></li>
<li>销毁这个临时变量<code>temp = null;</code></li>
</ol>
<p>为了方便操作基本数据类型，JavaScript 还提供了三个特殊的引用类型:<code>String</code>、<code>Number</code>和<code>Boolean</code>基本包装类型就是把简单数据类型包装成为复杂数据类型，这样基本数据类型就有了<strong>属性和方法</strong>。</p>
<h5 id="6-2-字符串的不可变"><a href="#6-2-字符串的不可变" class="headerlink" title="6.2 字符串的不可变"></a>6.2 字符串的不可变</h5><p>指的是里面的值不可变，虽然看上去可以改变内容，但其实是地址变了，内存中新开辟了一个内存空间。</p>
<pre><code class="javascript">var str = &quot;abc&quot;;
str = &quot;hello&quot;;
//当重新给 str 赋值的时候，常量&quot;abc&#39;不会被修改，依然在内存中
//重新给字符串赋值，会重新在内存中开辟空间，这个特点就是字符串的不可变
//由于字符串的不可变，在大量拼接字符串的时候会有效率问题
var str = &quot;&quot;;
for (var i = 0; i &lt; 100000; i++) &#123;
  str += i;
  console.log(str);
&#125; //这个结果需要花费大量时间来显示，因为需要不断的开辟新的空间
</code></pre>
<h5 id="6-3-根据字符返回位置"><a href="#6-3-根据字符返回位置" class="headerlink" title="6.3 根据字符返回位置"></a>6.3 根据字符返回位置</h5><p>操作完成会返回一个新的字符串。字符串所有的方法，都不会修改字符串本身(字符串是不可变的)</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td>indexOf(<strong>要查找的字符</strong>,<strong>起始的位置</strong>)</td>
<td>字符串中查找给定元素的第一个索引</td>
<td>如果存在返回索引号，如果不存在，则返回 -1。</td>
</tr>
<tr>
<td>lastIndexOf()</td>
<td>在字符串中的最后一个的索引</td>
<td>如果存在返回索引号，如果不存在，则返回 -1。</td>
</tr>
</tbody></table>
<h5 id="6-4-根据位置返回字符-重点"><a href="#6-4-根据位置返回字符-重点" class="headerlink" title="6.4 根据位置返回字符(重点)"></a>6.4 根据位置返回字符(重点)</h5><table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
<th>使用</th>
</tr>
</thead>
<tbody><tr>
<td>charAt(index)</td>
<td>返回指定位置的字符（index 字符串的索引号）</td>
<td><code>str.charAt(0)</code></td>
</tr>
<tr>
<td>charCodeAt(index)</td>
<td>获取指定位置字符的 ASCII 码（index 索引号）</td>
<td><code>str.charCodeAt(0)</code></td>
</tr>
<tr>
<td>str[index]</td>
<td>获取指定位置处字符</td>
<td>HTML5，IE8+ 支持，等效于 <code>charAt()</code></td>
</tr>
</tbody></table>
<h5 id="6-5-字符串的其他方法"><a href="#6-5-字符串的其他方法" class="headerlink" title="6.5 字符串的其他方法"></a>6.5 字符串的其他方法</h5><table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>concat(str1, str2, str3…)</td>
<td>concat() 方法用于连接两个或多个字符串。拼接字符串，等效于 +，更常用</td>
</tr>
<tr>
<td>substr(start, length)</td>
<td>从 start 位置开始（索引号），length 取的个数（重点记住这个）</td>
</tr>
<tr>
<td>slice(start, end)</td>
<td>从 start 位置开始，截取到 end 位置，end 取不到（它们俩都是索引号）</td>
</tr>
<tr>
<td>substring(start, end)</td>
<td>从 start 位置开始，截取到 end 位置，end 取不到。基本和 slice 相同，但不接受负值</td>
</tr>
<tr>
<td>replace(‘被替换的字符’，”替换为的字符”)</td>
<td>默认只会把字符串中出现的第一个被替换字符替换</td>
</tr>
<tr>
<td>split(‘分隔符’)</td>
<td>把字符串根据给定的分割符划分成数组</td>
</tr>
</tbody></table>
<ul>
<li>toUpperCase() &#x2F;&#x2F;转换大写</li>
<li>toLowerCase() &#x2F;&#x2F;转换小写</li>
</ul>
<h3 id="JavaScript-简单数据类型和复杂数据类型"><a href="#JavaScript-简单数据类型和复杂数据类型" class="headerlink" title="JavaScript 简单数据类型和复杂数据类型"></a>JavaScript 简单数据类型和复杂数据类型</h3><h4 id="1-简单类型与复杂类型"><a href="#1-简单类型与复杂类型" class="headerlink" title="1.简单类型与复杂类型"></a>1.简单类型与复杂类型</h4><p>简单类型又叫做基本数据类型或者<strong>值类型</strong>，复杂类型又叫做<strong>引用类型</strong></p>
<ul>
<li>值类型:简单数据类型&#x2F;基本数据类型，在存储时变量中存储的是值本身，因此叫做值类型<ul>
<li>string ,number ,boolean ,undefined ,null(特殊,空对象)</li>
</ul>
</li>
<li>引用类型:复杂数据类型，在存储时变量中存储的仅仅是地址(引用)，因此叫做引用数据类型<ul>
<li>通过 new 关键字创建的对象(系统对象、自定义对象)，如 Object、Array、Date 等</li>
</ul>
</li>
</ul>
<h4 id="2-堆和栈"><a href="#2-堆和栈" class="headerlink" title="2.堆和栈"></a>2.堆和栈</h4><p>堆栈空间分配区别:</p>
<ol>
<li>栈(操作系统):由操作系统自动分配释放存放函数的参数值、局部变量的值等。其操作方式类似于数据结构中的栈,<strong>简单数据类型存放到栈里面</strong></li>
<li>堆(操作系统):存储复杂类型(对象)，一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收。<strong>复杂数据类型存放到堆里面</strong></li>
</ol>
<img src="/2024/10/14/javascript-xue-xi/内存分区.png" alt="image-20240905110353348" style="zoom: 80%;">

<p><strong>注意</strong>: JavaScript 中没有堆栈的概念，通过堆栈的方式，可以让大家更容易理解代码的一些执行方式，便于将来学习其他语言</p>
<ul>
<li>简单数据类型是存放在栈里面 里面直接开辟一个空间存放的是值</li>
<li>复杂数据类型 首先在栈里面存放地址 十六进制表示 然后这个地址指向堆里面的数据(真正的对象实例)</li>
</ul>
<h4 id="3-简单类型传参"><a href="#3-简单类型传参" class="headerlink" title="3.简单类型传参"></a>3.简单类型传参</h4><p>函数的形参也可以看做是一个变量，当我们把一个<strong>值类型变量</strong>作为参数传给函数的形参时，其实是把变量在栈空间里的值<strong>复制</strong>了一份给<strong>形参</strong>，那么在方法内部对形参做任何修改，都不会影响到的外部变量。</p>
<pre><code class="javascript">function fn(a) &#123;
  a++;
  console.log(a);
&#125;
var x = 10;
fn(x);
console.log(x);
</code></pre>
<h4 id="4-复杂类型传参"><a href="#4-复杂类型传参" class="headerlink" title="4.复杂类型传参"></a>4.复杂类型传参</h4><p>函数的形参也可以看做是一个变量，当我们把<strong>引用类型变量</strong>传给形参时，其实是把变量在栈空间里保存的堆地址复制给了形参，形参和实参其实保存的是同个堆地址，所以操作的是<strong>同一个对象</strong>。</p>
<pre><code class="javascript">function Person(name) &#123;
  this.name = name;
&#125;

function f1(x) &#123;
  // x=p
  console.log(x.name); // 2. 这个输出什么?    刘德华
  x.name = &quot;张学友&quot;;
  console.log(x.name); // 3. 这个输出什么?    张学友
&#125;

var p = new Person(&quot;刘德华&quot;);
console.log(p.name); // 1. 这个输出什么 ?  刘德华
f1(p);
console.log(p.name); // 4. 这个输出什么 ?   张学友
</code></pre>
<h2 id="WebAPIs"><a href="#WebAPIs" class="headerlink" title="WebAPIs"></a>WebAPIs</h2><h3 id="1-WebAPIs-和-JS-基础关联性"><a href="#1-WebAPIs-和-JS-基础关联性" class="headerlink" title="1. WebAPIs 和 JS 基础关联性"></a>1. WebAPIs 和 JS 基础关联性</h3><h4 id="1-1-JS-的组成"><a href="#1-1-JS-的组成" class="headerlink" title="1.1 JS 的组成"></a>1.1 JS 的组成</h4><img src="/2024/10/14/javascript-xue-xi/js的组成.png" alt="image-20240905111550131" style="zoom: 67%;">

<h4 id="1-2-JS-基础阶段以及-WebAPIs-阶段"><a href="#1-2-JS-基础阶段以及-WebAPIs-阶段" class="headerlink" title="1.2 JS 基础阶段以及 WebAPIs 阶段"></a>1.2 JS 基础阶段以及 WebAPIs 阶段</h4><ul>
<li><p>JS 基础阶段</p>
<ul>
<li>我们学习的是 ECMAScript 标准规定的基本语法</li>
<li>要求同学们掌握 Js 基础语法</li>
<li>只学习基本语法，做不了常用的网页交互效果</li>
<li>目的是为了 Js 后面的课程打基础、做铺垫</li>
</ul>
</li>
<li><p>Web APIs 阶段</p>
<ul>
<li>web APIs 是<code>W3C组织</code>的标准</li>
<li>web APIs 我们主要学习 DOM 和 BOM</li>
<li>web APIs 是我们 Js 所独有的部分</li>
<li>我们主要学习页面交互功能</li>
<li>需要使用 Js 基础的课程内容做基础</li>
</ul>
</li>
</ul>
<h3 id="2-API-和-WebAPIs"><a href="#2-API-和-WebAPIs" class="headerlink" title="2.API 和 WebAPIs"></a>2.API 和 WebAPIs</h3><h4 id="2-1-API"><a href="#2-1-API" class="headerlink" title="2.1 API"></a>2.1 API</h4><p><code>API(Application Programming Interface,应用程序编程接口)</code>是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。</p>
<h4 id="2-2-WebAPIs"><a href="#2-2-WebAPIs" class="headerlink" title="2.2 WebAPIs"></a>2.2 WebAPIs</h4><p>Web API 是浏览器提供的一套操作<strong>浏览器功能</strong>和<strong>页面元素</strong>的 API(<strong>BOM</strong> 和 <strong>DOM</strong>)。</p>
<p>MDN 详细 API: <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API">https://developer.mozilla.org/zh-CN/docs/Web/API</a></p>
<h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><h3 id="1-DOM-简介"><a href="#1-DOM-简介" class="headerlink" title="1.DOM 简介"></a>1.DOM 简介</h3><h4 id="1-1-什么是-DOM"><a href="#1-1-什么是-DOM" class="headerlink" title="1.1 什么是 DOM"></a>1.1 什么是 DOM</h4><p>文档对象模型(Document Object Model,简称 DOM)，是 W3C 组织推荐的处理可扩展标记语言(HTML 或者 XML)的标准编程接口。</p>
<h4 id="1-2-DOM-树"><a href="#1-2-DOM-树" class="headerlink" title="1.2 DOM 树"></a>1.2 DOM 树</h4><p><img src="/2024/10/14/javascript-xue-xi/DOM%E6%A0%91.png" alt="image-20240905112511895"></p>
<ul>
<li>文档:一个页面就是一个文档，DOM 中使用 document 表示</li>
<li>元素:页面中的所有标签都是元素，DOM 中使用 element 表示</li>
<li>节点:网页中的所有内容都是节点(标签、属性、文本、注释等)，DOM 中使用 node 表示</li>
</ul>
<p><strong>DOM 把以上内容都看做是对象</strong></p>
<h3 id="2-获取元素"><a href="#2-获取元素" class="headerlink" title="2.获取元素"></a>2.获取元素</h3><h4 id="2-1-如何获取页面元素"><a href="#2-1-如何获取页面元素" class="headerlink" title="2.1 如何获取页面元素"></a>2.1 如何获取页面元素</h4><p>DOM 在我们实际开发中主要用来操作元素。<br>我们如何来获取页面中的元素呢?</p>
<p>获取页面中的元素可以使用以下几种方式:</p>
<ul>
<li>根据 ID 获取</li>
<li>根据标签名获取</li>
<li>通过 HTML5 新增的方法获取</li>
<li>特殊元素获取</li>
</ul>
<h4 id="2-2-根据-ID-获取"><a href="#2-2-根据-ID-获取" class="headerlink" title="2.2 根据 ID 获取"></a>2.2 根据 ID 获取</h4><p><code>document.getElementById(&quot;ID属性&quot;);</code>返回的是<strong>单个元素</strong>(查找到的第一个 id 匹配的标签)</p>
<pre><code class="html">&lt;div id=&quot;time&quot;&gt;2024-09-05&lt;/div&gt;
&lt;!-- 1.因为我们文档页面从上往下加载，所以先得有标签 所以我们script写到标签的下面
2.参数 id是大小写敏感的字符串 --&gt;
&lt;script&gt;
  var timer = document.getElementById(&quot;time&quot;); //返回的是DOM的Element对象
  console.log(timer);
  console.log(typeof timer);
  // 打印我们返回的元素对象 更好的查看里面的属性和方法
  console.dir(timer);
&lt;/script&gt;
</code></pre>
<p><code>console.dir(&#39;timer&#39;);</code>打印我们返回的元素对象 更好的查看里面的属性和方法</p>
<h4 id="2-3-根据标签名获取"><a href="#2-3-根据标签名获取" class="headerlink" title="2.3 根据标签名获取"></a>2.3 根据标签名获取</h4><p><code>document.getElementsByTagName(&quot;标签名&quot;);</code>,取出所有 div 标签,返回的是<strong>获取过来元素对象的集合</strong>,以<strong>伪数组</strong> 的形式存储的</p>
<pre><code class="javascript">&lt;ul&gt;
&lt;li&gt;知否知否,应是绿肥红瘦1&lt;/li&gt;
&lt;li&gt;知否知否,应是绿肥红瘦2&lt;/li&gt;
&lt;li&gt;知否知否,应是绿肥红瘦3&lt;/li&gt;
&lt;li&gt;知否知否,应是绿肥红瘦4&lt;/li&gt;
&lt;li&gt;知否知否,应是绿肥红瘦5&lt;/li&gt;
&lt;/ul&gt;

&lt;script&gt;
var lis = document.getElementsByTagName(&quot;li&quot;);
for (var i = 0; i &lt; lis.length; i++) &#123;
    console.log(lis[i]);
&#125;
&lt;/script&gt;
</code></pre>
<p>注意:</p>
<ol>
<li>因为得到的是一个对象的集合，所以我们想要操作里面的元素就需要遍历</li>
<li>得到元素对象是动态的</li>
</ol>
<ul>
<li>还可以获取某个元素(父元素)内部所有指定标签名的子元素</li>
</ul>
<p>注意:父元素必须是<strong>单个对象(必须指明是哪一个元素对象</strong>,要从伪数组中获取元素),获取的时候不包括父元素自己。</p>
<p><code>element.getElementsByTagName(&#39;标签名&#39;);</code></p>
<h4 id="2-4-通过-HTML5-新增的方法获取"><a href="#2-4-通过-HTML5-新增的方法获取" class="headerlink" title="2.4 通过 HTML5 新增的方法获取"></a>2.4 通过 HTML5 新增的方法获取</h4><ol>
<li>document.<strong>getElementsByClassName(‘类名’)</strong>;&#x2F;&#x2F;根据类名返回元素对象集</li>
<li>document.<strong>querySelector(‘选择器’)</strong>;&#x2F;&#x2F;根据<strong>指定(CSS)选择器</strong>返回<strong>第一个</strong>元素对象</li>
<li><strong>querySelectorA11()</strong>;&#x2F;&#x2F;返回指定选择器的<strong>所有</strong>元素对象</li>
</ol>
<h4 id="2-5-获取特殊元素-body-html"><a href="#2-5-获取特殊元素-body-html" class="headerlink" title="2.5 获取特殊元素(body,html)"></a>2.5 获取特殊元素(body,html)</h4><ul>
<li>获取 body 元素</li>
</ul>
<p><strong>doucumnet.body &#x2F;&#x2F;返回 body 元素对象</strong></p>
<ul>
<li>获取 html 元素</li>
</ul>
<p><strong>document.documentElement &#x2F;&#x2F;返回 html 元素对象!</strong></p>
<pre><code class="javascript">// 1.获取body 元素
var bodyEle = document.body;
console.log(bodyEle);
console.dir(bodyEle);
//2.获取htm1 元素
var htmlEle = document.documentElement;
console.log(htmlEle);
</code></pre>
<h3 id="3-事件基础"><a href="#3-事件基础" class="headerlink" title="3.事件基础"></a>3.事件基础</h3><h4 id="3-1-事件概述"><a href="#3-1-事件概述" class="headerlink" title="3.1 事件概述"></a>3.1 事件概述</h4><p>JavaScript 使我们有能力创建动态页面，而事件是可以被 JavaScript 侦测到的行为。</p>
<p>简单理解:触发—响应机制。</p>
<p>网页中的每个元素都可以产生某些可以触发 JavaScript 的事件，例如，我们可以在用户点击某按钮时产生一个事件，然后去执行某些操作。</p>
<h4 id="3-2-执行事件的步骤"><a href="#3-2-执行事件的步骤" class="headerlink" title="3.2 执行事件的步骤"></a>3.2 执行事件的步骤</h4><ol>
<li>获取事件源</li>
<li>注册事件(绑定事件)</li>
<li>添加事件处理程序(采取函数赋值形式)</li>
</ol>
<h4 id="3-3-常见的鼠标点击事件"><a href="#3-3-常见的鼠标点击事件" class="headerlink" title="3.3 常见的鼠标点击事件"></a>3.3 常见的鼠标点击事件</h4><table>
<thead>
<tr>
<th>鼠标事件</th>
<th>触发条件</th>
</tr>
</thead>
<tbody><tr>
<td>onclick</td>
<td>鼠标点击左键触发</td>
</tr>
<tr>
<td>onmouseover</td>
<td>鼠标经过时触发</td>
</tr>
<tr>
<td>onmouseout</td>
<td>鼠标离开时触发</td>
</tr>
<tr>
<td>onfocus</td>
<td>获取鼠标焦点触发</td>
</tr>
<tr>
<td>onblur</td>
<td>失去鼠标焦点触发</td>
</tr>
<tr>
<td>onmousemove</td>
<td>鼠标移动触发</td>
</tr>
<tr>
<td>onmouseup</td>
<td>鼠标弹起触发</td>
</tr>
<tr>
<td>onmousedown</td>
<td>鼠标按下触发</td>
</tr>
</tbody></table>
<h3 id="4-操作元素"><a href="#4-操作元素" class="headerlink" title="4.操作元素"></a>4.操作元素</h3><p>JavaScript 的 DOM 操作可以改变网页内容、结构和样式，我们可以利用 DOM 操作元素来改变元素里面的内容、属性等。注意以下都是属性</p>
<h4 id="4-1-改变元素内容"><a href="#4-1-改变元素内容" class="headerlink" title="4.1 改变元素内容"></a>4.1 改变元素内容</h4><ul>
<li><code>element.innerText</code>: 从起始位置到终止位置的内容,但它去除 html 标签，同时空格和换行也会去掉</li>
<li><code>element.innerHTML</code>: 起始位置到终止位置的全部内容，包括 html 标签，同时保留空格和换行</li>
</ul>
<h4 id="4-2-常用元素的属性操作"><a href="#4-2-常用元素的属性操作" class="headerlink" title="4.2 常用元素的属性操作"></a>4.2 常用元素的属性操作</h4><p>使用<code>元素.属性</code>来修改属性</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
    &lt;title&gt;修改元素属性&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;input type=&quot;text&quot; value=&quot;我是文本框&quot; /&gt;
    &lt;button&gt;点击修改按钮&lt;/button&gt;
    &lt;script&gt;
      var btn = document.querySelector(&quot;button&quot;);
      btn.onclick = function () &#123;
        document.querySelector(&quot;input&quot;).value = &quot;我被修改了&quot;;
      &#125;;
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h4 id="4-3-表单元素的属性操作"><a href="#4-3-表单元素的属性操作" class="headerlink" title="4.3 表单元素的属性操作"></a>4.3 表单元素的属性操作</h4><p>利用 DOM 可以操作如下表单元素的属性:<code>type、value、checked、selected、disabled</code></p>
<pre><code class="javascript">var inputElement = document.getElementById(&quot;myInput&quot;);
inputElement.type = &quot;password&quot;; // 将输入框类型改为密码框
</code></pre>
<h4 id="4-4-样式属性操作"><a href="#4-4-样式属性操作" class="headerlink" title="4.4 样式属性操作"></a>4.4 样式属性操作</h4><p>我们可以通过 JS 修改元素的大小、颜色、位置等样式。</p>
<ol>
<li><code>element.style</code> 行内样式操作</li>
<li><code>element.className</code> 对类名操作,如果想要保留原来的类名,使用<code>.classList.add(&quot;change&quot;)</code>,<code>classList.remove</code>,<code>classList.toggle</code></li>
</ol>
<pre><code class="html">--element.style--
&lt;div&gt;&lt;/div&gt;
&lt;script&gt;
  // 1.获取元素
  var div = document.querySelector(&quot;div&quot;);
  //2.注册事件 处理程序
  div.onclick = function () &#123;
    // div.style里面的属性 采取驼峰命名法
    this.style.backgroundcolor = &quot;purple&quot;; //this指向函数的调用者
  &#125;;
&lt;/script&gt;

--element.className--
&lt;style&gt;
  div &#123;
    background-color: yellow;
    width: 200px;
    height: 100px;
  &#125;
  .change &#123;
    background-color: blue;
  &#125;
&lt;/style&gt;
&lt;body&gt;
  &lt;div&gt;文本&lt;/div&gt;
  &lt;script&gt;
    var div = document.querySelector(&quot;div&quot;);
    div.onclick = function () &#123;
      // div.classList.add(&quot;change&quot;);
      div.className = &quot;change&quot;;
    &#125;;
  &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<p>注意:</p>
<ul>
<li><strong>this 关键字</strong>指向函数的调用者</li>
<li>Js 里面的样式采取驼峰命名法 比如 <code>fontSize</code>、<code>backgroundColor</code></li>
<li>Js 修改 style 样式操作,产生的是行内样式，<strong>CSS 权重比较高</strong></li>
</ul>
<h4 id="4-5-排他效果"><a href="#4-5-排他效果" class="headerlink" title="4.5 排他效果"></a>4.5 排他效果</h4><pre><code class="html">&lt;body&gt;
  &lt;button&gt;1&lt;/button&gt;&lt;button&gt;2&lt;/button&gt;&lt;button&gt;3&lt;/button&gt;&lt;button&gt;4&lt;/button
  &gt;&lt;button&gt;5&lt;/button&gt;
&lt;/body&gt;
&lt;script&gt;
  // const buttons = document.querySelectorAll(&quot;button&quot;);
  var btns = document.getElementsByTagName(&quot;button&quot;);
  for (var i = 0; i &lt; btns.length; i++) &#123;
    btns[i].onclick = function () &#123;
      //  先去掉其他的按钮的选中样式
      for (var j = 0; j &lt; btns.length; j++) &#123;
        btns[j].style.backgroundColor = &quot;&quot;;
      &#125;
      this.style.backgroundColor = &quot;pink&quot;;
    &#125;;
  &#125;
&lt;/script&gt;
</code></pre>
<h4 id="4-6-自定义属性效果"><a href="#4-6-自定义属性效果" class="headerlink" title="4.6 自定义属性效果"></a>4.6 自定义属性效果</h4><h5 id="获得元素属性值"><a href="#获得元素属性值" class="headerlink" title="获得元素属性值"></a>获得元素属性值</h5><ul>
<li><code>element.属性</code> 获取属性值</li>
<li><code>element.getAttribute(&#39;属性&#39;);</code></li>
</ul>
<p>区别:</p>
<ul>
<li><p><code>element.属性</code> 获取内置属性值(元素本身自带的属性)</p>
</li>
<li><p><code>element.getAttribute(&#39;属性&#39;);</code> 主要获得自定义的属性 (标准) 我们程序员自定义的属性</p>
</li>
</ul>
<h5 id="设置属性值"><a href="#设置属性值" class="headerlink" title="设置属性值"></a>设置属性值</h5><ul>
<li><code>element.属性=&#39;值&#39;</code> 设置内置属性值</li>
<li><code>element.setAttribute(&#39;属性&#39;,&#39;值&#39;)</code> 设置自定义属性值 (标准)</li>
</ul>
<h5 id="移除属性值"><a href="#移除属性值" class="headerlink" title="移除属性值"></a>移除属性值</h5><ul>
<li><code>element.removeAttribute();</code></li>
</ul>
<h4 id="4-7-H5-自定义属性"><a href="#4-7-H5-自定义属性" class="headerlink" title="4.7 H5 自定义属性"></a>4.7 H5 自定义属性</h4><p><strong>自定义属性目的: 是为了保存并使用数据。有些数据可以保存到页面中而不用保存到数据库中。</strong></p>
<p>自定义属性获取是通过<code>getAttribute(&quot;属性&quot;)</code>获取。</p>
<p>但是有些自定义属性很容易引起歧义，不容易判断是元素的内置属性还是自定义属性，</p>
<p>H5 给我们新增了自定义属性</p>
<ol>
<li>设置 H5 自定义属性</li>
</ol>
<p>H5 规定自定义属性<code>data-</code>开头做为属性名并且赋值: 比如<code>&lt;div data-index=&quot;1&quot;&gt;&lt;/div&gt;</code></p>
<ol start="2">
<li>获取 H5 自定义属性<ol>
<li>兼容性获取 <code>element.getAttribute(&#39;data-index&#39;);</code></li>
<li>通过 H5 新增属性<code>dataset</code>获取所有以<code>data-</code>开头的属性,然后取出里面的值<code>.index</code>或者<code>[index]</code></li>
</ol>
</li>
</ol>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
    &lt;title&gt;H5新增dataset属性&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div data-name=&quot;张三&quot; data-age=&quot;18&quot; data-class-name=&quot;student&quot;&gt;&lt;/div&gt;
  &lt;/body&gt;
  &lt;script&gt;
    var div = document.querySelector(&quot;div&quot;);
    console.log(div.dataset.name); // 张三
    console.log(div.dataset.age); // 18
    // 注意：dataset属性的属性名是驼峰命名法，所以要用驼峰命名法来访问属性
    console.log(div.dataset.className); // student
  &lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h3 id="5-节点操作"><a href="#5-节点操作" class="headerlink" title="5.节点操作"></a>5.节点操作</h3><h4 id="5-1-为什么学节点操作"><a href="#5-1-为什么学节点操作" class="headerlink" title="5.1 为什么学节点操作"></a>5.1 为什么学节点操作</h4><p>获取元素通常使用两种方式</p>
<ul>
<li>使用 DOM 提供的方法<ul>
<li><code>document.getElementByld()</code>,<code>document.getElementsByTagName()</code>,<code>document.querySelector()</code>等</li>
<li><strong>逻辑性不强、繁琐</strong></li>
</ul>
</li>
<li>利用<strong>节点层级关系</strong>获取元素<ul>
<li>利用父子兄弟节点关系获取元素</li>
<li>逻辑性强，但是兼容性稍差</li>
</ul>
</li>
</ul>
<h4 id="5-2-节点概述"><a href="#5-2-节点概述" class="headerlink" title="5.2 节点概述"></a>5.2 节点概述</h4><p>网页中的所有内容都是节点(标签、属性、文本、注释等)，在 DOM 中，节点使用 node 来表示 HTMLDOM 树中的所有节点均可通过 JavaScript 进行访问，所有 HTML 元素(节点)均可被修改，也可以创建或删除。</p>
<p>一般地，节点至少拥有<code>nodeType(节点类型)</code>、<code>nodeName(节点名称)</code>和<code>nodeValue(节点值)</code>这三个基本属性。</p>
<ul>
<li>元素节点 nodeType 为 1</li>
<li>属性节点 nodeType 为 2</li>
<li>文本节点 nodeType 为 3</li>
</ul>
<p><strong>(文本节点包含文字、空格、换行等我们在实际开发中，节点操作主要操作的是元素节点)</strong></p>
<h4 id="5-3-节点操作之父子节点"><a href="#5-3-节点操作之父子节点" class="headerlink" title="5.3 节点操作之父子节点"></a>5.3 节点操作之父子节点</h4><ul>
<li><p>父节点</p>
<ul>
<li>使用<code>节点.parentNode</code>属性获取父节点,得到的是<strong>离元素最近</strong>的父级节点,若找不到返回<strong>null</strong></li>
</ul>
</li>
<li><p>子节点</p>
<ul>
<li><p>使用<code>节点.childNodes</code>属性获取<strong>全部子节点</strong>-集合形式(包含文本节点、元素节点等),我们可以通过遍历每一个元素的节点属性来对应操作</p>
</li>
<li><p>使用<code>节点.children</code>属性获取所有<strong>子元素节点</strong>,是一个只读属性，返回所有的子元素节点。它只返回子元素节点，其余节点不返回</p>
</li>
<li><p><code>firstChild</code>获取第一个子节点 不管是文本节点还是元素节点,<code>lastChild</code>同理</p>
</li>
<li><p><code>firstElementChild</code>获取第一个子节点 不管是文本节点还是元素节点,<code>lastElementChild</code>同理,但可能有兼容性问题,一般使用<code>节点.children[0]</code>获取</p>
</li>
</ul>
</li>
</ul>
<pre><code class="javascript">&lt;body&gt;
    &lt;ul&gt;
      &lt;li class=&quot;active&quot;&gt;我是li&lt;/li&gt;
      &lt;li&gt;我是li&lt;/li&gt;
      &lt;li&gt;我是li&lt;/li&gt;
      &lt;li&gt;我是li&lt;/li&gt;
      &lt;li&gt;我是li&lt;/li&gt;
    &lt;/ul&gt;
    &lt;script&gt;
      var activeLi = document.querySelector(&quot;.active&quot;);
      activeLi.style.color = &quot;red&quot;;

      var ul = activeLi.parentNode;
      console.log(ul);

      var childs = ul.childNodes;
      for (var i = 0; i &lt; childs.length; i++) &#123;
        if (childs[i].nodeType === 1) &#123;
          console.log(childs[i]); // 只有当节点属性为1时才是元素节点,打印输出
        &#125;
      &#125;
      console.log(ul.children); // 等价于上面的代码
    &lt;/script&gt;
  &lt;/body&gt;
</code></pre>
<h4 id="5-4-节点操作之兄弟节点"><a href="#5-4-节点操作之兄弟节点" class="headerlink" title="5.4 节点操作之兄弟节点"></a>5.4 节点操作之兄弟节点</h4><p><code>node.nextSibling</code>: 返回元素下一个兄弟节点,包含文本节点等</p>
<p><code>node.nextElementSibling / node.previousElementSibling</code>返回当前元素下一个&#x2F;上一个兄弟元素节点，找不到则返回<strong>null</strong>.</p>
<ul>
<li>如何解决兼容性问题<ul>
<li>自己封装一个函数</li>
</ul>
</li>
</ul>
<pre><code class="javascript">function mygetNextElementSibling(node) &#123;
  var el = node;
  while ((el = el.nextSibling)) &#123;
    if (el.nodeType == 1) &#123;
      return el;
    &#125;
  &#125;
  return null;
&#125;
</code></pre>
<h4 id="5-5-创建节点"><a href="#5-5-创建节点" class="headerlink" title="5.5 创建节点"></a>5.5 创建节点</h4><p><code>document.createElement(&quot;tagName&quot;)</code></p>
<p><strong>document.createElement()<strong>方法创建由 <strong>tagName</strong> 指定的 HTML 元素。因为这些元素原先不存在是根据我们的需求动态生成的，所以我们也称为</strong>动态创建元素节点。</strong></p>
<pre><code class="javascript">var div = document.createElement(&quot;div&quot;);
div.innerHTML = &quot;Hello World!&quot;;
document.body.appendChild(div);

var p = document.createElement(&quot;p&quot;);
p.innerHTML = &quot;This is a paragraph.&quot;;
document.body.appendChild(p);
</code></pre>
<h4 id="5-6-插入节点"><a href="#5-6-插入节点" class="headerlink" title="5.6 插入节点"></a>5.6 插入节点</h4><p><code>appendChild(node)</code> 后面插入(尾插法)</p>
<p><code>insertBefore(child,指定元素)</code>在指定元素前面插入新子元素 child(前插法)</p>
<pre><code class="javascript">&lt;!-- 搭建评论框 --&gt;
&lt;div id=&quot;comment-box&quot;&gt;
    &lt;h2&gt;发表评论&lt;/h2&gt;
&lt;form id=&quot;comment-form&quot;&gt;
    &lt;label for=&quot;name&quot;&gt;昵称:&lt;/label&gt;
&lt;input type=&quot;text&quot; id=&quot;name&quot; name=&quot;name&quot; required /&gt;
    &lt;label for=&quot;email&quot;&gt;邮箱:&lt;/label&gt;
&lt;input type=&quot;email&quot; id=&quot;email&quot; name=&quot;email&quot; required /&gt;
    &lt;label for=&quot;comment&quot;&gt;评论:&lt;/label&gt;
&lt;textarea id=&quot;comment&quot; name=&quot;comment&quot; required&gt;&lt;/textarea&gt;
&lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;
&lt;/form&gt;
&lt;/div&gt;

&lt;!-- 评论列表 --&gt;
&lt;div id=&quot;comment-list&quot;&gt;
    &lt;h2&gt;评论列表&lt;/h2&gt;
&lt;ul id=&quot;comment-list-ul&quot;&gt;&lt;/ul&gt;
&lt;/div&gt;

&lt;script&gt;
    // 获取评论表单
    const commentForm = document.getElementById(&quot;comment-form&quot;);
// 获取评论列表
const commentList = document.getElementById(&quot;comment-list-ul&quot;);

// 监听提交事件
commentForm.addEventListener(&quot;submit&quot;, function (event) &#123;
    // 阻止默认提交事件
    event.preventDefault();
    // 获取表单数据
    const name = document.getElementById(&quot;name&quot;).value;
    const email = document.getElementById(&quot;email&quot;).value;
    const comment = document.getElementById(&quot;comment&quot;).value;
    // 创建li节点
    const li = document.createElement(&quot;li&quot;);
    if (name === &quot;&quot; || email === &quot;&quot; || comment === &quot;&quot;) &#123;
        alert(&quot;请填写完整信息&quot;);
        return;
    &#125;
    // 创建评论内容节点
    const content = document.createTextNode(
        `$&#123;name&#125;($&#123;email&#125;): $&#123;comment&#125;`
    );
    // 将评论内容节点添加到li节点
    li.appendChild(content);
    // 将li节点添加到评论列表
    commentList.insertBefore(li, commentList.firstChild);
    // 清空表单
    commentForm.reset();
&#125;);
&lt;/script&gt;
</code></pre>
<h4 id="5-7-删除节点"><a href="#5-7-删除节点" class="headerlink" title="5.7 删除节点"></a>5.7 删除节点</h4><p><code>node.removeChild(child)</code> 删除<strong>node</strong>里面的<strong>子节点</strong>,<code>node.removechild()</code>方法从 DOM 中删除一个子节点，返回删除的节点</p>
<pre><code class="javascript">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
    &lt;title&gt;评论_创建元素节点&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;!-- 搭建评论框 --&gt;
    &lt;div id=&quot;comment-box&quot;&gt;
      &lt;h2&gt;发表评论&lt;/h2&gt;
      &lt;form id=&quot;comment-form&quot;&gt;
        &lt;label for=&quot;name&quot;&gt;昵称:&lt;/label&gt;
        &lt;input type=&quot;text&quot; id=&quot;name&quot; name=&quot;name&quot; required /&gt;
        &lt;label for=&quot;email&quot;&gt;邮箱:&lt;/label&gt;
        &lt;input type=&quot;email&quot; id=&quot;email&quot; name=&quot;email&quot; required /&gt;
        &lt;label for=&quot;comment&quot;&gt;评论:&lt;/label&gt;
        &lt;textarea id=&quot;comment&quot; name=&quot;comment&quot; required&gt;&lt;/textarea&gt;
        &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;
      &lt;/form&gt;
    &lt;/div&gt;

    &lt;!-- 评论列表 --&gt;
    &lt;div id=&quot;comment-list&quot;&gt;
      &lt;h2&gt;评论列表&lt;/h2&gt;
      &lt;ul id=&quot;comment-list-ul&quot;&gt;&lt;/ul&gt;
    &lt;/div&gt;

    &lt;script&gt;
      // 获取评论表单
      const commentForm = document.getElementById(&quot;comment-form&quot;);
      // 获取评论列表
      const commentList = document.getElementById(&quot;comment-list-ul&quot;);

      // 监听提交事件
      commentForm.addEventListener(&quot;submit&quot;, function (event) &#123;
        // 阻止默认提交事件
        event.preventDefault();
        // 获取表单数据
        const name = document.getElementById(&quot;name&quot;).value;
        const email = document.getElementById(&quot;email&quot;).value;
        const comment = document.getElementById(&quot;comment&quot;).value;
        // 创建li节点
        const li = document.createElement(&quot;li&quot;);
        if (name === &quot;&quot; || email === &quot;&quot; || comment === &quot;&quot;) &#123;
          alert(&quot;请填写完整信息&quot;);
          return;
        &#125;
        // 创建评论内容节点
        const content = document.createElement(&quot;span&quot;);
        content.textContent = `$&#123;name&#125;($&#123;email&#125;): $&#123;comment&#125;`;
        const deletebtn = document.createElement(&quot;a&quot;);
        deletebtn.textContent = &quot;删除&quot;;
        deletebtn.href = &quot;javascript:void(0)&quot;;
        deletebtn.addEventListener(&quot;click&quot;, function () &#123;
          li.remove();
        &#125;);
        // 将评论内容节点添加到li节点
        li.appendChild(content);
        // 将删除按钮添加到li节点
        li.appendChild(deletebtn);

        // 将li节点添加到评论列表
        commentList.insertBefore(li, commentList.firstChild);
        // 清空表单
        commentForm.reset();
      &#125;);
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ul>
<li>当我们把文本域里面的值赋值给 li 的时候，多添加一个删除的链接</li>
<li>需要把所有的链接获取过来，当我们点击当前的链接的时候，删除当前链接所在的 li</li>
<li>阻止链接跳转需要添加<code>javascript:void(0);</code>或者 <code>javascript:;</code></li>
</ul>
<h4 id="5-8-复制节点"><a href="#5-8-复制节点" class="headerlink" title="5.8 复制节点"></a>5.8 复制节点</h4><p><code>node.cloneNode()</code>方法返回调用该方法的节点的一个副本。也称为克隆节点&#x2F;拷贝节点</p>
<ul>
<li>如果括号参数为 空 或者为 false，则是<strong>浅拷贝</strong>，即只克隆复制<strong>节点本身</strong>，<strong>不克隆里面的子节点</strong>。</li>
<li>如果括号参数为 true，则是深度拷贝，会复制节点本身以及里面所有的子节点。</li>
</ul>
<h4 id="5-9-三种动态创建元素区别"><a href="#5-9-三种动态创建元素区别" class="headerlink" title="5.9 三种动态创建元素区别"></a>5.9 三种动态创建元素区别</h4><ul>
<li><code>document.write()</code></li>
<li><code>element.innerHTML</code></li>
<li><code>document.createElement()</code></li>
</ul>
<p>区别</p>
<ol>
<li><code>document.write()</code> 是直接将内容写入页面的内容流，但是<strong>文档流执行完毕</strong>,则调用它会<strong>导致页面全部重绘</strong></li>
<li><code>element.innerHTML</code> 使用字符串拼接的方式创建元素,效率低,因为每次都要重新创建元素且开辟内存空间</li>
<li><code>element.innerHTML</code> 是将内容写入某个 DOM 节点，不会导致页面全部重绘,创建多个元素效率更高(不要拼接字符串，采取数组形式拼接)，结构稍微复杂</li>
<li><code>document.createElement()</code> 通过**createElement()**方法创建元素，然后将创建的元素添加到文档中</li>
<li><code>createglement()</code> 创建多个元素效率稍低一点点，但是结构更清晰</li>
</ol>
<pre><code class="javascript">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
    &lt;title&gt;创建元素方式区别&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;ul&gt;
      &lt;li&gt;创建元素方式1：write()&lt;/li&gt;
      &lt;li&gt;创建元素方式2：createElement()&lt;/li&gt;
      &lt;li&gt;创建元素方式3：innerHTML方式&lt;/li&gt;
    &lt;/ul&gt;
    &lt;button&gt;点击创建元素&lt;/button&gt;
  &lt;/body&gt;
  &lt;script&gt;
    // 1. write方式创建元素  直接将元素写入到文档中，可以直接使用document.write()方法,如果页面文档流加载完毕，再调用这句话会导致页面重绘
    var btn = document.querySelector(&quot;button&quot;);
    btn.onclick = function () &#123;
      document.write(&quot;&lt;div&gt;write方式创建元素&lt;/div&gt;&quot;);
    &#125;;

    // 2. createElement方式创建元素  通过createElement()方法创建元素，然后将创建的元素添加到文档中
    var btn2 = document.querySelector(&quot;button&quot;);
    btn2.onclick = function () &#123;
      var div = document.createElement(&quot;div&quot;);
      div.innerHTML = &quot;createElement方式创建元素&quot;;
      document.body.appendChild(div);
    &#125;;

    // 3. innerHTML方式创建元素  通过innerHTML方式创建元素，直接将元素添加到文档中,里面使用字符串拼接的方式创建元素,效率低,因为每次都要重新创建元素且开辟内存空间
    var btn3 = document.querySelector(&quot;button&quot;);
    btn3.onclick = function () &#123;
      var div = document.createElement(&quot;div&quot;);
      div.innerHTML = &quot;innerHTML方式创建元素&quot;;
      document.body.appendChild(div);
    &#125;;

    // 效率最高
    function fn() &#123;
      var start = +new Date();
      var arr = [];
      for (var i = 0; i &lt; 10000; i++) &#123;
        arr.push(&quot;&lt;div&gt;innerHTML方式创建元素&lt;/div&gt;&quot;);
      &#125;
      document.body.innerHTML = arr.join(&quot;&quot;);
      var end = +new Date();
      console.log(&quot;innerHTML方式创建元素耗时：&quot; + (end - start) + &quot;ms&quot;);
    &#125;
    fn();
  &lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h3 id="6-案例"><a href="#6-案例" class="headerlink" title="6. 案例"></a>6. 案例</h3><h4 id="密码输入检验"><a href="#密码输入检验" class="headerlink" title="密码输入检验"></a>密码输入检验</h4><pre><code class="html">&lt;body&gt;
  &lt;div class=&quot;register&quot;&gt;
    &lt;input type=&quot;password&quot; name=&quot;&quot; id=&quot;&quot; class=&quot;ipt&quot; /&gt;
    &lt;p class=&quot;message&quot;&gt;请输入6-16位密码&lt;/p&gt;
  &lt;/div&gt;
&lt;/body&gt;
&lt;script&gt;
  var ipt = document.querySelector(&quot;.ipt&quot;);
  var message = document.querySelector(&quot;.message&quot;);
  ipt.addEventListener(&quot;input&quot;, function () &#123;
    var value = this.value;
    if (value.length &lt; 6 || value.length &gt; 16) &#123;
      message.style.display = &quot;block&quot;;
    &#125; else &#123;
      message.style.display = &quot;none&quot;;
    &#125;
  &#125;);
&lt;/script&gt;
</code></pre>
<h4 id="开关灯"><a href="#开关灯" class="headerlink" title="开关灯"></a>开关灯</h4><pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
    &lt;title&gt;开关灯&lt;/title&gt;
    &lt;style&gt;
      .light &#123;
        background-color: #fff;
      &#125;
      .black &#123;
        background-color: #000;
      &#125;
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;button&gt;关灯&lt;/button&gt;
  &lt;/body&gt;
  &lt;script&gt;
    var flag = true;
    var btn = document.querySelector(&quot;button&quot;);
    btn.onclick = function () &#123;
      if (flag) &#123;
        document.body.className = &quot;black&quot;;
        btn.innerHTML = &quot;开灯&quot;;
        flag = false;
      &#125; else &#123;
        document.body.className = &quot;light&quot;;
        btn.innerHTML = &quot;关灯&quot;;
        flag = true;
      &#125;
    &#125;;
  &lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h4 id="图片换肤效果"><a href="#图片换肤效果" class="headerlink" title="图片换肤效果"></a>图片换肤效果</h4><pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
    &lt;title&gt;换肤效果&lt;/title&gt;
    &lt;style&gt;
      body &#123;
        background-color: #f5f5f5;
      &#125;
      div.skin &#123;
        width: 774px;
        margin: auto;
      &#125;
      img &#123;
        display: block;
        float: left;
        width: 380px;
        height: 200px;
        border: 1px solid #ccc;
      &#125;
      .clearfix::after &#123;
        content: &quot;&quot;;
        display: table;
        clear: both;
      &#125;
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div class=&quot;skin clearfix&quot;&gt;
      &lt;img src=&quot;../css下/background.png&quot; alt=&quot;&quot; /&gt;
      &lt;img src=&quot;../html下/image.png&quot; alt=&quot;&quot; /&gt;
    &lt;/div&gt;
  &lt;/body&gt;
  &lt;script&gt;
    imgs = document.getElementsByTagName(&quot;img&quot;);
    for (var i = 0; i &lt; imgs.length; i++) &#123;
      imgs[i].onclick = function () &#123;
        var body = document.querySelector(&quot;body&quot;);
        body.style.backgroundImage = &quot;url(&quot; + this.src + &quot;)&quot;;
      &#125;;
    &#125;
  &lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h4 id="新浪下划菜单"><a href="#新浪下划菜单" class="headerlink" title="新浪下划菜单"></a>新浪下划菜单</h4><pre><code class="javascript">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
    &lt;title&gt;Dropdown Menu&lt;/title&gt;
    &lt;style&gt;
      body &#123;
        margin: 0;
        padding: 0;
        font-family: Arial, sans-serif;
      &#125;
      .nav &#123;
        width: 100%;
        margin: 0 auto;
        padding: 0;
        list-style: none;
        background-color: #f8f8f8;
        border-bottom: 1px solid #e7e7e7;
      &#125;
      .nav li &#123;
        display: inline-block;
        position: relative;
        vertical-align: top;
        font-size: 0;
      &#125;
      .nav a &#123;
        display: block;
        padding: 10px 20px;
        text-decoration: none;
        color: #333;
        font-size: 16px;
      &#125;
      .nav li ul &#123;
        display: none;
        position: absolute;
        top: 100%;
        left: 0;
        list-style: none;
        padding: 0;
        margin: 0;
        background-color: #fff;
        border: 1px solid #e7e7e7;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      &#125;
      .nav li:hover &gt; ul &#123;
        display: block;
      &#125;
      .nav ul li &#123;
        display: block;
      &#125;
      .nav ul a &#123;
        padding: 10px 15px;
        white-space: nowrap;
      &#125;
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;ul class=&quot;nav&quot;&gt;
      &lt;li&gt;
        &lt;a href=&quot;#&quot;&gt;微博&lt;/a&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#&quot;&gt;关注&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#&quot;&gt;粉丝&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;a href=&quot;#&quot;&gt;微博&lt;/a&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#&quot;&gt;关注&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#&quot;&gt;粉丝&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;a href=&quot;#&quot;&gt;微博&lt;/a&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#&quot;&gt;关注&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#&quot;&gt;粉丝&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;a href=&quot;#&quot;&gt;微博&lt;/a&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#&quot;&gt;关注&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#&quot;&gt;粉丝&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;a href=&quot;#&quot;&gt;微博&lt;/a&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#&quot;&gt;关注&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#&quot;&gt;粉丝&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>消除行内块元素的<strong>默认空白(字符)间隙</strong>: 对父元素设置<code>font-size属性为0</code>,再对要显示的子元素单独设置<code>font-size</code></p>
<h4 id="动态生成表格"><a href="#动态生成表格" class="headerlink" title="动态生成表格"></a>动态生成表格</h4><ul>
<li>因为里面的学生数据都是动态的，我们需要 js 动态生成。这里我们模拟数据，自己定义好数据。数据我们采取对象形式存储。</li>
</ul>
<pre><code class="javascript">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
    &lt;title&gt;动态创建表格&lt;/title&gt;
  &lt;/head&gt;
  &lt;style&gt;
    table &#123;
      border-collapse: collapse;
      width: 60%;
    &#125;
    th,
    td &#123;
      border: 1px solid #6c6c6c;
      text-align: center;
      padding: 8px;
      border: 1px solid #000000;
    &#125;
    th &#123;
      background-color: rgb(200, 200, 200);
    &#125;
  &lt;/style&gt;
  &lt;body&gt;
    &lt;button&gt;添加&lt;/button&gt;
    &lt;table cellspacing=&quot;0&quot;&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;姓名&lt;/th&gt;
          &lt;th&gt;科目&lt;/th&gt;
          &lt;th&gt;成绩&lt;/th&gt;
          &lt;th&gt;操作&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;!-- &lt;tr&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;2&lt;/td&gt;
          &lt;td&gt;3&lt;/td&gt;
          &lt;td&gt;&lt;a href=&quot;javascript:void(0)&quot;&gt;修改&lt;/a&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;4&lt;/td&gt;
          &lt;td&gt;5&lt;/td&gt;
          &lt;td&gt;6&lt;/td&gt;
          &lt;td&gt;&lt;a href=&quot;javascript:void(0)&quot;&gt;修改&lt;/a&gt;&lt;/td&gt;
        &lt;/tr&gt; --&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/body&gt;
  &lt;script&gt;
    // 准备数据
    var datas = [
      &#123; name: &quot;张三&quot;, subject: &quot;语文&quot;, score: 80 &#125;,
      &#123; name: &quot;王五&quot;, subject: &quot;英语&quot;, score: 85 &#125;,
      &#123; name: &quot;赵六&quot;, subject: &quot;物理&quot;, score: 95 &#125;,
      &#123; name: &quot;周七&quot;, subject: &quot;化学&quot;, score: 88 &#125;,
      &#123; name: &quot;陈八&quot;, subject: &quot;生物&quot;, score: 90 &#125;,
      &#123; name: &quot;吴九&quot;, subject: &quot;历史&quot;, score: 85 &#125;,
    ];
    // 动态创建表格
    function createTable() &#123;
      var table = document.querySelector(&quot;table&quot;);
      var tbody = table.querySelector(&quot;tbody&quot;);
      for (var i = 0; i &lt; datas.length; i++) &#123;
        var tr = document.createElement(&quot;tr&quot;);
        var tdName = document.createElement(&quot;td&quot;);
        tdName.textContent = datas[i].name;
        var tdSubject = document.createElement(&quot;td&quot;);
        tdSubject.textContent = datas[i].subject;
        var tdScore = document.createElement(&quot;td&quot;);
        tdScore.textContent = datas[i].score;
        var tdOperation = document.createElement(&quot;td&quot;);
        tdOperation.innerHTML = &quot;&lt;a href=&#39;javascript:void(0)&#39;&gt;修改&lt;/a&gt;&quot;;
        tr.appendChild(tdName);
        tr.appendChild(tdSubject);
        tr.appendChild(tdScore);
        tr.appendChild(tdOperation);
        tbody.appendChild(tr);

        tdOperation.querySelector(&quot;a&quot;).onclick = function () &#123;
          var score = prompt(
            &quot;请输入修改后的成绩：&quot;,
            this.parentNode.parentNode.children[2].textContent
          );
          if (Number.isInteger(Number(score))) &#123;
            this.parentNode.parentNode.children[2].textContent = score;
          &#125; else &#123;
            alert(&quot;请输入正确的成绩！&quot;);
          &#125;
        &#125;;
      &#125;
    &#125;
    var btnAdd = document.querySelector(&quot;button&quot;);
    btnAdd.onclick = function () &#123;
      var tr = document.createElement(&quot;tr&quot;);
      var tdName = document.createElement(&quot;td&quot;);
      createTable();
    &#125;;
  &lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h2 id="事件高级"><a href="#事件高级" class="headerlink" title="事件高级"></a>事件高级</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ul>
<li>能够写出元素注册事件的两种方式</li>
<li>能够说出删除事件的两种方式</li>
<li>能够说出 DOM 事件流的三个阶段</li>
<li>能够利用事件对象完成跟随鼠标案例</li>
<li>能够封装阻止冒泡的兼容性函数</li>
<li>能够说出事件委托的原理</li>
<li>能够说出常用的鼠标和键盘事件</li>
</ul>
<h3 id="1-注册事件-绑定事件"><a href="#1-注册事件-绑定事件" class="headerlink" title="1.注册事件(绑定事件)"></a>1.注册事件(绑定事件)</h3><h4 id="1-1-注册事件概述"><a href="#1-1-注册事件概述" class="headerlink" title="1.1 注册事件概述"></a>1.1 注册事件概述</h4><p>给元素添加事件，称为注册事件或者绑定事件</p>
<p>注册事件有两种方式: <strong>传统方式</strong>和<strong>方法监听注册方式</strong></p>
<h5 id="传统注册方式"><a href="#传统注册方式" class="headerlink" title="传统注册方式"></a>传统注册方式</h5><ul>
<li>利用 on 开头的事件 onclick, 如<code>&lt;button onclick= &#39;alert(&quot;hi~&quot;)&#39;&gt;&lt;/button&gt; 或者 btn.onclick = function()&#123;&#125;</code></li>
<li><strong>特点:</strong> 注册事件的唯一性同一个元素同一个事件只能设置一个处理函数，最后注册的处理函数将会<strong>覆盖</strong>前面注册的处理函数</li>
</ul>
<h5 id="方法监听注册方式"><a href="#方法监听注册方式" class="headerlink" title="方法监听注册方式"></a>方法监听注册方式</h5><ul>
<li>w3c 标准推荐方式</li>
<li><code>addEventListener()</code>它是一个方法</li>
<li>IE9 之前的 IE 不支持此方法，可使用 <code>attachEvent()</code> 代替</li>
<li><strong>特点:</strong> 同一个元素同一个事件<strong>可以注册多个</strong>监听器</li>
</ul>
<h4 id="1-2-addEventListener-事件监听方式"><a href="#1-2-addEventListener-事件监听方式" class="headerlink" title="1.2 addEventListener 事件监听方式"></a>1.2 addEventListener 事件监听方式</h4><pre><code class="javascript">// 参数声明
eventTarget.addEventListener(type,listener[，useCapture])
</code></pre>
<p><code>eventTarget.addEventListener()</code>方法将指定的监听器注册到**eventTarget(目标对象)**上，当该对象触发指定的事件时，就会执行事件处理函数。<br>该方法接收三个参数:</p>
<ul>
<li><strong>type</strong>:事件类型字符串，比如 click、mouseover,注意这里不要带 on</li>
<li><strong>listener</strong>:事件处理函数，事件发生时，会调用该监听函数</li>
<li><strong>useCapture</strong>:可选参数，是一个布尔值，默认是 false。学完 DOM 事件流后，我们再进一步学习</li>
</ul>
<h4 id="1-3-attachEvent-事件监听方法"><a href="#1-3-attachEvent-事件监听方法" class="headerlink" title="1.3 attachEvent 事件监听方法"></a>1.3 attachEvent 事件监听方法</h4><pre><code class="javascript">eventTarget.attachEvent(eventNameWithon, callback);
</code></pre>
<p><code>eventTarget.attachEvent()</code>方法将指定的监听器注册到**eventTarget(目标对象)**上，当该对象触发指定的事件时，指定的回调函数就会被执行。<br>该方法接收两个参数:</p>
<ul>
<li><strong>eventNameWithOn:</strong> 类型字符串，比如 onclick、onmouseover，这里要带<code>on</code></li>
<li><strong>callback</strong>: 事件处理函数，当目标触发事件时回调函数被调用</li>
</ul>
<p><code>注意: 仅IE8及以前版本的IE浏览器支持</code></p>
<h4 id="1-4-兼容性处理"><a href="#1-4-兼容性处理" class="headerlink" title="1.4 兼容性处理"></a>1.4 兼容性处理</h4><pre><code class="javascript">// 兼容性处理
function aaddEventListener(element, eventName, fn) &#123;
  //判断当前浏览器是否支持 addEventListener 方法
  if (element.addEventListener) &#123;
    element.addEventListener(eventName, fn);
  &#125; //第三个参数默认是false
  else if (element.attachEvent) &#123;
    element.attachEvent(&quot;on&quot; + eventName, fn);
  &#125; else &#123;
    //相当于element.onclick=fn;
    element[&quot;on&quot; + eventName] = fn;
  &#125;
&#125;
</code></pre>
<h3 id="2-删除事件-解绑事件"><a href="#2-删除事件-解绑事件" class="headerlink" title="2.删除事件(解绑事件)"></a>2.删除事件(解绑事件)</h3><h4 id="2-1-删除事件的方式"><a href="#2-1-删除事件的方式" class="headerlink" title="2.1 删除事件的方式"></a>2.1 删除事件的方式</h4><ul>
<li>传统注册方式 <code>element.onclick = null;</code></li>
<li>方法监听注册方式 <code>eventTarget.removeEventListener(type,listener[,useCapture]);</code></li>
<li>IE8 方法 <code>eventTarget.detachEvent(type,listener[,useCapture]);</code></li>
</ul>
<pre><code class="javascript">var divs = document.getElementsByTagName(&quot;div&quot;);

divs[0].onclick = function () &#123;
  alert(&quot;点击了第1个div&quot;);
  divs[0].onclick = null;
  //   divs[0].remove();
&#125;;

divs[1].addEventListener(&quot;click&quot;, function () &#123;
  alert(&quot;点击了第2个div&quot;);
  divs[1].removeEventListener(&quot;click&quot;, arguments.callee); //arguments.callee指向当前函数，这里可以用匿名函数来实现
  //   divs[0].remove();
&#125;);

divs[2].attachEvent(&quot;onclick&quot;, fn1),
  function fn1() &#123;
    alert(&quot;点击了第3个div&quot;);
    divs[2].detachEvent(&quot;onclick&quot;, fn1);
  &#125;;
</code></pre>
<h3 id="3-DOM-的事件流"><a href="#3-DOM-的事件流" class="headerlink" title="3.DOM 的事件流"></a>3.DOM 的事件流</h3><p><strong>事件流</strong>描述的是从页面中接收事件的顺序，<br><strong>事件</strong>发生时会在元素节点之间按照特定<strong>的</strong>顺序传播，这个<strong>传播过程</strong>即<strong>DOM 事件流</strong>。</p>
<p><strong>注意</strong></p>
<ol>
<li>JS 代码中只能执行捕获或者冒泡其中的一个阶段。</li>
<li>onclick 和 attachEvent 只能得到冒泡阶段</li>
<li><code>addEventListener(type，listener[，useCapture])</code>第三个参数如果是 true,表示在事件捕获阶段调用事件处理程序;如果是 false(不写默认就是 false)，表示在事件冒泡阶段调用事件处理程序。</li>
<li>实际开发中我们很少使用事件捕获，我们更关注事件冒泡。</li>
<li>有些事件是没有冒泡的，比如 <code>onblur</code>、<code>onfocus</code>、<code>onmouseenter</code>、<code>onmouseleave</code></li>
</ol>
<p><img src="/2024/10/14/javascript-xue-xi/%E4%BA%8B%E4%BB%B6%E6%B5%81.png" alt="image-20240920102546864"></p>
<ul>
<li>事件冒泡:IE 最早提出，事件开始时由最具体的元素接收，然后逐级向上传播到到 DOM 最顶层节点的过程。</li>
<li>事件捕获:网景最早提出，由 DOM 最顶层节点开始，然后逐级向下传播到到最具体的元素接收的过程。</li>
</ul>
<pre><code class="javascript">&lt;!DOCTYPE html&gt;
    &lt;html lang=&quot;en&quot;&gt;
        &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot; /&gt;
            &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
                &lt;title&gt;Document&lt;/title&gt;
&lt;style&gt;
                body &#123;
                    width: 100%;
                &#125;
.father &#123;
    width: 200px;
    height: 200px;
    background-color: blueviolet;
    position: relative;
    margin: auto;
&#125;
.son &#123;
    width: 100px;
    height: 100px;
    background-color: pink;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    cursor: pointer;
&#125;
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;father&quot;&gt;
        &lt;div class=&quot;son&quot;&gt;子元素&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;script&gt;
            // 捕获阶段 从上到下,所以假如father和son都有click事件,则先捕获father的事件,然后再到son
            var son = document.querySelector(&quot;.son&quot;);
son.addEventListener(
    &quot;click&quot;,
    function () &#123;
        alert(&quot;son&quot;);
    &#125;,
    true
);

var father = document.querySelector(&quot;.father&quot;);
father.addEventListener(
    &quot;click&quot;,
    function () &#123;
        alert(&quot;father&quot;);
    &#125;,
    true
);

// 冒泡阶段 从下到上,所以假如father和son都有click事件,则先冒泡son的事件,然后再到father
var son = document.querySelector(&quot;.son&quot;);
son.addEventListener(
    &quot;click&quot;,
    function () &#123;
        alert(&quot;son&quot;);
    &#125;,
    false
);

var father = document.querySelector(&quot;.father&quot;);
father.addEventListener(
    &quot;click&quot;,
    function () &#123;
        alert(&quot;father&quot;);
    &#125;,
    false
);
&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h3 id="4-事件对象"><a href="#4-事件对象" class="headerlink" title="4.事件对象"></a>4.事件对象</h3><ol>
<li>event 就是一个事件对象，写到我们侦听函数的<strong>小括号</strong>里面，当形参来看</li>
<li>事件对象只有有了事件才会存在，它是系统给我们<strong>自动创建</strong>的，不需要我们传递参数</li>
<li>事件对象是我们事件的<strong>一系列相关数据的集合</strong>，跟事件相关的，比如鼠标点击里面就包含了鼠标的相关信息，鼠标坐标啊，如果是键盘事件里面就包含的键盘事件的信息 比如 判断用户按下了那个键</li>
<li>这个事件对象我们可以自己命名 比如 <code>event</code>、<code>evt</code>、<code>e</code></li>
<li>事件对象也有兼容性问题,ie678 通过 <code>window.event</code>,兼容性写法 <code>e = window.event || e;</code></li>
</ol>
<p>官方解释: event 对象代表事件的状态，比如键盘按键的状态、鼠标的位置、鼠标按钮的状态。</p>
<p>简单理解:事件发生后，跟事件相关的一系列信息数据的集合都放到这个对象里面，这个对象就是事件对象 event，它有很多属性和方法。</p>
<h4 id="4-1-事件对象的常见属性和方法"><a href="#4-1-事件对象的常见属性和方法" class="headerlink" title="4.1 事件对象的常见属性和方法"></a>4.1 事件对象的常见属性和方法</h4><table>
<thead>
<tr>
<th>事件对象属性方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>e.target</td>
<td>返回触发事件的对象 标准,<strong>和<code>this</code>不同,this 指向的是绑定事件的对象,例如点击<code>ul&gt;li</code>,target 返回的是 li,this 指向的是 ul</strong></td>
</tr>
<tr>
<td>e.srcElement</td>
<td>返回触发事件的对象 非标准 ie6-8 使用</td>
</tr>
<tr>
<td>e.type</td>
<td>返回事件的类型 比如 click mouseover 不带 on</td>
</tr>
<tr>
<td>e.cancelBubble</td>
<td>该属性阻止冒泡 非标准 ie6-8 使用</td>
</tr>
<tr>
<td>e.returnValue</td>
<td>该属性 阻止默认事件（默认行为） 非标准 ie6-8 使用 比如不让链接跳转</td>
</tr>
<tr>
<td>e.preventDefault()</td>
<td>该方法 阻止默认事件（默认行为） 标准 比如不让链接跳转,也可以使用<code>return false</code>(仅限于传统注册方式)</td>
</tr>
<tr>
<td>e.stopPropagation()</td>
<td>阻止冒泡 标准</td>
</tr>
</tbody></table>
<h3 id="5-阻止事件冒泡"><a href="#5-阻止事件冒泡" class="headerlink" title="5.阻止事件冒泡"></a>5.阻止事件冒泡</h3><h4 id="5-1-阻止事件冒泡的两种方式"><a href="#5-1-阻止事件冒泡的两种方式" class="headerlink" title="5.1 阻止事件冒泡的两种方式"></a>5.1 阻止事件冒泡的两种方式</h4><p>事件冒泡:开始时由最具体的元素接收，然后逐级向上传播到到 DOM 最顶层节点。</p>
<p>事件冒泡本身的特性，会带来的坏处，也会带来的好处，需要我们灵活掌握。</p>
<ul>
<li>标准写法: 利用事件对象里面的 <code>stopPropagation() </code>方法</li>
<li>非标准写法:IE6-8 利用事件对象 <code>cancelBubble</code> 属性</li>
</ul>
<pre><code class="javascript">var father = document.querySelector(&quot;.father&quot;);
var son = document.querySelector(&quot;.son&quot;);

son.addEventListener(
  &quot;click&quot;,
  function (event) &#123;
    if (event &amp;&amp; event.stopPropagation) &#123;
      event.stopPropagation(); // 阻止事件冒泡
    &#125; else &#123;
      window.event.cancelBubble = true; // 阻止事件冒泡
    &#125;
    alert(&quot;son clicked&quot;);
  &#125;,
  false
);
father.addEventListener(
  &quot;click&quot;,
  function (event) &#123;
    alert(&quot;father clicked&quot;);
  &#125;,
  false
);

document.addEventListener(
  &quot;click&quot;,
  function (event) &#123;
    if (event &amp;&amp; event.stopPropagation) &#123;
      event.stopPropagation(); // 阻止事件冒泡
    &#125; else &#123;
      window.event.cancelBubble = true; // 阻止事件冒泡
    &#125;
    alert(&quot;document clicked&quot;);
  &#125;,
  false
);
</code></pre>
<h3 id="6-事件委托-事件代理"><a href="#6-事件委托-事件代理" class="headerlink" title="6.事件委托(事件代理)"></a>6.事件委托(事件代理)</h3><p>事件冒泡本身的特性，会带来的坏处，也会<strong>带来的好处</strong>，需要我们灵活掌握。程序中也有如此场景</p>
<p><strong>事件委托</strong></p>
<p>事件委托也称为事件代理，在 jQuery 里面称为事件委派</p>
<p><strong>事件委托的原理</strong></p>
<p>不是每个子节点单独设置事件监听器,而是<strong>事件监听器设置在其父节点</strong>上，然后利用<strong>冒泡原理</strong>影响设置每个子节点。</p>
<p>以上案例:给 ul 注册点击事件，然后利用事件对象的 <code>target</code> 来找到当前点击的 li,因为点击 li，事件会冒泡到 ul 上, ul 有注册事件，就会触发事件监听器。</p>
<p><strong>事件委托的作用</strong></p>
<p>我们只操作了一次 DOM，提高了程序的性能</p>
<pre><code class="javascript">&lt;ul&gt;
&lt;li&gt;&quot;知否知否,点我应有弹窗在手&quot;&lt;/li&gt;
&lt;li&gt;&quot;知否知否,点我应有弹窗在手&quot;&lt;/li&gt;
&lt;li&gt;&quot;知否知否,点我应有弹窗在手&quot;&lt;/li&gt;
&lt;li&gt;&quot;知否知否,点我应有弹窗在手&quot;&lt;/li&gt;
&lt;li&gt;&quot;知否知否,点我应有弹窗在手&quot;&lt;/li&gt;
&lt;/ul&gt;
&lt;script&gt;
    // 事件委托的核心原理:给父节点添加侦听器，利用事件冒泡影响每一个子节点
    ul = document.querySelector(&quot;ul&quot;);
ul.addEventListener(&quot;click&quot;, function (event) &#123;
    event.target.style.backgroundColor = &quot;red&quot;;
&#125;);
&lt;/script&gt;
</code></pre>
<h3 id="7-常用的鼠标事件"><a href="#7-常用的鼠标事件" class="headerlink" title="7.常用的鼠标事件"></a>7.常用的鼠标事件</h3><h4 id="7-1-常用的鼠标事件"><a href="#7-1-常用的鼠标事件" class="headerlink" title="7.1 常用的鼠标事件"></a>7.1 常用的鼠标事件</h4><table>
<thead>
<tr>
<th>鼠标事件</th>
<th>触发条件</th>
</tr>
</thead>
<tbody><tr>
<td>onclick</td>
<td>鼠标点击左键触发</td>
</tr>
<tr>
<td>onmouseover</td>
<td>鼠标经过触发</td>
</tr>
<tr>
<td>onmouseout</td>
<td>鼠标离开触发</td>
</tr>
<tr>
<td>onfocus</td>
<td>获得鼠标焦点触发</td>
</tr>
<tr>
<td>onblur</td>
<td>失去鼠标焦点触发</td>
</tr>
<tr>
<td>onmousemove</td>
<td>鼠标移动触发</td>
</tr>
<tr>
<td>onmouseup</td>
<td>鼠标弹起触发</td>
</tr>
<tr>
<td>onmousedown</td>
<td>鼠标按下触发</td>
</tr>
</tbody></table>
<ul>
<li>禁止鼠标右键菜单</li>
</ul>
<p><code>contextmenu</code>主要控制应该何时显示上下文菜单，主要用于程序员取消默认的上下文菜单</p>
<pre><code class="javascript">document.addEventListener(&quot;contextmenu&quot;, function (e) &#123;
  e.preventDefault();
&#125;);
</code></pre>
<ul>
<li>禁止鼠标选中(selectstart 开始选中)</li>
</ul>
<pre><code class="javascript">document.addEventListener(&quot;selectstart&quot;, function (e) &#123;
  e.preventDefault();
&#125;);
</code></pre>
<h4 id="7-2-鼠标事件对象"><a href="#7-2-鼠标事件对象" class="headerlink" title="7.2 鼠标事件对象"></a>7.2 鼠标事件对象</h4><p><code>event</code>对象代表事件的状态，跟<code>事件相关的一系列信息</code>的集合。现阶段我们主要是用鼠标事件对象<code>MouseEvent</code>和键盘事件对象<code>KeyboardEvent</code>。</p>
<table>
<thead>
<tr>
<th>鼠标事件对象</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>e.clientX</td>
<td>返回鼠标相对于浏览器窗口可视区的 X 坐标</td>
</tr>
<tr>
<td>e.clientY</td>
<td>返回鼠标相对于浏览器窗口可视区的 Y 坐标</td>
</tr>
<tr>
<td>e.pageX</td>
<td>返回鼠标相对于文档页面的 X 坐标 IE9+ 支持</td>
</tr>
<tr>
<td>e.pageY</td>
<td>返回鼠标相对于文档页面的 Y 坐标 IE9+ 支持</td>
</tr>
<tr>
<td>e.screenX</td>
<td>返回鼠标相对于电脑屏幕的 X 坐标</td>
</tr>
<tr>
<td>e.screenY</td>
<td>返回鼠标相对于电脑屏幕的 Y 坐标</td>
</tr>
</tbody></table>
<pre><code class="javascript">/* 鼠标图片 */
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
    &lt;title&gt;鼠标图片&lt;/title&gt;
    &lt;style&gt;
      body &#123;
        position: relative;
      &#125;
      img &#123;
        position: absolute;
        top: 0;
        left: 0;
        /* 鼠标样式 */
        cursor: none;
      &#125;
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;img src=&quot;../src/jumpfire.gif&quot; alt=&quot;&quot; /&gt;
  &lt;/body&gt;
  &lt;script&gt;
    const img = document.querySelector(&quot;img&quot;);
    document.addEventListener(&quot;mousemove&quot;, function (event) &#123;
      img.style.top = event.clientY - img.height / 2 + &quot;px&quot;;
      img.style.left = event.clientX - img.width / 2 + &quot;px&quot;;
    &#125;);
  &lt;/script&gt;
&lt;/html&gt;
</code></pre>
<ul>
<li>鼠标不断的移动，使用鼠标移动事件:<code>mousemove</code></li>
<li>在页面中移动，给 document 注册事件</li>
<li>图片要移动距离，而且不占位置，我们使用绝对定位即可</li>
<li>核心原理:每次鼠标移动，我们都会获得最新的鼠标坐标，把这个 x 和 y 坐标做为图片的 top 和 left 值就可以移动图片</li>
</ul>
<h3 id="8-常用的键盘事件"><a href="#8-常用的键盘事件" class="headerlink" title="8.常用的键盘事件"></a>8.常用的键盘事件</h3><h4 id="8-1-常用键盘事件"><a href="#8-1-常用键盘事件" class="headerlink" title="8.1 常用键盘事件"></a>8.1 常用键盘事件</h4><p>事件除了使用鼠标触发，还可以使用<strong>键盘触发</strong>。</p>
<table>
<thead>
<tr>
<th>键盘事件</th>
<th>触发条件</th>
</tr>
</thead>
<tbody><tr>
<td>onkeyup</td>
<td>某个键盘按键被松开时触发</td>
</tr>
<tr>
<td>onkeydown</td>
<td>某个键盘按键被按下时触发</td>
</tr>
<tr>
<td>onkeypress</td>
<td>某个键盘按键被按下时触发 <strong>但是它不识别功能键 比如 ctrl shift 箭头等</strong></td>
</tr>
</tbody></table>
<p>注意</p>
<ol>
<li>如果使用 addEventListener 不需要加 on</li>
<li>onkeypress 和前面 2 个的区别是，它不识别功能键，比如左右箭头，shift 等</li>
<li>三个事件的执行顺序是:<code>keydown --- keypress --- keyup</code></li>
<li><code>keyup 和 keydown 不区分大小写</code></li>
</ol>
<h4 id="8-2-键盘事件属性"><a href="#8-2-键盘事件属性" class="headerlink" title="8.2 键盘事件属性"></a>8.2 键盘事件属性</h4><ul>
<li><code>keyCode</code>返回按下按键的<strong>Ascii 码值</strong></li>
<li><code>key</code>返回按下按键的键</li>
</ul>
<p><strong>京东光标定位案例</strong></p>
<pre><code class="javascript">var input = document.querySelector(&quot;input&quot;);
document.addEventListener(&quot;keyup&quot;, function (event) &#123;
  if (event.key === &quot;s&quot;) &#123;
    input.focus();
    input.value = &quot;&quot;;
  &#125;
&#125;);
</code></pre>
<p><strong>京东快递查询案例</strong></p>
<pre><code class="javascript">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
    &lt;title&gt;京东快递查询&lt;/title&gt;
    &lt;style&gt;
      * &#123;
        margin: 0;
        padding: 2px;
      &#125;
      .search &#123;
        display: block;
        width: 300px;
        margin: auto;
        margin-top: 100px;
      &#125;
      .con &#123;
        width: 100%;
        height: 30px;
        line-height: 30px;
        border: 1px solid #ccc;
        display: none;
        margin-bottom: 10px;
        font-size: larger;
        position: relative;
        box-shadow: 2px 3px 3px #ccc;
      &#125;
      .con::before &#123;
        content: &quot;&quot;;
        position: absolute;
        top: 34px;
        left: 17px;
        display: inline-block;

        /* 三角 */
        border-top: 10px solid white;
        border-left: 5px solid transparent;
        border-bottom: 5px solid transparent;
        border-right: 5px solid transparent;
      &#125;
      input &#123;
        display: inline-block;
        width: 100%;
        height: 100%;
        color: rgb(186, 188, 187);
      &#125;
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div class=&quot;search&quot;&gt;
      &lt;div class=&quot;con&quot;&gt;123&lt;/div&gt;
      &lt;input type=&quot;text&quot; value=&quot;请输入快递单号&quot; /&gt;
    &lt;/div&gt;
  &lt;/body&gt;
  &lt;script&gt;
    const input = document.querySelector(&quot;input&quot;);
    const con = document.querySelector(&quot;.con&quot;);
    input.addEventListener(&quot;focus&quot;, function () &#123;
      if (this.value === &quot;请输入快递单号&quot;) &#123;
        this.value = &quot;&quot;;
        this.style.color = &quot;black&quot;;
      &#125; else &#123;
        con.style.display = &quot;block&quot;;
      &#125;
    &#125;);
    input.addEventListener(&quot;blur&quot;, function () &#123;
      con.style.display = &quot;none&quot;;
    &#125;);
    input.addEventListener(&quot;keyup&quot;, function () &#123;
      if (this.value === &quot;&quot;) &#123;
        con.style.display = &quot;none&quot;;
      &#125; else &#123;
        con.style.display = &quot;block&quot;;
      &#125;
    &#125;);
    input.addEventListener(&quot;input&quot;, function () &#123;
      con.style.display = &quot;block&quot;;
      con.textContent = this.value;
    &#125;);
  &lt;/script&gt;
&lt;/html&gt;
</code></pre>
<p><strong>注意:<code>keydown</code>和<code>keypress</code>在文本框里面的特点:他们两个事件触发的时候，文字还没有落入文本框中。</strong><code>keyup</code>事件触发的时候，文字已经落入文本框里面了</p>
<h2 id="BOM-浏览器对象模型"><a href="#BOM-浏览器对象模型" class="headerlink" title="BOM 浏览器对象模型"></a>BOM 浏览器对象模型</h2><ul>
<li>能够说出什么是 BOM</li>
<li>能够知道浏览器的顶级对象 window</li>
<li>能够写出页面加载事件以及注意事项</li>
<li>能够写出两种定时器函数并说出区别</li>
<li>能够说出 JS 执行机制</li>
<li>能够使用 location 对象完成页面之间的跳转</li>
<li>能够知晓 navigator 对象涉及的属性</li>
<li>能够使用 history 提供的方法实现页面刷新</li>
</ul>
<h3 id="1-BOM-概述"><a href="#1-BOM-概述" class="headerlink" title="1.BOM 概述"></a>1.BOM 概述</h3><h4 id="1-1-什么是-BOM"><a href="#1-1-什么是-BOM" class="headerlink" title="1.1 什么是 BOM"></a>1.1 什么是 BOM</h4><p><code>BOM(BrowserObjectModel)</code>即浏览器对象模型它提供了独立于内容而与<code>浏览器窗口进行交互的对象</code>，其核心对象是 window。</p>
<p><strong>BOM 由一系列相关的对象构成，并且每个对象都提供了很多方法与属性。</strong></p>
<p>BOM 缺乏标准，JavaScript 语法的标准化组织是 ECMA，DOM 的标准化组织是 W3C，BOM 最初是 Netscape 浏览器标准的一部分。<br><img src="/2024/10/14/javascript-xue-xi/dom%E5%92%8Cbom%E7%9A%84%E5%8C%BA%E5%88%AB.png" alt="image-20240921115514114"></p>
<h4 id="1-2-BOM-的构成"><a href="#1-2-BOM-的构成" class="headerlink" title="1.2 BOM 的构成"></a>1.2 BOM 的构成</h4><p><strong>BOM 比 DOM 更大，它包含 DOM.</strong></p>
<p><code>window对象</code>是浏览器的顶级对象，它具有双重角色。</p>
<ol>
<li>它是 JS 访问浏览器窗口的一个接口。</li>
<li>它是一个全局对象。定义在<strong>全局作用域中的变量、函数都会变成 window 对象的属性和方法。</strong>在调用的时候可以省略 window，前面学习的对话框都属于 window 对象方法，如 alert()、prompt()等</li>
<li><strong>注意:window 下的一个特殊属性<code>window.name</code></strong></li>
</ol>
<h3 id="2-window-对象的常见事件"><a href="#2-window-对象的常见事件" class="headerlink" title="2.window 对象的常见事件"></a>2.window 对象的常见事件</h3><h4 id="2-1-窗口加载事件"><a href="#2-1-窗口加载事件" class="headerlink" title="2.1 窗口加载事件"></a>2.1 窗口加载事件</h4><pre><code class="javascript">window.onload = function () &#123;&#125;;
或者;
window.addEventListener(&quot;load&quot;, function () &#123;&#125;);
</code></pre>
<p><code>window.onload</code> 是窗口(页面)加载事件,当文档内容完全加载完成会触发该事件(包括图像、脚本文件、CSS 文件等),就调用的处理函数。</p>
<p><strong>注意:</strong></p>
<ol>
<li>有了 <code>window.onload</code> 就可以把 JS 代码写到页面元素的上方,因为 onload 是等页面内容全部加载完毕再去执行处理函数。</li>
<li>window.onload 传统注册事件方式只能写一次，如果有多个，会以最后一个 window.onload 为准,</li>
<li>如果使用 <code>addEventListener</code> 则没有限制</li>
</ol>
<pre><code class="javascript">document.addEventListener(&quot;DOMContentLoaded&quot;, function () &#123;&#125;);
</code></pre>
<p><code>DOMContentLoaded</code>事件触发时，仅当 DOM 加载完成，不包括样式表，图片，flash 等等，加载速度比 onload 快</p>
<h4 id="2-2-调整窗口大小事件"><a href="#2-2-调整窗口大小事件" class="headerlink" title="2.2 调整窗口大小事件"></a>2.2 调整窗口大小事件</h4><pre><code class="javascript">window.onresize = function () &#123;&#125;;
window.addEventListener(&quot;resize&quot;, function () &#123;&#125;);
</code></pre>
<p><code>window.onresize</code> 是调整窗口大小加载事件,当触发时就调用的处理函数。</p>
<p>注意:</p>
<ol>
<li>只要窗口大小发生<strong>像素变化</strong>，就会触发这个事件。</li>
<li>我们经常利用这个事件完成响应式布局。<code>window.innerWidth</code>当前屏幕的宽度</li>
</ol>
<h3 id="3-定时器"><a href="#3-定时器" class="headerlink" title="3.定时器"></a>3.定时器</h3><h4 id="3-1-两种定时器"><a href="#3-1-两种定时器" class="headerlink" title="3.1 两种定时器"></a>3.1 两种定时器</h4><p>window 对象给我们提供了 2 个非常好用的方法-<code>定时器</code>。</p>
<ul>
<li><code>setTimeout()</code></li>
<li><code>setInterval()</code></li>
</ul>
<h4 id="3-2-setTimeout-定时器"><a href="#3-2-setTimeout-定时器" class="headerlink" title="3.2 setTimeout()定时器"></a>3.2 <code>setTimeout()</code>定时器</h4><pre><code class="javascript">window.setrimeout(调用函数，[延迟的毫秒数]);
</code></pre>
<ul>
<li><p><code>setTimeout()</code> 方法用于设置一个定时器，该定时器在定时器到期后执行调用函数。</p>
</li>
<li><p>调用函数可以写<code>匿名函数</code>、<code>函数名</code>、<code>&#39;函数名()&#39;</code></p>
</li>
<li><p><code>setTimeout()</code>这个调用函数我们也称为回调函数<code>callback</code></p>
</li>
</ul>
<h4 id="3-3-停止setTimeout-定时器"><a href="#3-3-停止setTimeout-定时器" class="headerlink" title="3.3 停止setTimeout()定时器"></a>3.3 停止<code>setTimeout()</code>定时器</h4><pre><code class="javascript">window.clearTimeout(timeoutID);

var boom = window.setTimeout(function () &#123;
  alert(&quot;BOOM&quot;);
&#125;, 5000);

var btn = document.querySelector(&quot;button&quot;);
btn.addEventListener(&quot;click&quot;, function () &#123;
  window.clearTimeout(boom);
  console.log(&quot;炸弹拆除成功&quot;);
&#125;);
</code></pre>
<h4 id="3-4-setInterval-定时器"><a href="#3-4-setInterval-定时器" class="headerlink" title="3.4 setInterval()定时器"></a>3.4 <code>setInterval()</code>定时器</h4><pre><code class="javascript">window.setInterval(回调函数，[间隔的毫秒数]);
</code></pre>
<p><code>setInterval()</code>方法<strong>重复调用</strong>一个函数，每隔这个时间，就去调用一次回调函数。</p>
<p><strong>注意:</strong></p>
<ol>
<li>window 可以省略。</li>
<li>这个调用函数可以<code>直接写函数，或者写函数名或者采取字符串&#39;函数名()&#39;</code>三种形式</li>
<li>间隔的毫秒数省略默认是 0,如果写，必须是<strong>毫秒</strong>，表示每隔多少毫秒就自动调用这个函数。</li>
<li>因为定时器可能有很多，所以我们经常给<strong>定时器赋值一个标识符</strong></li>
</ol>
<h4 id="3-5-京东定时器案例"><a href="#3-5-京东定时器案例" class="headerlink" title="3.5 京东定时器案例"></a>3.5 京东定时器案例</h4><ol>
<li>这个倒计时是不断变化的，因此需要定时器来自动变化(<code>setInterval</code>)</li>
</ol>
<pre><code class="javascript">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
    &lt;title&gt;定时器案例&lt;/title&gt;
    &lt;style&gt;
      .hour,
      .min,
      .sec &#123;
        width: 50px;
        height: 50px;
        background-color: rgb(50, 50, 50);
        color: white;
        text-align: center;
        line-height: 50px;
        font-family: &quot;Courier New&quot;, Courier, monospace;
        font-size: 20px;
        float: left;
        margin-left: 5px;
      &#125;
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div class=&quot;time&quot;&gt;
      &lt;div class=&quot;hour&quot;&gt;1&lt;/div&gt;
      &lt;div class=&quot;min&quot;&gt;2&lt;/div&gt;
      &lt;div class=&quot;sec&quot;&gt;3&lt;/div&gt;
    &lt;/div&gt;
  &lt;/body&gt;
  &lt;script&gt;
    var hour = document.querySelector(&quot;.hour&quot;);
    var min = document.querySelector(&quot;.min&quot;);
    var sec = document.querySelector(&quot;.sec&quot;);
    var inputTime = +new Date(&quot;2024-09-22 23:59:59&quot;); // 返回的是用户输入时间总的毫秒数
    function getTime() &#123;
      var nowTime = +new Date(); // 返回的是当前时间总的毫秒数
      var times = (inputTime - nowTime) / 1000; // times是剩余时间总的秒数
      var h = parseInt((times / 60 / 60) % 24); // 时
      h = h &lt; 10 ? &quot;0&quot; + h : h;
      hour.innerHTML = h;
      var m = parseInt((times / 60) % 60); // 分
      m = m &lt; 10 ? &quot;0&quot; + m : m;
      min.innerHTML = m;
      var s = parseInt(times % 60); // 当前的秒
      s = s &lt; 10 ? &quot;0&quot; + s : s;
      sec.innerHTML = s;
    &#125;
    getTime(); // 第一次调用getTime函数
    setInterval(getTime, 1000); // 每秒调用一次getTime函数
  &lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h4 id="3-6-清除clearInterval-定时器"><a href="#3-6-清除clearInterval-定时器" class="headerlink" title="3.6 清除clearInterval()定时器"></a>3.6 清除<code>clearInterval()</code>定时器</h4><pre><code class="javascript">window.clearInterval(IntervalID);
</code></pre>
<h4 id="3-7-发送短信按钮"><a href="#3-7-发送短信按钮" class="headerlink" title="3.7 发送短信按钮"></a>3.7 发送短信按钮</h4><pre><code class="javascript">  &lt;body&gt;
    &lt;input type=&quot;&quot; /&gt;
    &lt;button&gt;发送&lt;/button&gt;
  &lt;/body&gt;
  &lt;script&gt;
    var btn = document.querySelector(&quot;button&quot;);
    var input = document.querySelector(&quot;input&quot;);
    var totalTime = 60;
    var timer = null;
    btn.addEventListener(&quot;click&quot;, function () &#123;
      btn.disabled = true;
      timer = setInterval(function () &#123;
        totalTime--;
        if (totalTime &lt; 0) &#123;
          clearInterval(timer);
          totalTime = 60;
          btn.disabled = false;
          input.value = &quot;发送成功&quot;;
          return;
        &#125;
        btn.innerText = &quot;发送(&quot; + totalTime + &quot;)&quot;;
      &#125;, 1000);
    &#125;);
  &lt;/script&gt;
</code></pre>
<h4 id="3-8-this-指向问题"><a href="#3-8-this-指向问题" class="headerlink" title="3.8 this 指向问题"></a>3.8 this 指向问题</h4><ol>
<li>this 指向问题,一般情况下 this 的最终指向的是那个调用它的对象</li>
<li>方法调用中谁调用 this 指向谁</li>
<li>全局作用域或者普通函数中,this 指向全局对象 window(注意定时器里面的 this 指向 window)</li>
<li>构造函数中 this 指向构造函数的实例</li>
</ol>
<h3 id="4-JS-执行机制"><a href="#4-JS-执行机制" class="headerlink" title="4.JS 执行机制"></a>4.JS 执行机制</h3><p>JavaScript 语言的一大特点就是<code>单线程</code>,也就是说,同一个时间只能做一件事。</p>
<p>这是因为<strong>Javascript 这门脚本语言诞生的使命所致</strong>–JavaScript 是为处理页面中用户的交互，以及操作 DOM 而诞生的。比如我们对某个 DOM 元素进行添加和删除操作，不能同时进行。应该先进行添加，之后再删除。</p>
<h4 id="4-1-同步和异步"><a href="#4-1-同步和异步" class="headerlink" title="4.1 同步和异步"></a>4.1 同步和异步</h4><p>为了解决这个问题,利用多核 CPU 的计算能力，HTML5 提出<code>WebWorker标准</code>，允许 JavaScript 脚本创建多个线程。于是 JS 中出现了<strong>同步和异步</strong></p>
<ul>
<li><p>同步: 一个任务结束后再执行后一个任务，程序的执行顺序与任务的排列顺序是一致的、同步的。</p>
</li>
<li><p>异步: 你在做一件事情时，因为这件事情会花费很长时间，在做这件事的同时，你还可以去处理其他事情。</p>
</li>
<li><p>同步任务</p>
</li>
</ul>
<p><strong>同步任务都在主线程上执行，形成一个执行栈。</strong></p>
<ul>
<li>异步任务</li>
</ul>
<p>JS 的异步是通过<strong>回调函数</strong>实现的。<br>一般而言，异步任务有以下三种类型:</p>
<ol>
<li>普通事件，如<code>click</code>、<code>resize</code>等</li>
<li>资源加载，如<code>load</code>、<code>error</code>等</li>
<li>定时器，包括<code>setlnterval</code>、<code>setTimeout</code>等</li>
<li>异步任务相关回调函数添加到<code>任务队列</code>中(<strong>任务队列也称为消息队列</strong>)。</li>
</ol>
<h4 id="4-2-Js-执行机制"><a href="#4-2-Js-执行机制" class="headerlink" title="4.2 Js 执行机制"></a>4.2 Js 执行机制</h4><ol>
<li><strong>先执行执行栈中的同步任务</strong></li>
<li>异步任务(回调函数)放入任务队列中。</li>
<li>一旦执行栈中的所有同步任务执行完毕,系统就会<strong>按次序</strong>读取任务队列中的异步任务，于是被读取的异步任务结束等待状态，进入<strong>执行栈</strong>，开始执行。</li>
</ol>
<img src="/2024/10/14/javascript-xue-xi/js执行机制.png" alt="image-20240922194648727" style="zoom:80%;">

<h4 id="4-3-Js-事件循环机制"><a href="#4-3-Js-事件循环机制" class="headerlink" title="4.3 Js 事件循环机制"></a>4.3 Js 事件循环机制</h4><p><img src="/2024/10/14/javascript-xue-xi/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6.png" alt="image-20240922195117756"></p>
<h3 id="5-location-对象"><a href="#5-location-对象" class="headerlink" title="5.location 对象"></a>5.location 对象</h3><h4 id="5-1-什么是-location-对象"><a href="#5-1-什么是-location-对象" class="headerlink" title="5.1 什么是 location 对象"></a>5.1 什么是 location 对象</h4><p><code>window对象</code>给我们提供了一个<code>location属性</code>用于获取或设置窗体的<code>URL</code>,并且可以用于解析 URL。</p>
<p>因为这个属性返回的是一个对象，所以我们将这个属性也称为 location 对象。</p>
<h4 id="5-2-URL"><a href="#5-2-URL" class="headerlink" title="5.2 URL"></a>5.2 URL</h4><p><code>统一资源定位符(Uniform Resource Locator,URL)</code>是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的 URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。</p>
<p>URL 的一般语法格式为:</p>
<pre><code class="txt">protocol://host[:port]/path/[?query]#fragment
http://www.itcast.cn/index.html?name=andy&amp;age=18#link
</code></pre>
<table>
<thead>
<tr>
<th>组成</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>protocol</td>
<td>通信协议 常用的 http, ftp, mailto 等</td>
</tr>
<tr>
<td>host</td>
<td>主机（域名） <a target="_blank" rel="noopener" href="http://www.itheima.com/">www.itheima.com</a></td>
</tr>
<tr>
<td>port</td>
<td>端口号 可选，省略时使用方案的默认端口 如 http 的默认端口为 80</td>
</tr>
<tr>
<td>path</td>
<td>路径 由零或多个’&#x2F;‘符号隔开的字符串，一般用来表示主机上的一个目录或文件地址</td>
</tr>
<tr>
<td>query</td>
<td>参数 以键值对的形式，通过’&amp;’符号分隔开来</td>
</tr>
<tr>
<td>fragment</td>
<td>片段 #后面内容 常见于链接 锚点</td>
</tr>
</tbody></table>
<h4 id="5-3-location-对象的属性和方法"><a href="#5-3-location-对象的属性和方法" class="headerlink" title="5.3 location 对象的属性和方法"></a>5.3 location 对象的属性和方法</h4><table>
<thead>
<tr>
<th>location 对象属性</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td>location.href</td>
<td>获取或者设置 整个 URL</td>
</tr>
<tr>
<td>location.host</td>
<td>返回主机（域名） <a target="_blank" rel="noopener" href="http://www.itheima.com/">www.itheima.com</a></td>
</tr>
<tr>
<td>location.port</td>
<td>返回端口号 如果未写返回 空字符串</td>
</tr>
<tr>
<td>location.pathname</td>
<td>返回路径</td>
</tr>
<tr>
<td>location.search</td>
<td>返回参数</td>
</tr>
<tr>
<td>location.hash</td>
<td>返回片段 #后面内容 常见于链接 锚点</td>
</tr>
</tbody></table>
<h4 id="5-4-定时跳转页面"><a href="#5-4-定时跳转页面" class="headerlink" title="5.4 定时跳转页面"></a>5.4 定时跳转页面</h4><pre><code class="javascript">// 定时跳转页面
setTimeout(&quot;location.href=&#39;http://www.baidu.com&#39;&quot;, 3000); // 3秒后跳转到百度
</code></pre>
<h4 id="5-5-多页面间参数传递"><a href="#5-5-多页面间参数传递" class="headerlink" title="5.5 多页面间参数传递"></a>5.5 多页面间参数传递</h4><ul>
<li>第一个登录页面，里面有提交表单，action 提交到 index.html 页面</li>
<li>第二个页面，可以使用第一个页面的参数，这样实现了一个数据不同页面之间的传递效果</li>
<li>第二个页面之所以可以使用第一个页面的数据，是利用了 URL 里面的<strong>location.search</strong>参数</li>
</ul>
<pre><code class="javascript">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
    &lt;title&gt;获取url参数&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;form action=&quot;74_获取url参数_2.html&quot;&gt;
      用户名: &lt;input type=&quot;text&quot; name=&quot;uname&quot; /&gt;
      &lt;input type=&quot;submit&quot; value=&quot;登陆&quot; /&gt;
    &lt;/form&gt;
  &lt;/body&gt;
&lt;/html&gt;

&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;meta
      name=&quot;viewport&quot;
      content=&quot;width=device-width, user-scalable=no, initial-scale=1.0&quot;
    /&gt;
    &lt;title&gt;获取url参数&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;script&gt;
      var s = window.location.search;
      var params = s.substr(1).split(&quot;&amp;&quot;);
      for (var i = 0; i &lt; params.length; i++) &#123;
        console.log(params[i]);
        var param = params[i].split(&quot;=&quot;);
        if (param[0] == &quot;uname&quot;) &#123;
          document.write(&quot;&lt;p&gt;你好，&quot; + param[1] + &quot;！欢迎来到我的博客。&lt;/p&gt;&quot;);
        &#125;
      &#125;
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h4 id="5-6-location-对象方法"><a href="#5-6-location-对象方法" class="headerlink" title="5.6 location 对象方法"></a>5.6 location 对象方法</h4><table>
<thead>
<tr>
<th>location 对象方法</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td>location.assign()</td>
<td>跟 href 一样，可以跳转页面（也称为重定向页面）</td>
</tr>
<tr>
<td>location.replace()</td>
<td>替换当前页面，因为不记录历史，所以不能后退页面</td>
</tr>
<tr>
<td>location.reload()</td>
<td>重新加载页面，相当于刷新按钮或者 f5 如果参数为 true 强制刷新 ctrl+f5</td>
</tr>
</tbody></table>
<h3 id="6-navigator-对象"><a href="#6-navigator-对象" class="headerlink" title="6.navigator 对象"></a>6.navigator 对象</h3><p>navigator 对象包含有关浏览器的信息，它有很多属性，我们最常用的是<code>userAgent</code>，该属性可以返回由客户机发送服务器的 user-agent 头部的值。</p>
<p>下面前端代码可以判断用户那个终端打开页面，实现跳转</p>
<pre><code class="javascript">if (
  navigator.userAgent.match(
    /(phone|pad|iPhone|iPod|Android|BlackBerry|IEMobile|Opera Mini|Windows Phone)/i
  )
) &#123;
  // 手机
  window.location.href = &quot;https://m.example.com&quot;; // 将用户重定向到移动版网页
&#125; else &#123;
  // 电脑
  window.location.href = &quot;https://www.example.com&quot;; // 将用户重定向到桌面版网页
&#125;
</code></pre>
<h4 id="7-history-对象"><a href="#7-history-对象" class="headerlink" title="7.history 对象"></a>7.history 对象</h4><p>window 对象给我们提供了一个 history 对象，与浏览器历史记录进行交互。该对象包含用户(在浏览器窗口中)访问过的 URL。</p>
<table>
<thead>
<tr>
<th>history 对象方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>back()</td>
<td>可以后退功能</td>
</tr>
<tr>
<td>forward()</td>
<td>前进功能</td>
</tr>
<tr>
<td>go(参数)</td>
<td>前进后退功能 参数如果是 1 前进 1 个页面 如果是 -1 后退 1 个页面</td>
</tr>
</tbody></table>
<p><strong>history 对象一般在实际开发中比较少用，但是会在一些 OA 办公系统中见到。</strong></p>
<h2 id="PC-端网页特效"><a href="#PC-端网页特效" class="headerlink" title="PC 端网页特效"></a>PC 端网页特效</h2><ul>
<li>能够说出常见 offset 系列属性的作用</li>
<li>能够说出常见 client 系列属性的作用</li>
<li>能够说出常见 scroll 系列属性的作用 R</li>
<li>能够封装简单动画函数</li>
<li>能够写出网页轮播图案例</li>
</ul>
<h3 id="0-立即执行函数"><a href="#0-立即执行函数" class="headerlink" title="0.立即执行函数"></a>0.立即执行函数</h3><p>立即执行函数<code>(function() &#123;&#125;)();</code> 或者 <code>(function()&#123;&#125; ());</code></p>
<p>主要作用:</p>
<ul>
<li>创建一个独立的作用域,里面所有变量都是局部变量,不会存在命名冲突</li>
<li>不需要调用,立即执行</li>
<li>可以传参,可以起函数名</li>
</ul>
<pre><code class="javascript">(function sum(a, b) &#123;
  console.log(a + b); // 输出4
&#125;)(1, 3);
</code></pre>
<h3 id="1-offset-系列属性"><a href="#1-offset-系列属性" class="headerlink" title="1.offset 系列属性"></a>1.offset 系列属性</h3><h4 id="1-1-offset-概述"><a href="#1-1-offset-概述" class="headerlink" title="1.1 offset 概述"></a>1.1 offset 概述</h4><p><code>offset</code>翻译过来就是偏移量，我们使用 offset 系列相关属性可以<code>动态的</code>得到该元素的<strong>位置(偏移)、大小</strong>等</p>
<ul>
<li><strong>获得元素距离带有定位父元素的位置</strong></li>
<li>获取自身属性</li>
</ul>
<table>
<thead>
<tr>
<th>offset 系列属性</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>element.offsetParent</td>
<td>返回作为该元素带有定位的父级元素 如果父级都没有定位则返回 body</td>
</tr>
<tr>
<td>element.offsetTop</td>
<td>返回元素相对带有定位父元素上方的偏移</td>
</tr>
<tr>
<td>element.offsetLeft</td>
<td>返回元素相对带有定位父元素左边框的偏移</td>
</tr>
<tr>
<td>element.offsetWidth</td>
<td>返回自身包括 padding、边框、内容区的宽度，返回数值不带单位</td>
</tr>
<tr>
<td>element.offsetHeight</td>
<td>返回自身包括 padding、边框、内容区的高度，返回数值不带单位</td>
</tr>
</tbody></table>
<h4 id="1-2-offset-和-style-的区别"><a href="#1-2-offset-和-style-的区别" class="headerlink" title="1.2 offset 和 style 的区别"></a>1.2 offset 和 style 的区别</h4><table>
<thead>
<tr>
<th>属性</th>
<th>offset</th>
<th>style</th>
</tr>
</thead>
<tbody><tr>
<td>可获取样式</td>
<td>可以得到任意样式表中的样式值</td>
<td>只能得到行内样式表中的样式值</td>
</tr>
<tr>
<td>返回值</td>
<td>获得的数值是没有单位的</td>
<td>获得的是带有单位的字符串</td>
</tr>
<tr>
<td>包含内容</td>
<td>offsetWidth 包含 <code>padding + border + width</code></td>
<td><code>style.width</code>获得的值不包含 padding 和 border</td>
</tr>
<tr>
<td>属性类型</td>
<td>只读属性，只能获取不能赋值</td>
<td>可读写属性，可以获取也可以赋值</td>
</tr>
<tr>
<td>适用场景</td>
<td><strong>想要获取元素大小位置，用 offset 更合适</strong></td>
<td><strong>想要给元素更改值，则需要用 style 改变</strong></td>
</tr>
</tbody></table>
<h4 id="1-3-案例"><a href="#1-3-案例" class="headerlink" title="1.3 案例"></a>1.3 案例</h4><p>放大镜效果</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
    &lt;title&gt;放大镜效果&lt;/title&gt;
    &lt;style&gt;
      .small &#123;
        width: 500px;
        height: 300px;
        position: relative;
      &#125;
      .small .mask &#123;
        display: none;
        position: absolute;
        width: 200px;
        height: 200px;
        background-color: rgba(210, 229, 124, 0.5);
        cursor: move;
      &#125;
      img &#123;
        width: 100%;
        height: 100%;
      &#125;
      .small .big &#123;
        position: absolute;
        top: 50px;
        left: 600px;
        display: none;
        width: 200px;
        height: 200px;
        background-image: url(&quot;../../html下/image.png&quot;);
        background-repeat: no-repeat;
        z-index: 999;
      &#125;
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div class=&quot;small&quot;&gt;
      &lt;img src=&quot;../../html下/image.png&quot; alt=&quot;&quot; /&gt;
      &lt;div class=&quot;mask&quot;&gt;&lt;/div&gt;
      &lt;div class=&quot;big&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
  &lt;/body&gt;
  &lt;script&gt;
    var small = document.querySelector(&quot;.small&quot;);
    var img = small.querySelector(&quot;img&quot;);
    var mask = small.querySelector(&quot;.mask&quot;);
    var big = document.querySelector(&quot;.small .big&quot;);

    function showImg(x, y) &#123;
      big.style.transform = &quot;scale(1.5)&quot;;
      big.style.backgroundPosition = -x + &quot;px&quot; + &quot; &quot; + (-y + &quot;px&quot;);
    &#125;

    small.addEventListener(&quot;mousedown&quot;, function (e) &#123;
      mask.style.display = &quot;block&quot;;
      big.style.display = &quot;block&quot;;
      document.addEventListener(&quot;mousemove&quot;, function (e) &#123;
        var x = e.pageX - small.offsetLeft - 100;
        var y = e.pageY - small.offsetTop - 100;
        if (x &lt; 0) &#123;
          x = 0;
        &#125;
        if (x &gt; small.offsetWidth - mask.offsetWidth) &#123;
          x = small.offsetWidth - mask.offsetWidth;
        &#125;
        if (y &lt; 0) &#123;
          y = 0;
        &#125;
        if (y &gt; small.offsetHeight - mask.offsetHeight) &#123;
          y = small.offsetHeight - mask.offsetHeight;
        &#125;
        showImg(x, y);
        mask.style.left = x + &quot;px&quot;;
        mask.style.top = y + &quot;px&quot;;
      &#125;);
      document.addEventListener(&quot;mouseup&quot;, function (e) &#123;
        mask.style.display = &quot;none&quot;;
        big.style.display = &quot;none&quot;;
      &#125;);
    &#125;);
  &lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h3 id="2-元素可视区-client-系列"><a href="#2-元素可视区-client-系列" class="headerlink" title="2. 元素可视区 client 系列"></a>2. 元素可视区 client 系列</h3><p>client 翻译过来就是客户端,我们使用<strong>client 系列</strong>的相关属性来获取元素可视区的相关信息。通过 client 系列的相关属性 可以动态的得到该元素的边框大小、元素大小等。</p>
<h4 id="2-1-常见-client-属性"><a href="#2-1-常见-client-属性" class="headerlink" title="2.1 常见 client 属性"></a>2.1 常见 client 属性</h4><table>
<thead>
<tr>
<th>client 系列属性</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>element.clientTop</td>
<td>返回元素上边框的大小</td>
</tr>
<tr>
<td>element.clientLeft</td>
<td>返回元素左边框的大小</td>
</tr>
<tr>
<td>element.clientWidth</td>
<td>返回自身包括 padding、内容区的宽度，不含边框，返回数值不带单位</td>
</tr>
<tr>
<td>element.clientHeight</td>
<td>返回自身包括 padding、内容区的高度，不含边框，返回数值不带单位</td>
</tr>
</tbody></table>
<h3 id="3-元素滚动-scorll-系列"><a href="#3-元素滚动-scorll-系列" class="headerlink" title="3. 元素滚动 scorll 系列"></a>3. 元素滚动 scorll 系列</h3><h4 id="3-1-元素-scroll-系列属性"><a href="#3-1-元素-scroll-系列属性" class="headerlink" title="3.1 元素 scroll 系列属性"></a>3.1 元素 scroll 系列属性</h4><p>scroll 翻译过来就是滚动的，我们使用 scroll 系列的相关属性可以动态的得到该元素的大小、滚动距离等。</p>
<table>
<thead>
<tr>
<th>scroll 系列属性</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>element.scrollTop</td>
<td>返回被卷去的上侧距离，返回数值不带单位</td>
</tr>
<tr>
<td>element.scrollLeft</td>
<td>返回被卷去的左侧距离，返回数值不带单位</td>
</tr>
<tr>
<td>element.scrollWidth</td>
<td>返回自身实际的宽度，不含边框，返回数值不带单位</td>
</tr>
<tr>
<td>element.scrollHeight</td>
<td>返回自身实际的高度，不含边框，返回数值不带单位</td>
</tr>
</tbody></table>
<img src="/2024/10/14/javascript-xue-xi/scorll系列属性.png" alt="image-20240928202943684" style="zoom:80%;">

<h4 id="3-2-仿淘宝滚动栏案例"><a href="#3-2-仿淘宝滚动栏案例" class="headerlink" title="3.2 仿淘宝滚动栏案例"></a>3.2 仿淘宝滚动栏案例</h4><ol>
<li>原先侧边栏是绝对定位</li>
<li>当页面滚动到一定位置，侧边栏改为固定定位</li>
<li>页面继续滚动，会让<strong>返回顶部</strong>显示出来</li>
<li>需要用到页面滚动事件 scroll 因为是页面滚动，所以事件源是 document</li>
<li>滚动到某个位置，就是判断页面被卷去的上部值。</li>
<li>页面被<code>卷去的头部</code>:可以通过<code>window.pageYOffset </code>获得 如果是被卷去的左侧<code> window.pageXOffset</code></li>
</ol>
<h4 id="3-3-页面被卷去的头部兼容性解决方案"><a href="#3-3-页面被卷去的头部兼容性解决方案" class="headerlink" title="3.3 页面被卷去的头部兼容性解决方案"></a>3.3 页面被卷去的头部兼容性解决方案</h4><p>需要注意的是，页面被卷去的头部，有兼容性问题，因此被卷去的头部通常有如下几种写法:</p>
<ol>
<li>声明了 DTD,使用 <code>document.documentElement.scrollTop</code></li>
<li>未声明 DTD,使用 <code>document.body.scrollTop</code></li>
<li>新方法<code>window.pageYOffset</code>和<code>window.pageXOffset</code>，IE9 开始支持</li>
</ol>
<pre><code class="javascript">function getscroll()&#123;
    return &#123;
        left: window.pageXoffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0,
        top: window.pageYoffset || document.documentElement.scrollTop ||  document.body.scrollTop ||  0
    &#125;;
    使用的时候getScro1l().left
</code></pre>
<h3 id="三大系列总结"><a href="#三大系列总结" class="headerlink" title="三大系列总结"></a>三大系列总结</h3><table>
<thead>
<tr>
<th>三大系列大小对比</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>element.offsetWidth</td>
<td>返回自身包括 padding、边框、内容区的宽度，返回数值不带单位</td>
</tr>
<tr>
<td>element.clientWidth</td>
<td>返回自身包括 padding、内容区的宽度，不含边框，返回数值不带单位</td>
</tr>
<tr>
<td>element.scrollWidth</td>
<td>返回自身实际的宽度，不含边框，返回数值不带单位</td>
</tr>
</tbody></table>
<ol>
<li>offset 系列经常用于获得元素位置 <code>offsetLeft</code> <code>offsetTop</code></li>
<li>client 经常用于获取元素大小 <code>clientWidth</code> <code>clientHeight</code></li>
<li>scroll 经常用于获取滚动距离 <code>scrollTop</code> <code>scrollLeft</code></li>
<li><strong>注意页面滚动的距离</strong>通过 <code>window.pagexoffset</code> 获得</li>
</ol>
<h3 id="4-mouseenter-和-mouseover-事件"><a href="#4-mouseenter-和-mouseover-事件" class="headerlink" title="4. mouseenter 和 mouseover 事件"></a>4. mouseenter 和 mouseover 事件</h3><h4 id="mouseenter-鼠标事件"><a href="#mouseenter-鼠标事件" class="headerlink" title="mouseenter 鼠标事件"></a>mouseenter 鼠标事件</h4><ul>
<li>当鼠标移动到元素上时就会触发<strong>mouseenter 事件</strong></li>
<li>类似 mouseover，它们两者之间的差别是</li>
<li>mouseover 鼠标经过自身盒子会触发，<code>经过子盒子还会触发</code>。mouseenter 只会经过自身盒子触发</li>
<li>之所以这样，就是因为 mouseenter 不会冒泡</li>
<li>跟 mouseenter 搭配 鼠标离开 mouseleave 同样不会冒泡</li>
</ul>
<h3 id="5-动画函数封装"><a href="#5-动画函数封装" class="headerlink" title="5. 动画函数封装"></a>5. 动画函数封装</h3><h4 id="5-1-动画实现原理"><a href="#5-1-动画实现原理" class="headerlink" title="5.1 动画实现原理"></a>5.1 动画实现原理</h4><p><strong>核心原理</strong>: 通过定时器 <code>setInterval()</code> 不断移动盒子位置。</p>
<p>1.获得盒子当前位置</p>
<p>2.让盒子在当前位置加上 1 个移动距离</p>
<p>3.利用定时器不断重复这个操作</p>
<p>4.加一个结束定时器的条件</p>
<p>5.注意此元素需要添加定位，才能使用<code>element.style.left</code></p>
<h4 id="5-2-动画函数简单封装"><a href="#5-2-动画函数简单封装" class="headerlink" title="5.2 动画函数简单封装"></a>5.2 动画函数简单封装</h4><pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
    &lt;title&gt;动画元素封装&lt;/title&gt;
    &lt;style&gt;
      div &#123;
        /* 记得加定位 */
        position: absolute;
        left: 0;
        width: 100px;
        height: 100px;
        background-color: blue;
      &#125;
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div&gt;&lt;/div&gt;
  &lt;/body&gt;
  &lt;script&gt;
    function animate(element, moveDistance) &#123;
      var timer = setInterval(function () &#123;
        if (element.offsetLeft &gt;= moveDistance) &#123;
          clearInterval(timer);
        &#125; else &#123;
          element.style.left = element.offsetLeft + 1 + &quot;px&quot;;
        &#125;
      &#125;);
    &#125;
    var div = document.querySelector(&quot;div&quot;);
    animate(div, 400);
  &lt;/script&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
    &lt;title&gt;动画元素封装&lt;/title&gt;
    &lt;style&gt;
      div &#123;
        position: absolute;
        left: 0;
        width: 100px;
        height: 100px;
        background-color: blue;
      &#125;
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div&gt;&lt;/div&gt;
  &lt;/body&gt;
  &lt;script&gt;
    function animate(element, moveDistance) &#123;
      var timer = setInterval(function () &#123;
        if (element.offsetLeft &gt;= moveDistance) &#123;
          clearInterval(timer);
        &#125; else &#123;
          element.style.left = element.offsetLeft + 1 + &quot;px&quot;;
        &#125;
      &#125;);
    &#125;
    var div = document.querySelector(&quot;div&quot;);
    animate(div, 400);
  &lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h4 id="5-3-动画函数给不同元素记录不同定时器"><a href="#5-3-动画函数给不同元素记录不同定时器" class="headerlink" title="5.3 动画函数给不同元素记录不同定时器"></a>5.3 动画函数给不同元素记录不同定时器</h4><p>如果多个元素都使用这个动画函数，每次都要 var 声明定时器。我们可以给不同的元素使用不同的定时器**(自己专门用自己的定时器)**。</p>
<p>核心原理:利用 <code>Js</code> 是一门动态语言，可以很方便的给当前对象添加属性。</p>
<pre><code class="javascript">function animate(element, moveDistance) &#123;
  clearInterval(element.timer);
  element.timer = setInterval(function () &#123;
    if (element.offsetLeft &gt;= moveDistance) &#123;
      clearInterval(element.timer);
    &#125; else &#123;
      element.style.left = element.offsetLeft + 1 + &quot;px&quot;;
    &#125;
  &#125;);
&#125;
</code></pre>
<h4 id="5-4-缓动效果原理"><a href="#5-4-缓动效果原理" class="headerlink" title="5.4 缓动效果原理"></a>5.4 缓动效果原理</h4><p><code>缓动动画</code>就是让元素运动速度有所变化，最常见的是让速度慢慢停下来</p>
<p>思路:</p>
<ol>
<li>让盒子每次移动的距离慢慢变小，速度就会慢慢落下来</li>
<li>核心算法: <code>(目标值-现在的位置)/10</code> 做为每次移动的距离步长</li>
</ol>
<pre><code class="javascript">function animate(element, distance) &#123;
  clearInterval(element.timer);
  element.timer = setInterval(function () &#123;
    step = (distance - element.offsetLeft + 10) / 10;
    if (element.offsetLeft == distance) &#123;
      clearInterval(element.timer);
    &#125; else &#123;
      element.style.left = element.offsetLeft + step + &quot;px&quot;;
      console.log(element.offsetLeft, step);
    &#125;
  &#125;, 15);
&#125;
var box = document.getElementById(&quot;box&quot;);
var btn = document.querySelector(&quot;button&quot;);
btn.addEventListener(&quot;click&quot;, function () &#123;
  animate(box, 900);
&#125;);
</code></pre>
<h4 id="5-5-动画函数添加回调函数"><a href="#5-5-动画函数添加回调函数" class="headerlink" title="5.5 动画函数添加回调函数"></a>5.5 动画函数添加回调函数</h4><p><strong>回调函数原理: 函数可以作为一个参数。</strong></p>
<p>将这个函数作为参数传到另一个函数里面，当那个函数执行完之后，再执行传进去的这个函数，这个过程就叫做<code>回调</code>。</p>
<p>回调函数写的位置:定时器结束的位置。</p>
<h4 id="5-6-动画函数封装到单独-JS-文件里面"><a href="#5-6-动画函数封装到单独-JS-文件里面" class="headerlink" title="5.6 动画函数封装到单独 JS 文件里面"></a>5.6 动画函数封装到单独 JS 文件里面</h4><p>因为以后经常使用这个动画函数，可以单独封装到一个 js 文件里面，使用的时候引用这个 js 文件即可。</p>
<h3 id="6-常见网页特效案例"><a href="#6-常见网页特效案例" class="headerlink" title="6. 常见网页特效案例"></a>6. 常见网页特效案例</h3><h4 id="滚动条案例"><a href="#滚动条案例" class="headerlink" title="滚动条案例"></a>滚动条案例</h4><pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
    &lt;title&gt;滑动条&lt;/title&gt;
    &lt;script src=&quot;animate.js&quot;&gt;&lt;/script&gt;
    &lt;style&gt;
      * &#123;
        margin: 0;
        padding: 0;
        box-sizing: border-box; /* 设置所有元素的 box-sizing 为 border-box */
      &#125;
      body &#123;
        display: flex; /* 使用 flexbox 来控制布局 */
        justify-content: flex-end; /* 使内容右对齐 */
        height: 100vh; /* 全高 */
        align-items: center; /* 垂直居中 */
        overflow: hidden; /* 隐藏滚动条 */
      &#125;
      .sliderbar &#123;
        position: relative;
        height: 40px;
        width: 200px; /* 固定宽度 */
        overflow: hidden; /* 保证内容不会溢出 */
      &#125;
      span &#123;
        display: block;
        position: absolute;
        width: 40px;
        height: 40px;
        background-color: rgb(149, 149, 220);
        line-height: 40px;
        text-align: center;
        font-size: 20px;
        right: 0; /* 右对齐 */
      &#125;
      .con &#123;
        position: absolute;
        left: 200px;
        top: 0;
        height: 40px;
        line-height: 40px;
        text-align: left;
        width: 160px; /* 减少宽度以适应 `span` */
        padding-left: 10px;
        background-color: rgb(149, 149, 220);
      &#125;
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div class=&quot;sliderbar&quot;&gt;
      &lt;div class=&quot;con&quot;&gt;问题反馈&lt;/div&gt;
      &lt;span&gt;&amp;larr;&lt;/span&gt;
    &lt;/div&gt;
    &lt;script&gt;
      var sliderbar = document.querySelector(&quot;.sliderbar&quot;);
      var con = document.querySelector(&quot;.con&quot;);
      var span = document.querySelector(&quot;span&quot;);

      sliderbar.addEventListener(&quot;mouseenter&quot;, function () &#123;
        animate(con, 0);
        span.innerHTML = &quot;&amp;larr;&quot;;
      &#125;);

      sliderbar.addEventListener(&quot;mouseleave&quot;, function () &#123;
        animate(con, 200, function () &#123;&#125;);
        span.innerHTML = &quot;&amp;rarr;&quot;;
      &#125;);
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h4 id="网页轮播条案例"><a href="#网页轮播条案例" class="headerlink" title="网页轮播条案例"></a>网页轮播条案例</h4><pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;meta
      name=&quot;viewport&quot;
      content=&quot;width=device-width, user-scalable=no, initial-scale=1.0&quot;
    /&gt;
    &lt;title&gt;轮播焦点图案例&lt;/title&gt;
    &lt;script src=&quot;animate.js&quot;&gt;&lt;/script&gt;
    &lt;style&gt;
      * &#123;
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      &#125;
      .container &#123;
        position: relative;
        width: 600px;
        height: 400px;
        margin: 0 auto;
        overflow: hidden;
        background-color: pink;
      &#125;
      .box &#123;
        position: absolute;
        top: 0;
        left: 0;
        width: 400%;
        height: 100%;
      &#125;
      .box img &#123;
        width: 600px;
        height: 400px;
        float: left;
      &#125;
      span &#123;
        position: absolute;
        right: 20px;
        top: 50%;
        display: block;
        width: 30px;
        height: 30px;
        line-height: 30px;
        text-align: center;
        font-size: 22px;
        border-radius: 50%;
        transform: translateY(-50%);
        background-color: rgba(213, 13, 13, 0.5);
        cursor: pointer;
      &#125;
      .left &#123;
        left: 20px; /* 左侧按钮位置 */
      &#125;
      ul &#123;
        position: absolute;
        bottom: 10px;
        left: 50%;
        transform: translateX(-50%);
        width: 45px;
        height: 14px;
        background-color: rgba(255, 255, 255, 0.5);
        border-radius: calc(13px / 2);
        overflow: hidden;
      &#125;
      ul li &#123;
        list-style: none;
        margin: 3px;
        float: left;
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: skyblue;
      &#125;
      .selected &#123;
        background: red;
      &#125;
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div class=&quot;container&quot;&gt;
      &lt;div class=&quot;box&quot;&gt;
        &lt;img src=&quot;https://picsum.photos/id/237/600/400&quot; alt=&quot;&quot; /&gt;
        &lt;img src=&quot;https://picsum.photos/id/238/600/400&quot; alt=&quot;&quot; /&gt;
        &lt;img src=&quot;https://picsum.photos/id/239/600/400&quot; alt=&quot;&quot; /&gt;
        &lt;img src=&quot;https://picsum.photos/id/237/600/400&quot; alt=&quot;&quot; /&gt;
      &lt;/div&gt;
      &lt;ul class=&quot;dots&quot;&gt;
        &lt;li class=&quot;selected&quot;&gt;&lt;/li&gt;
        &lt;li&gt;&lt;/li&gt;
        &lt;li&gt;&lt;/li&gt;
        &lt;li&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;span class=&quot;left&quot;&gt;&amp;lt;&lt;/span&gt;
      &lt;span class=&quot;right&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;/div&gt;

    &lt;script&gt;
      var box = document.querySelector(&quot;.box&quot;);
      var right = document.querySelector(&quot;.right&quot;);
      var left = document.querySelector(&quot;.left&quot;);
      var index = 1; // 图片索引
      right.addEventListener(&quot;click&quot;, function () &#123;
        index++;
        if (index &gt; 3) &#123;
          index = 1;
        &#125;
        updateDotsAndAnimate(index);
      &#125;);

      left.addEventListener(&quot;click&quot;, function () &#123;
        index--;
        if (index &lt; 1) &#123;
          index = 3;
        &#125;
        updateDotsAndAnimate(index);
      &#125;);

      function updateDotsAndAnimate(index) &#123;
        var lis = document.querySelectorAll(&quot;ul li&quot;);
        for (var i = 0; i &lt; lis.length; i++) &#123;
          lis[i].classList.remove(&quot;selected&quot;); // 移除所有的选中状态
        &#125;
        var li = document.querySelectorAll(&quot;ul li&quot;)[index - 1];
        li.classList.add(&quot;selected&quot;); // 添加选中状态
        animate(box, -600 * (index - 1)); // 动画效果
      &#125;

      var lis = document.querySelectorAll(&quot;ul li&quot;);
      for (var i = 0; i &lt; lis.length; i++) &#123;
        (function (i) &#123;
          // 使用 IIFE 捕获当前索引
          lis[i].addEventListener(&quot;click&quot;, function () &#123;
            updateDotsAndAnimate(i + 1); // 传递正确的索引
          &#125;);
        &#125;)(i); // 立即调用函数表达式
      &#125;

      var timer = setInterval(function () &#123;
        // 怎么判断是否聚焦
        if (box == document.activeElement) &#123;
          return; // 聚焦则不切换图片
        &#125;
        right.click();
      &#125;, 2000); // 定时切换图片
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h4 id="let关键字"><a href="#let关键字" class="headerlink" title="let关键字"></a>let关键字</h4><p><code>var</code> 和 <code>let</code> 是 JavaScript 中用来声明变量的关键字，它们之间有几个重要的区别：</p>
<ol>
<li><p><strong>作用域</strong>：</p>
<ul>
<li><code>var</code> 声明的变量是函数作用域（function scope）或全局作用域（global scope）。如果在函数内部使用 <code>var</code> 声明变量，那么这个变量的作用域仅限于该函数内部。</li>
<li><code>let</code> 声明的变量是块作用域（block scope）。这意味着 <code>let</code> 声明的变量只在包含它的块中可用（例如，if 语句、for 循环等）。</li>
</ul>
<pre><code class="javascript">if (true) &#123;
  var x = 10; // x 在整个函数或全局作用域可用
  let y = 20; // y 仅在这个块内可用
&#125;
console.log(x); // 输出 10
console.log(y); // 报错: y is not defined
</code></pre>
</li>
<li><p><strong>提升（Hoisting）</strong>：</p>
<ul>
<li><code>var</code> 声明的变量会被提升到作用域的顶部，但在赋值之前，变量的值是 <code>undefined</code>。</li>
<li><code>let</code> 声明的变量也会被提升，但在赋值之前，不能访问这个变量，这会导致”暂时性死区”（temporal dead zone）的错误。</li>
</ul>
<pre><code class="javascript">console.log(a); // 输出 undefined
var a = 5;

console.log(b); // 报错: Cannot access &#39;b&#39; before initialization
let b = 10;
</code></pre>
</li>
<li><p><strong>重复声明</strong>：</p>
<ul>
<li>使用 <code>var</code> 可以在同一作用域内重复声明变量，而不会报错。</li>
<li>使用 <code>let</code> 不允许在同一作用域内重复声明同名变量，这会导致语法错误。</li>
</ul>
<pre><code class="javascript">var c = 1;
var c = 2; // 不报错

let d = 3;
let d = 4; // 报错: Identifier &#39;d&#39; has already been declared
</code></pre>
</li>
<li><p><strong>总结</strong></p>
</li>
</ol>
<ul>
<li>使用 <code>let</code> 声明变量时，它有更严格的作用域规则，并且不会被意外地重复声明。</li>
<li>一般建议使用 <code>let</code>（或 <code>const</code>，用于声明不可变变量）来替代 <code>var</code>，以提高代码的可读性和可维护性。</li>
</ul>
<h4 id="节流阀"><a href="#节流阀" class="headerlink" title="节流阀"></a>节流阀</h4><p>防止轮播图按钮连续点击造成播放过快,</p>
<p><strong>节流阀目的:</strong> 当上一个函数动画内容执行完毕，再去执行下一个函数动画,让事件无法连续触发。</p>
<p><strong>核心实现思路:</strong> 利用回调函数，添加一个变量来控制，锁住函数和解锁函数。</p>
<pre><code class="javascript">var flag = true;
arrow_right.addEventListener(&quot;click&quot;, function () &#123;
  flag = false;
  // 其余代码 ...
  animate(1000, function () &#123;
    // 在回调函数中,等动画结束在改变flag值
    flag = true;
  &#125;);
&#125;);
</code></pre>
<h4 id="返回顶部"><a href="#返回顶部" class="headerlink" title="返回顶部"></a>返回顶部</h4><p>滚动窗口至文档中的特定位置。</p>
<pre><code class="javascript">window.scroll(x, y);
</code></pre>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;meta
      name=&quot;viewport&quot;
      content=&quot;width=device-width, user-scalable=no, initial-scale=1.0&quot;
    /&gt;
    &lt;title&gt;窗口滚动&lt;/title&gt;
    &lt;style&gt;
      .header &#123;
        height: 100px;
        background-color: #de9898;
      &#125;
      .main &#123;
        height: 1500px;
        background-color: #5f3434;
      &#125;
      .footer &#123;
        height: 100px;
        background-color: #b12727;
      &#125;
      div &#123;
        margin-bottom: 30px;
      &#125;
      .backtop &#123;
        position: fixed;
        bottom: 100px;
        right: 100px;
        width: 50px;
        height: 50px;
        background-color: #342a2a;
        border-radius: 50%;
        cursor: pointer;
      &#125;
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div class=&quot;header&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;footer&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;backtop&quot;&gt;&lt;/div&gt;
  &lt;/body&gt;
  &lt;script&gt;
    backtop = document.querySelector(&quot;.backtop&quot;);
    backtop.addEventListener(&quot;click&quot;, function () &#123;
      animate(window, 0, 0, function () &#123;
        console.log(&quot;动画结束&quot;);
      &#125;);
    &#125;);

    function animate(element, distance, duration, callback) &#123;
      clearInterval(element.timer);
      element.timer = setInterval(
        function () &#123;
          var step = (distance - window.pageYOffset) / 10;
          step &gt; 0 ? (step = Math.ceil(step)) : (step = Math.floor(step));

          if (window.pageYOffset == distance) &#123;
            clearInterval(element.timer);
            if (callback) &#123;
              callback();
            &#125;
          &#125; else &#123;
            window.scroll(0, window.pageYOffset + step);
          &#125;
        &#125;,
        duration ? duration : 15
      );
    &#125;
  &lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h2 id="移动端特效"><a href="#移动端特效" class="headerlink" title="移动端特效"></a>移动端特效</h2><h3 id="1-触屏事件"><a href="#1-触屏事件" class="headerlink" title="1.触屏事件"></a>1.触屏事件</h3><h4 id="1-1-触屏事件概述"><a href="#1-1-触屏事件概述" class="headerlink" title="1.1 触屏事件概述"></a>1.1 触屏事件概述</h4><p>移动端浏览器兼容性较好，我们不需要考虑以前 JS 的兼容性问题，可以放心的使用原生 JS 书写效果，但是移动端也有自己独特的地方。比如<code>触屏事件touch(也称触摸事件)</code>，Android 和 IOS 都有。</p>
<p><code>touch对象</code>代表一个触摸点。触摸点可能是一根手指，也可能是一根触摸笔。触屏事件可响应用户手指(或触控笔)对屏幕或者触控板操作。</p>
<p>常见的触摸事件有:</p>
<table>
<thead>
<tr>
<th>触屏 touch 事件</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>touchstart</td>
<td>手指触摸到一个 DOM 元素时触发</td>
</tr>
<tr>
<td>touchmove</td>
<td>手指在一个 DOM 元素上滑动时触发</td>
</tr>
<tr>
<td>touchend</td>
<td>手指从一个 DOM 元素上移开时触发</td>
</tr>
</tbody></table>
<h4 id="1-2-触摸事件对象-TouchEvent"><a href="#1-2-触摸事件对象-TouchEvent" class="headerlink" title="1.2 触摸事件对象(TouchEvent)"></a>1.2 触摸事件对象(TouchEvent)</h4><ul>
<li>TouchEvent 是一类描述手指在触摸平面(触摸屏、触摸板等)的状态变化的事件。这类事件用于描述一个或多个触点，使开发者可以检测触点的移动，触点的增加和减少，等等</li>
<li><code>touchstart、touchmove、touchend</code> 三个事件都会各自有事件对象。</li>
</ul>
<p>触摸事件对象重点我们看三个常见对象列表:</p>
<table>
<thead>
<tr>
<th>触摸列表</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>touches</td>
<td>正在触摸屏幕的所有手指的一个列表</td>
</tr>
<tr>
<td>targetTouches</td>
<td>正在触摸当前 DOM 元素上的手指的一个列表</td>
</tr>
<tr>
<td>changedTouches</td>
<td>手指状态发生了改变的列表，<code>从无到有，从有到无变化</code></td>
</tr>
</tbody></table>
<ul>
<li>当我们手指离开屏幕的时候，就没有了<strong>touches 和 targetTouches 列表</strong>,但是会有 <code>changedTouches</code> (从有到无)</li>
</ul>
<h4 id="1-3-移动端拖动事件"><a href="#1-3-移动端拖动事件" class="headerlink" title="1.3 移动端拖动事件"></a>1.3 移动端拖动事件</h4><ol>
<li><p>touchstart、touchmove、touchend 可以实现拖动元素</p>
</li>
<li><p>但是拖动元素需要当前手指的坐标值我们可以使用 targetTouches[0] 里面的 pageX 和 pageY</p>
</li>
<li><p>移动端拖动的原理:手指移动中，计算出手指移动的距离。然后用盒子原来的位置 + 手指移动的距离</p>
</li>
<li><p>手指移动的距离:手指滑动中的位置减去手指刚开始触摸的位置拖动元素三步曲:<br>(1) 触摸元素 touchstart: 获取手指初始坐标，同时获得盒子原来的位置</p>
<p>(2) 移动手指 touchmove: 计算手指的滑动距离，并且移动盒子</p>
<p>(3) 离开手指 touchend:</p>
</li>
</ol>
<p><code>注意:手指移动也会触发滚动屏幕所以这里要阻止默认的屏幕滚动e.preventDefault();</code></p>
<pre><code class="javascript">var startX, startY, x, y;
var div = document.querySelector(&quot;div&quot;);
div.addEventListener(&quot;touchstart&quot;, function (event) &#123;
  console.log(&quot;touchstart&quot; + event.targetTouches[0].pageX);
  event.preventDefault();
  startX = event.targetTouches[0].pageX;
  startY = event.targetTouches[0].pageY;
  x = div.offsetLeft;
  y = div.offsetTop;
&#125;);
div.addEventListener(&quot;touchmove&quot;, function (event) &#123;
  console.log(event.targetTouches[0].pageX);
  event.preventDefault();
  var moveX = event.targetTouches[0].pageX - startX;
  var moveY = event.targetTouches[0].pageY - startY;
  div.style.left = x + moveX + &quot;px&quot;;
  div.style.top = y + moveY + &quot;px&quot;;
&#125;);
</code></pre>
<h3 id="2-移动端轮播图"><a href="#2-移动端轮播图" class="headerlink" title="2.移动端轮播图"></a>2.移动端轮播图</h3><pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;../综合案例/携程移动端/css/normalize.css&quot; /&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;../综合案例/携程移动端/css/index.css&quot; /&gt;
    &lt;title&gt;携程在手，说走就走&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;!-- 焦点图模块 --&gt;
    &lt;div class=&quot;focus&quot;&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;img src=&quot;../综合案例/携程移动端/upload/focus.jpg&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
        &lt;li&gt;&lt;img src=&quot;../综合案例/携程移动端/upload/focus.jpg&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
        &lt;li&gt;&lt;img src=&quot;../综合案例/携程移动端/upload/focus.jpg&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
        &lt;li&gt;&lt;img src=&quot;../综合案例/携程移动端/upload/focus.jpg&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
        &lt;li&gt;&lt;img src=&quot;../综合案例/携程移动端/upload/focus.jpg&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;!-- 小圆点 --&gt;
      &lt;ol&gt;
        &lt;li class=&quot;current&quot;&gt;&lt;/li&gt;
        &lt;li&gt;&lt;/li&gt;
        &lt;li&gt;&lt;/li&gt;
      &lt;/ol&gt;
    &lt;/div&gt;
  &lt;/body&gt;
  &lt;script&gt;
    // 移动端轮播
    // 移动端轮播
    window.addEventListener(&quot;load&quot;, function () &#123;
      // 获取元素
      var focus = document.querySelector(&quot;.focus&quot;);
      var ul = focus.children[0];
      var ol = focus.querySelector(&quot;ol&quot;);
      // 获得focus的宽度
      var w = focus.offsetWidth;
      // 利用定时器
      var index = 0;
      var timer = setInterval(function () &#123;
        index++;
        // 切换样式
        ul.style.transition = &quot;transform 0.5s ease&quot;;
        ul.style.transform = &quot;translateX(&quot; + -w * index + &quot;px)&quot;;
      &#125;, 2000);

      // 等着过渡完成
      ul.addEventListener(&quot;transitionend&quot;, function () &#123;
        // 无缝切换
        if (index &gt;= 3) &#123;
          index = 0;
          ul.style.transition = &quot;none&quot;;
          ul.style.transform = &quot;translateX(&quot; + -w * index + &quot;px)&quot;;
        &#125; else if (index &lt; 0) &#123;
          index = 2;
          ul.style.transition = &quot;none&quot;;
          ul.style.transform = &quot;translateX(&quot; + -w * index + &quot;px)&quot;;
        &#125;
        // 小圆点切换
        ol.querySelector(&quot;.current&quot;).classList.remove(&quot;current&quot;);
        ol.children[index].classList.add(&quot;current&quot;);
      &#125;);

      // 手机滑动轮播
      var startX = 0;
      var moveX = 0;
      var flag = false;
      ul.addEventListener(&quot;touchstart&quot;, function (e) &#123;
        startX = e.targetTouches[0].pageX;
        clearInterval(timer); // 停止定时器
      &#125;);

      ul.addEventListener(&quot;touchmove&quot;, function (e) &#123;
        // e.preventDefault();
        // 计算移动距离
        moveX = e.targetTouches[0].pageX - startX;
        // 移动盒子
        ul.style.transition = &quot;none&quot;; // 禁止transition动画
        ul.style.transform = &quot;translateX(&quot; + (-w * index + moveX) + &quot;px)&quot;;
        flag = true; // 标记移动状态
      &#125;);

      ul.addEventListener(&quot;touchend&quot;, function (e) &#123;
        if (flag) &#123;
          // 根据滑动距离决定是切换到上一张还是下一张
          if (Math.abs(moveX) &gt; 50) &#123;
            if (moveX &gt; 0) &#123;
              index--;
            &#125; else &#123;
              index++;
            &#125;
            var translatex = -index * w;
            ul.style.transition = &quot;all .3s&quot;;
            ul.style.transform = &quot;translateX(&quot; + translatex + &quot;px)&quot;;
          &#125; else &#123;
            // 小于50px回弹效果
            var translatex = -index * w;
            ul.style.transform = &quot;translateX(&quot; + translatex + &quot;px)&quot;;
          &#125;
          // 手指离开后重新启动定时器
          clearInterval(timer);
        &#125;
      &#125;);
    &#125;);
  &lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h3 id="3-返回顶部效果"><a href="#3-返回顶部效果" class="headerlink" title="3.返回顶部效果"></a>3.返回顶部效果</h3><pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;zh&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
    &lt;title&gt;返回顶部示例&lt;/title&gt;
    &lt;style&gt;
      body &#123;
        font-family: Arial, sans-serif;
        line-height: 1.6;
      &#125;

      .content &#123;
        height: 2000px; /* 使页面足够长以便测试滚动 */
        padding: 20px;
      &#125;

      .goBack &#123;
        position: fixed;
        bottom: 20px;
        right: 20px;
        width: 50px;
        height: 50px;
        background-color: skyblue;
        color: white;
        border: none;
        border-radius: 25px;
        display: none; /* 初始状态隐藏 */
        justify-content: center;
        align-items: center;
        cursor: pointer;
        font-size: 24px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        z-index: 1000; /* 确保按钮在最上层 */
      &#125;

      .goBack.show &#123;
        z-index: 1000; /* 确保按钮在最上层 */
        display: flex; /* 显示按钮 */
      &#125;
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div class=&quot;content&quot;&gt;
      &lt;h1&gt;这是一个返回顶部示例&lt;/h1&gt;
      &lt;p&gt;这里是一些内容...&lt;/p&gt;
      &lt;p&gt;内容很多...&lt;/p&gt;
      &lt;p&gt;更多内容...&lt;/p&gt;
      &lt;p&gt;甚至更多内容...&lt;/p&gt;
      &lt;p&gt;继续添加内容以便滚动...&lt;/p&gt;
      &lt;p&gt;更多...&lt;/p&gt;
    &lt;/div&gt;

    &lt;div class=&quot;goBack&quot; id=&quot;goBack&quot;&gt;↑&lt;/div&gt;

    &lt;script&gt;
      window.onscroll = function () &#123;
        const goBackButton = document.getElementById(&quot;goBack&quot;);

        if (
          document.body.scrollTop &gt; 100 ||
          document.documentElement.scrollTop &gt; 100
        ) &#123;
          goBackButton.classList.add(&quot;show&quot;);
        &#125; else &#123;
          goBackButton.classList.remove(&quot;show&quot;);
        &#125;
      &#125;;

      document.getElementById(&quot;goBack&quot;).onclick = function () &#123;
        window.scrollTo(&#123;
          top: 0,
          behavior: &quot;smooth&quot;, // 平滑滚动
        &#125;);
      &#125;;
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="4-移动端-click-延时处理"><a href="#4-移动端-click-延时处理" class="headerlink" title="4.移动端 click 延时处理"></a>4.移动端 click 延时处理</h3><p>移动端 click 事件会有 300ms 的延时，原因是移动端屏幕双击会缩放(double tap to zoom) 页面。</p>
<p>解决方案:</p>
<ol>
<li>禁用缩放。浏览器禁用默认的双击缩放行为并且去掉 300ms 的点击延迟</li>
</ol>
<pre><code class="html">&lt;meta name=&quot;viewport&quot; content=&quot;user-scalable=no&quot; /&gt;
</code></pre>
<ol start="2">
<li>利用 touch 事件自己封装这个事件解决 300ms 延迟,</li>
</ol>
<p>原理就是: 1.当我们手指触摸屏幕，记录当前触摸时间 2.当我们手指离开屏幕，用离开的时间减去触摸的时间 3.如果时间小于 150ms，并且没有滑动过屏幕，那么我们就定义为点击</p>
<pre><code class="javascript">// 封装tap，解决click 300ms 延时
function tap(obj, callback) &#123;
  var isMove = false;
  var startTime = 0; // 记录触摸时候的时间变量

  obj.addEventListener(&quot;touchstart&quot;, function (e) &#123;
    isMove = false; // 重置移动状态
    startTime = Date.now(); // 记录触摸时间
  &#125;);

  obj.addEventListener(&quot;touchmove&quot;, function (e) &#123;
    isMove = true; // 如果有滑动，标记为拖拽
  &#125;);

  obj.addEventListener(&quot;touchend&quot;, function (e) &#123;
    if (!isMove &amp;&amp; Date.now() - startTime &lt; 150) &#123;
      // 手指触摸和离开时间小于150ms
      callback &amp;&amp; callback(); // 执行回调函数
    &#125;

    // 重置状态
    isMove = false;
    startTime = 0;
  &#125;);
&#125;

// 调用示例
var div = document.getElementById(&quot;myDiv&quot;); // 假设你有一个id为myDiv的元素
tap(div, function () &#123;
  console.log(&quot;Tapped!&quot;); // 执行识别代码
&#125;);
</code></pre>
<ol start="3">
<li>使用插件。<code>fastclick</code> 插件解决 300ms 延迟。</li>
</ol>
<h3 id="5-移动端常用开发插件"><a href="#5-移动端常用开发插件" class="headerlink" title="5.移动端常用开发插件"></a>5.移动端常用开发插件</h3><h4 id="5-1-什么是插件"><a href="#5-1-什么是插件" class="headerlink" title="5.1 什么是插件"></a>5.1 什么是插件</h4><p>移动端要求的是快速开发，所以我们经常会借助于一些插件来帮我完成操作，那么什么是插件呢?</p>
<p>插件是 javascript 文件，它遵循一定规范编写，方便程序展示效果,拥有特定功能且方便调用。如轮播图和瀑布流插件。</p>
<p>特点:它一般是为了解决某个问题而专门存在，其功能单一，并且比较小。</p>
<ul>
<li>fastclick 插件解决 300ms 延迟。使用延时 GitHub 官网地址:<a target="_blank" rel="noopener" href="https://github.com/ftlabs/fastclick">https://github.com/ftlabs/fastclick</a></li>
</ul>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;script src=&quot;../插件/fastclick.js&quot;&gt;&lt;/script&gt;
    &lt;style&gt;
      div &#123;
        width: 100px;
        height: 100px;
        background-color: red;
      &#125;
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div&gt;&lt;/div&gt;
    &lt;script&gt;
      if (&quot;addEventListener&quot; in document) &#123;
        document.addEventListener(
          &quot;DOMContentLoaded&quot;,
          function () &#123;
            FastClick.attach(document.body);
          &#125;,
          false
        );
      &#125;
      var div = document.querySelector(&quot;div&quot;);
      div.addEventListener(&quot;click&quot;, function () &#123;
        alert(&quot;div被点击了&quot;);
      &#125;);
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h4 id="5-2-Swiper-插件的使用"><a href="#5-2-Swiper-插件的使用" class="headerlink" title="5.2 Swiper 插件的使用"></a>5.2 Swiper 插件的使用</h4><p>中文官网地址: <a target="_blank" rel="noopener" href="https://www.swiper.com.cn/">https://www.swiper.com.cn/</a></p>
<ol>
<li>引入插件相关文件。</li>
<li>按照规定语法使用</li>
</ol>
<h4 id="5-3-其他插件"><a href="#5-3-其他插件" class="headerlink" title="5.3 其他插件"></a>5.3 其他插件</h4><ul>
<li>superslide: <a target="_blank" rel="noopener" href="http://www.superslide2.com/">http://www.superslide2.com/</a></li>
<li>iscroll: <a target="_blank" rel="noopener" href="https://github.com/cubiq/iscroll">https://github.com/cubiq/iscroll</a></li>
</ul>
<h4 id="5-4-练习-移动端视频插件-zy-media-js"><a href="#5-4-练习-移动端视频插件-zy-media-js" class="headerlink" title="5.4 练习-移动端视频插件 zy.media.js"></a>5.4 练习-移动端视频插件 zy.media.js</h4><p>H5 给我们提供了 video 标签，但是浏览器的支持情况不同。</p>
<p>不同的视频格式文件，我们可以通过 source 解决;</p>
<p>但是外观样式，还有暂停，播放，全屏等功能我们只能自己写代码解决,这个时候我们可以使用插件方式来制作。</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;link
      rel=&quot;stylesheet&quot;
      href=&quot;../src/插件/zy.media.js/examples/zy.media.min.css&quot;
    /&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div class=&quot;zy_media&quot;&gt;
      &lt;video data-config=&#39;&#123;&quot;mediaTitle&quot;: &quot;小米宣传片&quot;&#125;&#39;&gt;
        &lt;source
          src=&quot;../html5和css3提高/opening_idea_movie_final.mp4&quot;
          type=&quot;video/mp4&quot;
        /&gt;
        您的浏览器不支持HTML5视频
      &lt;/video&gt;
      &lt;script src=&quot;../src/插件/zy.media.js/zy.media.js&quot;&gt;&lt;/script&gt;
      &lt;script&gt;
        zymedia(&quot;video&quot;);
      &lt;/script&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="6-移动端常用开发框架"><a href="#6-移动端常用开发框架" class="headerlink" title="6. 移动端常用开发框架"></a>6. 移动端常用开发框架</h3><h4 id="6-1-框架概述"><a href="#6-1-框架概述" class="headerlink" title="6.1 框架概述"></a>6.1 框架概述</h4><p>框架，顾名思义就是一套架构，它会基于自身的特点向用户提供一套较为完整的解决方案。</p>
<p>框架的控制权在框架本身，使用者要按照框架所规定的某种规范进行开发。</p>
<p>插件一般是为了解决某个问题而专门存在，其功能单一，并且比较小。</p>
<ul>
<li><p>前端常用的框架有 Bootstrap、Vue、Angular、React 等。既能开发 PC 端，也能开发移动端</p>
</li>
<li><p>前端常用的移动端插件有 swiper、superslide、iscroll 等</p>
<p><strong>区别</strong></p>
</li>
<li><p>框架:大而全，一整套解决方案</p>
</li>
<li><p>插件:小而专一，某个功能的解决方案</p>
</li>
</ul>
<h4 id="6-2-Bootstrap"><a href="#6-2-Bootstrap" class="headerlink" title="6.2 Bootstrap"></a>6.2 Bootstrap</h4><ul>
<li>Bootstrap 是一个简洁、直观、强悍的前端开发框架，它让 web 开发更迅速、简单。<br>它能开发 PC 端，也能开发移动端</li>
<li>BootstrapJS 插件使用步骤:<ol>
<li>引入相关 对应 <code>版本javascipt</code> 文件</li>
<li>复制 HTML 结构(在对应版本的官方文档里<a target="_blank" rel="noopener" href="https://v4.bootcss.com/docs/components/carousel/">Bootstrap v4 中文文档 v4.6</a>)</li>
<li>修改对应 CSS 样式</li>
<li>修改相应 JS 参数</li>
</ol>
</li>
</ul>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;meta
      name=&quot;viewport&quot;
      content=&quot;width=device-width, user-scalable=no, initial-scale=1.0&quot;
    /&gt;
    &lt;title&gt;Bootstrap轮播图插件&lt;/title&gt;
    &lt;link
      rel=&quot;stylesheet&quot;
      href=&quot;../src/插件/bootstrap-4.6.2/dist/css/bootstrap.min.css&quot;
    /&gt;
    &lt;script src=&quot;../src/插件/jquery/jquery3.7.1_slim.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;../src/插件/bootstrap-4.6.2/dist/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;
    &lt;style&gt;
      .facous &#123;
        width: 800px;
        height: 300px;
        background-color: pink;
        margin: 100px auto;
      &#125;
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div class=&quot;facous&quot;&gt;
      &lt;div
        id=&quot;carouselExampleControls&quot;
        class=&quot;carousel slide&quot;
        data-ride=&quot;carousel&quot;
      &gt;
        &lt;div class=&quot;carousel-inner&quot;&gt;
          &lt;div class=&quot;carousel-item active&quot;&gt;
            &lt;img src=&quot;../src/bear.png&quot; class=&quot;d-block w-100&quot; alt=&quot;...&quot; /&gt;
          &lt;/div&gt;
          &lt;div class=&quot;carousel-item&quot;&gt;
            &lt;img src=&quot;../src/bear.png&quot; class=&quot;d-block w-100&quot; alt=&quot;...&quot; /&gt;
          &lt;/div&gt;
          &lt;div class=&quot;carousel-item&quot;&gt;
            &lt;img src=&quot;../src/bear.png&quot; class=&quot;d-block w-100&quot; alt=&quot;...&quot; /&gt;
          &lt;/div&gt;
        &lt;/div&gt;
        &lt;button
          class=&quot;carousel-control-prev&quot;
          type=&quot;button&quot;
          data-target=&quot;#carouselExampleControls&quot;
          data-slide=&quot;prev&quot;
        &gt;
          &lt;span class=&quot;carousel-control-prev-icon&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt;
          &lt;span class=&quot;sr-only&quot;&gt;Previous&lt;/span&gt;
        &lt;/button&gt;
        &lt;button
          class=&quot;carousel-control-next&quot;
          type=&quot;button&quot;
          data-target=&quot;#carouselExampleControls&quot;
          data-slide=&quot;next&quot;
        &gt;
          &lt;span class=&quot;carousel-control-next-icon&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt;
          &lt;span class=&quot;sr-only&quot;&gt;Next&lt;/span&gt;
        &lt;/button&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="本地储存"><a href="#本地储存" class="headerlink" title="本地储存"></a>本地储存</h3><h4 id="target"><a href="#target" class="headerlink" title="target"></a>target</h4><ul>
<li>能够写出 sessionStorage 数据的存储以及获取</li>
<li>能够写出 localStorage 数据的存储以及获取</li>
<li>能够说出它们两者的区别</li>
</ul>
<h4 id="1-本地存储"><a href="#1-本地存储" class="headerlink" title="1.本地存储"></a>1.本地存储</h4><p>随着互联网的快速发展，基于网页的应用越来越普遍，同时也变的越来越复杂，为了满足各种各样的需求，会经常性在本地存储大量的数据，HTML5规范提出了相关解决方案。</p>
<p>本地存储特性</p>
<p>1、数据存储在用户浏览器中</p>
<p>2、设置、读取方便、甚至页面刷新不丢失数据</p>
<p>3、容量较大，<code>sessionStorage</code>约5M、<code>localStorage</code>约20M</p>
<p>4、只能存储字符串，可以将对象<code>JSON.stringify()</code>编码后存储</p>
<h4 id="2-window-sessionStorage"><a href="#2-window-sessionStorage" class="headerlink" title="2.window.sessionStorage"></a>2.window.sessionStorage</h4><ol>
<li>生命周期为关闭浏览器窗口</li>
<li>在同一个窗口(页面)下数据可以共享</li>
<li>以键值对的形式存储使用</li>
</ol>
<p><strong>存储数据:</strong></p>
<pre><code class="javascript">sessionStorage.setItem(key, value);
</code></pre>
<p><strong>获取数据:</strong></p>
<pre><code class="javascript">sessionStorage.getItem(key);
</code></pre>
<p><strong>删除数据:</strong></p>
<pre><code class="javascript">sessionStorage.removeItem(key);
</code></pre>
<p><strong>删除所有数据:</strong></p>
<pre><code class="javascript">sessionStorage.clear();
</code></pre>
<h4 id="3-window-localStorage"><a href="#3-window-localStorage" class="headerlink" title="3.window.localStorage"></a>3.window.localStorage</h4><ol>
<li>生命周期永久生效，除非手动删除否则关闭页面也会存在</li>
<li>可以多窗口(页面)共享(同一浏览器可以共享)</li>
<li>以键值对的形式存储使用</li>
</ol>
<p>存储数据:</p>
<pre><code class="javascript">localStorage.setItem(key,value);
</code></pre>
<p>获取数据:</p>
<pre><code class="javascript">localStorage.getItem(key);
</code></pre>
<p>删除数据:</p>
<pre><code class="javascript">localStorage.removeItem(key);
</code></pre>
<p>删除全部数据:</p>
<pre><code class="javascript">localStorage.clear();
</code></pre>
<h4 id="4-记住用户名案例"><a href="#4-记住用户名案例" class="headerlink" title="4. 记住用户名案例"></a>4. 记住用户名案例</h4><p>如果勾选记住用户名，下次用户打开浏览器，就在文本框里面自动显示上次登录的用户名</p>
<ol>
<li>把数据存起来，用到本地存储</li>
<li>关闭页面，也可以显示用户名，所以用到localStorage</li>
<li>打开页面，先判断是否有这个用户名，如果有，就在表单里面显示用户名,并且勾选复选框</li>
</ol>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot; /&gt;
        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
        &lt;title&gt;记住用户名案例&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;input type=&quot;text&quot; id=&quot;username&quot; /&gt;
        &lt;input type=&quot;checkbox&quot; id=&quot;remember&quot; /&gt; 记住用户名
        &lt;script&gt;
            var username = document.querySelector(&quot;#username&quot;);
            var remember = document.querySelector(&quot;#remember&quot;);
            if (localStorage.getItem(&quot;username&quot;)) &#123;
                username.value = localStorage.getItem(&quot;username&quot;);
                remember.checked = true;
            &#125;
            remember.addEventListener(&quot;change&quot;, function () &#123;
                if (remember.checked) &#123;
                    localStorage.setItem(&quot;username&quot;, username.value);
                &#125; else &#123;
                    localStorage.removeItem(&quot;username&quot;);
                &#125;
            &#125;);
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="JQuery"><a href="#JQuery" class="headerlink" title="JQuery"></a>JQuery</h2><h3 id="1-jQuery概述"><a href="#1-jQuery概述" class="headerlink" title="1.jQuery概述"></a>1.jQuery概述</h3><h4 id="1-1-JavaScript库"><a href="#1-1-JavaScript库" class="headerlink" title="1.1 JavaScript库"></a>1.1 JavaScript库</h4><p>仓库: 可以把很多东西放到这个仓库里面。找东西只需要到仓库里面查找到就可以了</p>
<p>JavaScript库:即<code>library</code>,是一个封装好的特定的集合(方法和函数)。从封装一大堆函数的角度理解库，就是在这个库中，封装了很多预先定义好的函数在里面，比如动画animate、hide、show，比如获取元素等</p>
<p>比如jQuery，就是为了快速方便的操作<code>DOM</code>，里面基本都是<code>函数(方法)。</code></p>
<h4 id="1-2-jQuery的概念"><a href="#1-2-jQuery的概念" class="headerlink" title="1.2 jQuery的概念"></a>1.2 jQuery的概念</h4><p>jQuery 是一个快速、简洁的 JavaScript 库，其设计的宗旨是 **”write Less,Do More”**，即倡导写更少的代码做更多的事情。</p>
<p>jQuery 封装了JavaScript常用的功能代码,<code>优化了 DOM 操作、事件处理、动画设计和 Ajax交互</code></p>
<ul>
<li><strong>jQuery 的优点</strong><ul>
<li>轻量级。核心文件才几十kb，不会影响页面加载速度</li>
<li>跨浏览器兼容。基本兼容了现在主流的浏览器</li>
<li>链式编程、隐式迭代</li>
<li>对事件、样式、动画支持，大大简化了DOM操作</li>
<li>支持插件扩展开发。有着丰富的第三方的插件</li>
<li>例如:树形菜单、日期控件、轮播图等</li>
<li>免费、开源</li>
</ul>
</li>
</ul>
<h3 id="2-jQuery的基本使用"><a href="#2-jQuery的基本使用" class="headerlink" title="2.jQuery的基本使用"></a>2.jQuery的基本使用</h3><h4 id="2-1-jQuery-的下载"><a href="#2-1-jQuery-的下载" class="headerlink" title="2.1 jQuery 的下载"></a>2.1 jQuery 的下载</h4><p>官网地址:<a target="_blank" rel="noopener" href="https://jquery.com/">https://jquery.com/</a></p>
<p><a target="_blank" rel="noopener" href="https://code.jquery.com/jquery-3.5.1.min.js">code.jquery.com&#x2F;jquery-3.5.1.min.js</a></p>
<p>版本</p>
<ul>
<li>1x: 兼容IE 678等低版本浏览器，官网不再更新</li>
<li>2x: 不兼容IE 678等低版本浏览器，官网不再更新</li>
<li>3x: 不兼容IE 678等低版本浏览器，是官方主要更新维护的版本</li>
</ul>
<h4 id="2-2-jQuery-的入口函数"><a href="#2-2-jQuery-的入口函数" class="headerlink" title="2.2 jQuery 的入口函数"></a>2.2 jQuery 的入口函数</h4><pre><code class="javascript">$(function ()&#123;
    //此处是页面 DOM 加载完成的入口
&#125;);

$(document).ready(function()&#123;
    //此处是页面DOM加载完成的入口
&#125;);
</code></pre>
<ol>
<li>等着 DOM 结构渲染完毕即可执行内部代码，不必等到所有外部资源加载完成，jQuery 帮我们完成了封装。</li>
<li>相当于原生 javascript 中的<code>DOMContentLoaded</code>。</li>
</ol>
<h4 id="2-4-jQuery-的顶级对象"><a href="#2-4-jQuery-的顶级对象" class="headerlink" title="2.4 jQuery 的顶级对象$"></a>2.4 jQuery 的顶级对象$</h4><ol>
<li><code>$</code>是jQuery的别称，在代码中可以使用jQuery代替<code>$</code>,但一般为了方便,通常都直接使用<code>$</code>。</li>
<li><code>$</code>是jQuery的顶级对象，相当于原生JavaScript中的window。把元素利用<code>$</code>包装成jQuery对象，就可以调用jQuery的方法。</li>
</ol>
<h4 id="2-5-jQuery-对象和-DOM-对象"><a href="#2-5-jQuery-对象和-DOM-对象" class="headerlink" title="2.5 jQuery 对象和 DOM 对象"></a>2.5 jQuery 对象和 DOM 对象</h4><ol>
<li>用原生 JS 获取来的对象就是 DOM 对象</li>
<li>jQuery方法获取的元素就是jQuery对象。</li>
<li><code>jQuery 对象只能使用 jQuery 方法，DOM 对象则使用原生的 Javascirpt 属性和方法</code></li>
</ol>
<p><strong>DOM 对象与jQuery对象之间是可以相互转换的。</strong></p>
<p>因为原生 js 比 jQuery 更大，原生的一些属性和方法jQuery没有给我们封装.要想使用这些属性和方法需要把jQuery对象转换为DOM对象才能使用。</p>
<ol>
<li>DOM 对象转换为jQuery对象:<code>$(DOM对象)</code></li>
<li>jQuery对象转换为 DOM 对象(两种方式)</li>
</ol>
<pre><code class="javascript">$(&#39;div&#39;)[index]
// index是索引号
$(&#39;div&#39;),get(index)
</code></pre>
<h3 id="3-jQuery的选择器"><a href="#3-jQuery的选择器" class="headerlink" title="3.jQuery的选择器"></a>3.jQuery的选择器</h3><h4 id="3-1-jQuery的基础选择器"><a href="#3-1-jQuery的基础选择器" class="headerlink" title="3.1 jQuery的基础选择器"></a>3.1 jQuery的基础选择器</h4><p>原生JS获取元素方式很多，很杂，而且兼容性情况不一致，因此jQuery给我们做了封装，使获取元素统一标准。</p>
<pre><code class="javascript">$(&quot;选择器&quot;) //里面选择器直接写CSS选择器即可，但是要加引号
</code></pre>
<table>
<thead>
<tr>
<th>名称</th>
<th>用法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ID选择器</td>
<td>$(“#id”)</td>
<td>获取指定ID的元素</td>
</tr>
<tr>
<td>全选选择器</td>
<td>$(“*”)</td>
<td>匹配所有元素</td>
</tr>
<tr>
<td>类选择器</td>
<td>$(“.class”)</td>
<td>获取同一类class的元素</td>
</tr>
<tr>
<td>标签选择器</td>
<td>$(“div”)</td>
<td>获取同一类标签的所有元素</td>
</tr>
<tr>
<td>并集选择器</td>
<td>$(“div,p,li”)</td>
<td>选取多个元素</td>
</tr>
<tr>
<td>交集选择器</td>
<td>$(“li.current”)</td>
<td>交集元素</td>
</tr>
</tbody></table>
<h4 id="3-2-层级选择器"><a href="#3-2-层级选择器" class="headerlink" title="3.2 层级选择器"></a>3.2 层级选择器</h4><table>
<thead>
<tr>
<th>名称</th>
<th>用法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>子代选择器</td>
<td>$(“ul&gt;li”)</td>
<td>使用&gt;号，获取亲儿子层级的元素；注意，并不会获取孙子层级的元素</td>
</tr>
<tr>
<td>后代选择器</td>
<td>$(“ul li”)</td>
<td>使用空格，代表后代选择器，获取ul下的所有li元素，包括孙子等</td>
</tr>
</tbody></table>
<h4 id="3-3-隐式迭代"><a href="#3-3-隐式迭代" class="headerlink" title="3.3 隐式迭代"></a>3.3 隐式迭代</h4><p>遍历内部DOM元素(伪数组形式存储)的过程就叫做<code>隐式迭代</code>。</p>
<p>简单理解: 给匹配到的所有元素进行循环遍历，执行相应的方法，而不用我们再进行循环，简化我们的操作方便我们调用。 </p>
<h4 id="3-4-jQuery筛选选择器"><a href="#3-4-jQuery筛选选择器" class="headerlink" title="3.4 jQuery筛选选择器"></a>3.4 jQuery筛选选择器</h4><table>
<thead>
<tr>
<th>语法</th>
<th>用法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>:first</td>
<td>$(‘li:first’)</td>
<td>获取第一个li元素</td>
</tr>
<tr>
<td>:last</td>
<td>$(‘li:last’)</td>
<td>获取最后一个li元素</td>
</tr>
<tr>
<td>:eq(index)</td>
<td>$(“li:eq(2)”)</td>
<td>获取到的li元素中，选择索引号为2的元素，索引号index从0开始</td>
</tr>
<tr>
<td>:odd</td>
<td>$(“li:odd”)</td>
<td>获取到的li元素中，选择索引号为奇数的元素</td>
</tr>
<tr>
<td>:even</td>
<td>$(“li:even”)</td>
<td>获取到的li元素中，选择索引号为偶数的元素</td>
</tr>
</tbody></table>
<h4 id="3-5-jQuery筛选方法-重点"><a href="#3-5-jQuery筛选方法-重点" class="headerlink" title="3.5 jQuery筛选方法(重点)"></a>3.5 jQuery筛选方法(重点)</h4><table>
<thead>
<tr>
<th>语法</th>
<th>用法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>parent()</td>
<td>$(“li”).parent();</td>
<td>查找父级</td>
</tr>
<tr>
<td>children(selector)</td>
<td>$(“ul”).children(“li”);</td>
<td>相当于$(“ul&gt;li”)，最近一级（亲儿子）</td>
</tr>
<tr>
<td>find(selector)</td>
<td>$(“ul”).find(“li”);</td>
<td>相当于$(“ul li”)，后代选择器</td>
</tr>
<tr>
<td>siblings(selector)</td>
<td>$(“.first”).siblings(“li”);</td>
<td>查找兄弟节点，不包括自身</td>
</tr>
<tr>
<td>nextAll([expr])</td>
<td>$(“.first”).nextAll()</td>
<td>查找当前元素之后所有的同辈元素</td>
</tr>
<tr>
<td>prevtAll([expr])</td>
<td>$(“.last”).prevAll()</td>
<td>查找当前元素之前所有的同辈元素</td>
</tr>
<tr>
<td>hasClass(class)</td>
<td>$(“div”).hasClass(“protected”)</td>
<td>检查当前的元素是否含有某个特定的类，如果有，则返回true</td>
</tr>
<tr>
<td>eq(index)</td>
<td>$(“li”).eq(2);</td>
<td>相当于<code>$(&quot;li:eq(2)&quot;)</code>,index从0开始</td>
</tr>
</tbody></table>
<h4 id="3-6-jQuery的排他思想"><a href="#3-6-jQuery的排他思想" class="headerlink" title="3.6 jQuery的排他思想"></a>3.6 jQuery的排他思想</h4><p>思路: 利用<code>siblings()</code>筛选方法选出除自身外元素修改为默认样式</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot; /&gt;
        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
        &lt;title&gt;jQuery的排他思想&lt;/title&gt;
        &lt;script src=&quot;https://code.jquery.com/jquery-3.5.1.min.js&quot;&gt;&lt;/script&gt;
    &lt;/head&gt;

    &lt;body&gt;
        &lt;button&gt;按钮&lt;/button&gt;
        &lt;button&gt;按钮&lt;/button&gt;
        &lt;button&gt;按钮&lt;/button&gt;
        &lt;button&gt;按钮&lt;/button&gt;
        &lt;button&gt;按钮&lt;/button&gt;
        &lt;script&gt;
            $(function () &#123;
                $(&quot;button&quot;).click(function () &#123;
                    $(this).css(&quot;background-color&quot;, &quot;red&quot;);
                    // $(&quot;button&quot;).not(this).css(&quot;background-color&quot;, &quot;&quot;);
                    $(this).siblings(&quot;button&quot;).css(&quot;background-color&quot;, &quot;&quot;);
                &#125;);
            &#125;);
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><code>index()方法</code></p>
<pre><code class="javascript">$(&quot;button&quot;).click(function () &#123;
    // index() 方法可以获取当前元素在其同辈元素中的位置索引
    console.log($(this).index());
&#125;);
</code></pre>
<h3 id="4-jQuery样式操作"><a href="#4-jQuery样式操作" class="headerlink" title="4. jQuery样式操作"></a>4. jQuery样式操作</h3><h4 id="4-1-操作CSS方法"><a href="#4-1-操作CSS方法" class="headerlink" title="4.1 操作CSS方法"></a>4.1 操作CSS方法</h4><p>jQuery可以使用css方法来修改简单元素样式;也可以操作类，修改多个样式</p>
<ol>
<li>参数只写属性名，则是返回属性值</li>
</ol>
<pre><code class="javascript">$(this).css(&quot;&#39;color&quot;);
</code></pre>
<ol start="2">
<li>参数是<code>属性名，属性值，逗号分隔</code>，是设置一组样式，属性必须加引号，值如果是数字可以不用跟单位和引号</li>
</ol>
<pre><code class="javascript">$(this).css(&quot;color&quot;, &quot;red&quot;);
</code></pre>
<ol start="3">
<li>参数可以是对象形式，方便设置多组样式。属性名和属性值用冒号隔开，属性可以不用加引号</li>
</ol>
<pre><code class="javascript">$(this).css(&#123;&quot;color&quot;:&quot;white&quot;,&quot;font-size&quot;:&quot;20px&quot;&#125;);
</code></pre>
<h4 id="4-2-设置类样式方法"><a href="#4-2-设置类样式方法" class="headerlink" title="4.2 设置类样式方法"></a>4.2 设置类样式方法</h4><p>作用等同于以前的 classList，可以操作类样式，注意操作类里面的参数不要加点</p>
<ol>
<li>添加类</li>
</ol>
<pre><code class="javascript">$(&quot;div&quot;).addClass(&quot;current&quot;);
</code></pre>
<ol start="2">
<li>删除类</li>
</ol>
<pre><code class="javascript">$(&quot;div&quot;).removeClass(&quot;current&quot;);
</code></pre>
<ol start="3">
<li>切换类</li>
</ol>
<pre><code class="javascript">$(&quot;div&quot;).toggleClass(&quot;current&quot;);
</code></pre>
<h3 id="5-jQuery效果"><a href="#5-jQuery效果" class="headerlink" title="5. jQuery效果"></a>5. jQuery效果</h3><h4 id="5-1-元素的显示和隐藏"><a href="#5-1-元素的显示和隐藏" class="headerlink" title="5.1 元素的显示和隐藏"></a>5.1 元素的显示和隐藏</h4><ol>
<li><p><strong>显示语法规范</strong></p>
<pre><code class="javascript">show([speed,[easing],[fn]])
</code></pre>
</li>
<li><p>显示参数</p>
</li>
</ol>
<ul>
<li><p>参数都可以省略，无动画直接显示。</p>
</li>
<li><p>speed: 三种预定速度之一字符串(“slow”，”normal”,or “fast”)或表示动画时长的毫秒数值(如:1000)</p>
</li>
<li><p>easing: (Optional)用来指定切换效果，默认是 “swing” ，可用参数 “linear”</p>
</li>
<li><p>fn: 回调函数，在动画完成时执行的函数，每个元素执行一次</p>
</li>
</ul>
<ol>
<li><p><strong>隐藏语法规范</strong></p>
<pre><code class="javascript">show([speed,[easing],[fn]])
</code></pre>
</li>
<li><p>隐藏参数</p>
</li>
</ol>
<ul>
<li><p>参数都可以省略，无动画直接显示。</p>
</li>
<li><p>speed: 三种预定速度之一字符串(“slow”，”normal”,or “fast”)或表示动画时长的毫秒数值(如:1000)</p>
</li>
<li><p>easing: (Optional)用来指定切换效果，默认是 “swing” ，可用参数 “linear”</p>
</li>
<li><p>fn: 回调函数，在动画完成时执行的函数，每个元素执行一次</p>
</li>
</ul>
<p><code>切换语法规范</code></p>
<pre><code class="javascript">toggle([speed,[easing],[fn]]);
</code></pre>
<h4 id="5-2-滑动效果"><a href="#5-2-滑动效果" class="headerlink" title="5.2 滑动效果"></a>5.2 滑动效果</h4><ol>
<li><p>滑动切换效果语法规范</p>
<pre><code class="javascript">slideToggle([speed,[easing],[fn]]);
</code></pre>
</li>
<li><p>滑动切换效果参数</p>
<ul>
<li>参数都可以省略。</li>
<li>speed: 三种预定速度之一的字符串(“slow”，”normal”,or “fast”)或表示动画时长的毫秒数值(如:1000)</li>
<li>easing: (Optional)用来指定切换效果，默认是 “swing” 可用参数 “linear”</li>
<li>fn: 回调函数，在动画完成时执行的函数,每个元素执行一次。</li>
</ul>
</li>
</ol>
<h4 id="5-3-事件切换"><a href="#5-3-事件切换" class="headerlink" title="5.3 事件切换"></a>5.3 事件切换</h4><pre><code class="javascript">hover([over,]out)
</code></pre>
<ol>
<li>over:鼠标移到元素上要触发的函数(相当于mouseenter)</li>
<li>out:鼠标移出元素要触发的函数(相当于mouseleave)</li>
</ol>
<p><code>如果只写一个函数,鼠标移入和离开都会触发这个函数</code></p>
<h4 id="5-4-动画队列及其停止排队方法"><a href="#5-4-动画队列及其停止排队方法" class="headerlink" title="5.4 动画队列及其停止排队方法"></a>5.4 动画队列及其停止排队方法</h4><ol>
<li><strong>动画或效果队列</strong></li>
</ol>
<p>动画或者效果一旦触发就会执行，如果多次触发，就造成多个动画或者效果排队执行</p>
<p>2.停止排队</p>
<pre><code class="javascript">stop();
</code></pre>
<ol>
<li>stop()方法用于停止动画或效果,</li>
<li>注意:stop()写到动画或者效果的前面，相当于停止结束上一次的动画。</li>
</ol>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot; /&gt;
        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
        &lt;title&gt;导航栏&lt;/title&gt;
        &lt;script src=&quot;https://code.jquery.com/jquery-3.5.1.min.js&quot;&gt;&lt;/script&gt;
        &lt;style&gt;
            ul &#123;
                list-style: none;
                padding: 0;
            &#125;
            ul li &#123;
                float: left;
                margin-right: 10px;
                position: relative;
            &#125;
            ul li span &#123;
                display: inline-block;
                width: 50px;
                height: 20px;
                margin: 0;
                text-align: center;
            &#125;
            ul li .content &#123;
                display: none;
                width: 100%;
                height: 290px;
                background-color: blue;
                position: absolute;
                top: 100%;
                left: 0;
            &#125;
        &lt;/style&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div class=&quot;box&quot;&gt;
            &lt;ul&gt;
                &lt;li&gt;
                    &lt;span&gt;导航&lt;/span&gt;
                    &lt;div class=&quot;content&quot;&gt;&lt;/div&gt;
                &lt;/li&gt;
                &lt;li&gt;
                    &lt;span&gt;导航&lt;/span&gt;
                    &lt;div class=&quot;content&quot;&gt;&lt;/div&gt;
                &lt;/li&gt;
                &lt;li&gt;
                    &lt;span&gt;导航&lt;/span&gt;
                    &lt;div class=&quot;content&quot;&gt;&lt;/div&gt;
                &lt;/li&gt;
                &lt;li&gt;
                    &lt;span&gt;导航&lt;/span&gt;
                    &lt;div class=&quot;content&quot;&gt;&lt;/div&gt;
                &lt;/li&gt;
                &lt;li&gt;
                    &lt;span&gt;导航&lt;/span&gt;
                    &lt;div class=&quot;content&quot;&gt;&lt;/div&gt;
                &lt;/li&gt;
            &lt;/ul&gt;
        &lt;/div&gt;
        &lt;script&gt;
            $(&quot;ul&gt;li&quot;).hover(function () &#123;
                // 先停止动画
                $(this).children(&quot;.content&quot;).stop().slideToggle();
            &#125;);
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h4 id="5-5-淡入淡出效果"><a href="#5-5-淡入淡出效果" class="headerlink" title="5.5 淡入淡出效果"></a>5.5 淡入淡出效果</h4><ol>
<li>淡入效果语法规范</li>
</ol>
<pre><code class="javascript">fadeIn([speed,[easing],[fn]])
</code></pre>
<ol start="2">
<li>淡入效果参数<ul>
<li>参数都可以省略。</li>
<li>speed:三种预定速度之一的字符串(“slow”，”normal”,or “fast”)或表示动画时长的亳秒数值(如:1000)</li>
<li>easing: (Optional)用来指定切换效果，默认是 “swing” 可用参数 “linear”</li>
<li>fn: 回调函数，在动画完成时执行的函数,每个元素执行一次。</li>
</ul>
</li>
</ol>
<pre><code class="javascript">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
    &lt;title&gt;淡入淡出效果&lt;/title&gt;
    &lt;script src=&quot;https://code.jquery.com/jquery-3.5.1.min.js&quot;&gt;&lt;/script&gt;
    &lt;style&gt;
      div &#123;
        width: 200px;
        height: 200px;
        background-color: red;
      &#125;
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;button&gt;淡入&lt;/button&gt;
    &lt;button&gt;淡出&lt;/button&gt;
    &lt;button&gt;淡入淡出切换&lt;/button&gt;
    &lt;button&gt;修改透明度&lt;/button&gt;
    &lt;div&gt;&lt;/div&gt;
    &lt;script&gt;
      $(function () &#123;&#125;);
      $(&quot;button&quot;)
        .eq(0)
        .click(function () &#123;
          $(&quot;div&quot;).fadeIn();
        &#125;);
      $(&quot;button&quot;)
        .eq(1)
        .click(function () &#123;
          $(&quot;div&quot;).fadeOut();
        &#125;);
      $(&quot;button&quot;)
        .eq(2)
        .click(function () &#123;
          $(&quot;div&quot;).fadeToggle();
        &#125;);
      $(&quot;button&quot;)
        .eq(3)
        .click(function () &#123;
          $(&quot;div&quot;).fadeTo(&quot;slow&quot;, 0.5);
        &#125;);
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h4 id="5-6-自定义动画animate"><a href="#5-6-自定义动画animate" class="headerlink" title="5.6 自定义动画animate"></a>5.6 自定义动画animate</h4><ol>
<li>语法</li>
</ol>
<pre><code class="javascript">animate(params,[speed],[easing],[fn]);
</code></pre>
<ol start="2">
<li>参数<ul>
<li><code>params</code>:<strong>想要更改的样式属性,以<code>对象</code>形式传递，必须写。属性名可以不用带引号，如果是复合属性则需要采取驼峰命名法。</strong>其余参数都可以省略。</li>
<li>speed:三种预定速度之一的字符串(“slow”，”normal”,or “fast”)或表示动画时长的亳秒数值(如:1000)</li>
<li>easing: (Optional)用来指定切换效果，默认是 “swing” 可用参数 “linear”</li>
<li>fn: 回调函数，在动画完成时执行的函数,每个元素执行一次。</li>
</ul>
</li>
</ol>
<pre><code class="javascript">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
    &lt;title&gt;动画效果&lt;/title&gt;
    &lt;script src=&quot;https://code.jquery.com/jquery-3.5.1.min.js&quot;&gt;&lt;/script&gt;
    &lt;style&gt;
      div &#123;
        position: absolute;
        width: 200px;
        height: 200px;
        background-color: blue;
      &#125;
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div&gt;&lt;/div&gt;
    &lt;script&gt;
        // 实现自定义动画
      $(function () &#123;
        $(&quot;div&quot;).click(function () &#123;
          $(this).animate(
            &#123;
              left: &quot;250px&quot;,
              top: &quot;250px&quot;,
              width: &quot;100px&quot;,
              height: &quot;100px&quot;,
              opacity: 0.5,
            &#125;,
            1000
          );
        &#125;);
      &#125;);
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="6-jQuery的属性操作"><a href="#6-jQuery的属性操作" class="headerlink" title="6. jQuery的属性操作"></a>6. jQuery的属性操作</h3><h4 id="6-1-设置或获取元素固有属性值-prop"><a href="#6-1-设置或获取元素固有属性值-prop" class="headerlink" title="6.1 设置或获取元素固有属性值 prop()"></a>6.1 设置或获取元素固有属性值 prop()</h4><p>所谓元素固有属性就是元素本身自带的属性，比如<code>&lt;a&gt;元素里面的 href,比如 &lt;input&gt;元素里面的type</code>。</p>
<ol>
<li>获取属性语法</li>
</ol>
<pre><code class="javascript">prop(&quot;属性&quot;)
</code></pre>
<ol start="2">
<li>设置属性语法</li>
</ol>
<pre><code class="javascript">prop(&quot;属性&quot;，&quot;属性值&quot;)
</code></pre>
<h4 id="6-2-设置或获取元素自定义属性值-attr"><a href="#6-2-设置或获取元素自定义属性值-attr" class="headerlink" title="6.2 设置或获取元素自定义属性值 attr()"></a>6.2 设置或获取元素自定义属性值 attr()</h4><p>用户自己给元素添加的属性，我们称为自定义属性。比如给 div 添加 index&#x3D;“1“</p>
<ol>
<li>获取属性语法</li>
</ol>
<pre><code class="javascript">attr(&quot;属性&quot;)//类似原生 getAttribute()
</code></pre>
<ol start="2">
<li>设置属性语法</li>
</ol>
<pre><code class="javascript">attr(&quot;属性&quot;，&quot;属性值&quot;)//类似原生 setAttribute()
</code></pre>
<h4 id="6-3-数据缓存-data"><a href="#6-3-数据缓存-data" class="headerlink" title="6.3 数据缓存 data()"></a>6.3 数据缓存 data()</h4><p>data()方法可以在指定的元素上存取数据，并不会修改 DOM 元素结构。一旦页面刷新，之前存放的数据都将被移除</p>
<p>1.附加数据语法</p>
<pre><code class="javascript">data(&quot;name&quot;，&quot;value&quot;)// 向被选元素附加数据
</code></pre>
<p>2.获取数据语法</p>
<pre><code class="javascript">date(&quot;name&quot;)// 向被选元素获取数据
</code></pre>
<p>同时，还可以读取 HTML5 自定义属性 data-index，得到的是数字型</p>
<pre><code class="html">&lt;span data-index=&quot;1&quot;&gt;test&lt;/span&gt;

console.log($(&quot;span&quot;).data(&quot;index&quot;)) &lt;- 输出1 -&gt;
</code></pre>
<h3 id="7-jQuery内容文本值"><a href="#7-jQuery内容文本值" class="headerlink" title="7.jQuery内容文本值"></a>7.jQuery内容文本值</h3><p>主要针对元素的内容还有表单的值操作。</p>
<h4 id="7-1-普通元素内容html-相当于原生innerHTML"><a href="#7-1-普通元素内容html-相当于原生innerHTML" class="headerlink" title="7.1 普通元素内容html()(相当于原生innerHTML)"></a>7.1 普通元素内容html()(相当于原生innerHTML)</h4><pre><code class="javascript">html() //获取元素内容
html(&quot;内容&quot;) // 设置元素内容值
</code></pre>
<h4 id="7-2-text-文本内容值"><a href="#7-2-text-文本内容值" class="headerlink" title="7.2 text()文本内容值"></a>7.2 text()文本内容值</h4><pre><code class="javascript">text()
text(&quot;文本内容&quot;)
</code></pre>
<h4 id="7-3-val-表单值"><a href="#7-3-val-表单值" class="headerlink" title="7.3 val()表单值"></a>7.3 val()表单值</h4><pre><code class="javascript">val()
val(&quot;文本内容&quot;)
</code></pre>
<ul>
<li><code>parents()返回所有祖先元素,例如parents(&#39;.father&#39;)返回祖先元素中class属性等于father的元素</code></li>
<li><code>toFixed(2)可以保留指定位小数</code></li>
</ul>
<h3 id="8-jQuery元素操作"><a href="#8-jQuery元素操作" class="headerlink" title="8. jQuery元素操作"></a>8. jQuery元素操作</h3><h4 id="8-1-遍历元素"><a href="#8-1-遍历元素" class="headerlink" title="8.1 遍历元素"></a>8.1 遍历元素</h4><p>jQuery隐式迭代是对同一类元素做了同样的操作。(如果想要给同一类元素做不同操作，就需要用到遍历)</p>
<p><strong>语法1:</strong></p>
<pre><code class="javascript">$(&quot;div&quot;).each(function(index,domEle)&#123; xxx;&#125;)
</code></pre>
<ol>
<li><p>each()方法遍历匹配的每一个元素。主要用DOM处理。each每一个</p>
</li>
<li><p>里面的回调函数有2个参数: <code>index</code> 是每个元素的索引号; <code>demEle</code>是每个DOM元素对象，,不是jQuery对象</p>
</li>
<li><p>所以要想使用jQuery方法，需要给这个DOM元素转换为jQuery对象<code>$(domEle)</code></p>
</li>
</ol>
<p><strong>语法2:</strong></p>
<pre><code class="javascript">$.each(object,function(index,element)&#123; xxx;&#125;)
</code></pre>
<ol>
<li>$.each()方法可用于遍历任何对象。主要用于数据处理，比如<code>数组，对象</code></li>
<li>里面的函数有2个参数: index是每个元素的索引号; element遍历内容</li>
</ol>
<pre><code class="javascript">// each() 方法用于遍历集合中的每个元素，并对每个元素执行一个函数。
var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;purple&quot;];
$(&quot;li&quot;).each(function (index, element) &#123;
    $(this).css(&quot;color&quot;, colors[index]);
    // element是DOM对象,不能使用jQuery方法
&#125;);

// $.each() 方法用于遍历数组或对象，并对每个元素执行一个函数,主要用于数据处理
var arr = [1, 2, 3, 4, 5];
$.each(arr, function (index, value) &#123;
    console.log(index + &quot;:&quot; + value);
&#125;);
</code></pre>
<h4 id="8-2-创建元素"><a href="#8-2-创建元素" class="headerlink" title="8.2 创建元素"></a>8.2 创建元素</h4><pre><code class="javascript">$(&quot;&lt;li&gt;我是新创建的元素&lt;/Ii&gt;&quot;);
// 新创建一个元素
</code></pre>
<h4 id="8-3-添加元素"><a href="#8-3-添加元素" class="headerlink" title="8.3 添加元素"></a>8.3 添加元素</h4><p><strong>1.内部添加</strong></p>
<pre><code class="javascript">element.append(&quot;内容&quot;) // 把内容放入匹配元素内部`最后面`，类似原生appendChild。
element.prepend(&quot;内容&quot;)
</code></pre>
<p><strong>2.外部添加</strong></p>
<pre><code class="javascript">element.after(&quot;内容&quot;)// 把内容放入目标元素后面
element.before(&quot;内容&quot;) // 把内容放入目标元素前面
</code></pre>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">0zxm</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://0zxm.github.io/2024/10/14/javascript-xue-xi/">https://0zxm.github.io/2024/10/14/javascript-xue-xi/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">0zxm</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/JavaScript/">
                                    <span class="chip bg-color">JavaScript</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="far fa-dot-circle"></i>&nbsp;本篇
            </div>
            <div class="card">
                <a href="/2024/10/14/javascript-xue-xi/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/15.jpg" class="responsive-img" alt="JavaScript学习">
                        
                        <span class="card-title">JavaScript学习</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            Javascript学习笔记
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2024-10-14
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%89%8D%E7%AB%AF/" class="post-category">
                                    前端
                                </a>
                            
                            
                        </span>
                    </div>
                </div>

                
                <div class="card-action article-tags">
                    
                    <a href="/tags/JavaScript/">
                        <span class="chip bg-color">JavaScript</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2024/10/11/java-ji-chu-shang/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/14.jpg" class="responsive-img" alt="Java基础上">
                        
                        <span class="card-title">Java基础上</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            Java课程学习
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2024-10-11
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Java/" class="post-category">
                                    Java
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Java/">
                        <span class="chip bg-color">Java</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        font-size: 15px;
        color: #0019ED;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="3177534452"
                   fixed='true'
                   autoplay='false'
                   theme='#0019ED'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2024</span>
            
            <span id="year">2024</span>
            <a href="/about" target="_blank">0zxm</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">448.8k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/0zxm" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:m15813109801@163.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=2378173954" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 2378173954" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

	
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
