<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="0zxm">





<title>Linux指令 | 0zxm</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 7.1.1"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">0zxm&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">0zxm&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">Linux指令</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">0zxm</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">四月 27, 2024&nbsp;&nbsp;22:57:27</a>
                        </span>
                    
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="Linux学习"><a href="#Linux学习" class="headerlink" title="Linux学习"></a>Linux学习</h1><h2 id="第一章-linux基本命令"><a href="#第一章-linux基本命令" class="headerlink" title="第一章 linux基本命令"></a>第一章 linux基本命令</h2><h3 id="期末考试方式"><a href="#期末考试方式" class="headerlink" title="期末考试方式"></a>期末考试方式</h3><p>使用<code>exam</code>命令,输入数字选择选项或题目,答案默认保存,若想修改之前的答案,输入对应题号就行</p>
<h3 id="1-连接到学校主机10-188-2-251的帐号密码"><a href="#1-连接到学校主机10-188-2-251的帐号密码" class="headerlink" title="1.连接到学校主机10.188.2.251的帐号密码"></a>1.连接到学校主机10.188.2.251的帐号密码</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">账号:s223174</span><br><span class="line">密码:welcome</span><br></pre></td></tr></table></figure>

<h3 id="2-nano指令操作文件"><a href="#2-nano指令操作文件" class="headerlink" title="2.nano指令操作文件"></a>2.nano指令操作文件</h3><p>查看和编辑文件</p>
<h3 id="3-环境变量"><a href="#3-环境变量" class="headerlink" title="3.环境变量"></a>3.环境变量</h3><ol>
<li>PATH环境变量: 当shell执行时去哪找可执行文件,依次查找</li>
<li>PS1环境变量: shell命令提示符的样式</li>
<li>LANG环境变量: 与shell交互使用的语言</li>
<li>HOME环境变量: 当前用户工作目录</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">locale -a 指令</span><br><span class="line">列出所有系统安装的语言</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/27/Linux%E6%8C%87%E4%BB%A4/image-20240314232303614.png" alt="image-20240314232303614"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修改PS1环境变量---shell提示符样式</span><br><span class="line">PS1=&#x27;HAPPY: \u $ &#x27;</span><br><span class="line">\u是特殊参数,表示用户名</span><br></pre></td></tr></table></figure>

<p>​	<img src="/2024/04/27/Linux%E6%8C%87%E4%BB%A4/image-20240314232634341.png" alt="image-20240314232634341"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">添加当前目录(.)到PATH变量</span><br><span class="line">注意:PATH变量以冒号分割(:),修改PATH环境变量只对本次生效,想要永久生效,可以修改.profile文件</span><br><span class="line">PATH=$PATH:.</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/27/Linux%E6%8C%87%E4%BB%A4/image-20240314232909211.png" alt="image-20240314232909211"></p>
<h3 id="4-echo命令"><a href="#4-echo命令" class="headerlink" title="4.echo命令"></a>4.echo命令</h3><p>类似于打印命令</p>
<p><img src="/2024/04/27/Linux%E6%8C%87%E4%BB%A4/image-20240314233218047.png" alt="image-20240314233218047"></p>
<h3 id="5-alias命令"><a href="#5-alias命令" class="headerlink" title="5.alias命令"></a>5.alias命令</h3><p>alias可以起别名或者修改命令默认的执方式</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">alias 别名=源名</span><br><span class="line">例子alias list=ls</span><br><span class="line"></span><br><span class="line">alias命令展示所有已取(默认)别名</span><br><span class="line"></span><br><span class="line">unalias取消别名</span><br><span class="line">unalias list</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/27/Linux%E6%8C%87%E4%BB%A4/image-20240314233930938.png" alt="image-20240314233930938"></p>
<h3 id="6-Linux中的源字符"><a href="#6-Linux中的源字符" class="headerlink" title="6.Linux中的源字符"></a>6.Linux中的源字符</h3><ul>
<li>$美元符: 表示取值</li>
<li>双引号: 对引号里面的源字符进行处理</li>
<li>单引号: 不对引号里面的源字符处理</li>
<li>\ 反斜杠: 最常见的转义字符,用于转义其他字符</li>
<li>*字符: 任意字符</li>
<li>?问号: ? 可以用来匹配任意单个字符…命令 <code>ls a?.txt</code> 会列出所有以 <code>a</code> 开头,后面跟着任意单个字符,并且以 <code>.txt</code> 结尾的文件</li>
<li><code>[限制条件]</code>: 限制范围,例如 <code>ls /tmp/[123].tmp</code>(区间写法)等价于 <code>ls /tmp/[1-3].tmp</code>(列举写法),表示取出tmp目录下的所有1到3以<code>tmp</code>为后缀的文件,注意变通</li>
<li>^或者!: 表示否定negative</li>
<li>~字符: 表示工作目录,等价于<code>echo $HOME</code></li>
</ul>
<p><img src="/2024/04/27/Linux%E6%8C%87%E4%BB%A4/image-20240315000305427.png" alt="image-20240315000305427"></p>
<h3 id="7-基本命令"><a href="#7-基本命令" class="headerlink" title="7.基本命令"></a>7.基本命令</h3><ul>
<li><p>clear清屏命令</p>
</li>
<li><p>cp 源文件路径 目的路径</p>
<p>  例: cp hello hi</p>
<p>  <img src="/2024/04/27/Linux%E6%8C%87%E4%BB%A4/image-20240314234136513.png" alt="image-20240314234136513"><br> <img src="/2024/04/27/Linux%E6%8C%87%E4%BB%A4/cp.jpg" alt="alt text"></p>
</li>
<li><p>type xxx命令</p>
<p>  查看指令类型</p>
</li>
</ul>
<p><img src="/2024/04/27/Linux%E6%8C%87%E4%BB%A4/image-20240314234306905.png" alt="image-20240314234306905"></p>
<ul>
<li><p>rm 文件路径</p>
<p>  例: rm hi  (hi文件已经存在)</p>
<p>  <img src="/2024/04/27/Linux%E6%8C%87%E4%BB%A4/image-20240314234422632.png" alt="image-20240314234422632"></p>
</li>
<li><p>ls指令(参数 -l等)</p>
<p>  例: ls -l hello</p>
<ul>
<li><code>-i</code>参数,显示更详细信息</li>
</ul>
<p>  <img src="/2024/04/27/Linux%E6%8C%87%E4%BB%A4/image-20240314234557355.png" alt="image-20240314234557355"></p>
</li>
<li><p>history命令</p>
<p>  显示shell命令的历史记录</p>
<p>  <img src="/2024/04/27/Linux%E6%8C%87%E4%BB%A4/image-20240315000404594.png" alt="image-20240315000404594"></p>
</li>
<li><p>!!直接执行上条命令,!加编号执行history里的第几条记录</p>
<p>  <img src="/2024/04/27/Linux%E6%8C%87%E4%BB%A4/image-20240315000542358.png"></p>
</li>
<li><p><code>su</code> 和 <code>sudo</code>超级用户(管理员)<br><code>su</code> : 把身份切换到超级用户(su之后就切换到root用户,要求输入的是root用户口令)<br><code>su 用户名</code> : 切换到其他用户<br><code>sudo</code> : 以超级用户的身份执行某条命令(sudo要求输入口令时,输入的是当前用户的口令)<br>值得注意的是,只有被指定的用户才能使用sudo命令,在&#x2F;etc&#x2F;sudoers文件里的才被允许<br><img src="/2024/04/27/Linux%E6%8C%87%E4%BB%A4/sudoers.png" alt="alt text"></p>
</li>
<li><p><code>whoami</code>查看当前用户</p>
</li>
<li><p><code>id</code>命令或<code>groups</code>显示所属组</p>
</li>
<li><p><code>hostname</code>查看主机名</p>
<ol>
<li><code>hostname</code></li>
<li><code>hostname 想要修改的主机名</code></li>
</ol>
</li>
<li><p><code>uname</code>查看操作系统内核<br><img src="/2024/04/27/Linux%E6%8C%87%E4%BB%A4/uname.png" alt="alt text"></p>
</li>
<li><p><code>free</code>查看内存<br><code>free -h</code>参数表示human readable 便于人类阅读的<br><img src="/2024/04/27/Linux%E6%8C%87%E4%BB%A4/free.png" alt="alt text"></p>
</li>
<li><p><code>date</code>显示当前系统时间<br><img src="/2024/04/27/Linux%E6%8C%87%E4%BB%A4/date.png" alt="alt text"></p>
</li>
<li><p><code>vi</code>命令查看<code>/proc</code>系统信息文件夹下文件<br>vi &#x2F;proc&#x2F;cpuinfo<br><img src="/2024/04/27/Linux%E6%8C%87%E4%BB%A4/proc.png" alt="alt text"></p>
</li>
<li><p><code>passwd</code>修改口令命令<br>以前存放在&#x2F;etc&#x2F;passwd下,现在存放在&#x2F;etc&#x2F;shadow文件</p>
</li>
<li><p><code>wall</code>广播命令<br>您可以使用<code>wall</code>命令来向所有登录用户发送消息。例如，要发送一句话给所有登录用户，您可以在终端中输入以下命令：</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;这是一条消息&quot; | wall</span><br></pre></td></tr></table></figure>
<p>这将向所有登录用户显示消息“这是一条消息”。请注意，您需要具有适当的权限才能向所有用户发送消息。</p>
<ul>
<li><code>w</code>或<code>who</code>查看所有当前登陆用户<br><img src="/2024/04/27/Linux%E6%8C%87%E4%BB%A4/who.png" alt="alt text"></li>
</ul>
<h3 id="8-shell命令执行的优先级"><a href="#8-shell命令执行的优先级" class="headerlink" title="8.shell命令执行的优先级"></a>8.shell命令执行的优先级</h3><ol>
<li>alias别名</li>
<li>内置命令</li>
<li>可执行文件</li>
</ol>
<h3 id="9-源字符使用实例-第一次小测"><a href="#9-源字符使用实例-第一次小测" class="headerlink" title="9.源字符使用实例(第一次小测)"></a>9.源字符使用实例(第一次小测)</h3><ol>
<li>list files whose name start with a,b or c <ul>
<li>解答 : <code>ls [abc]*</code></li>
</ul>
</li>
<li>list files whose name don’t start with a digit<ul>
<li>解答 : <code>ls [^0-9]*</code></li>
</ul>
</li>
<li>list all files whose names only contains two characters<ul>
<li>解答 : <code>ls ??</code></li>
</ul>
</li>
<li>list all the file whose name contain a $<ul>
<li>解答 : <code>ls *\$*</code></li>
</ul>
</li>
<li>Which file stores the user information?<ul>
<li>解答 : <code>/etc/passwd</code></li>
</ul>
</li>
<li>Which file will be executed once when user login<ul>
<li>解答 : <code>.profile</code>或<code>.bash_login</code></li>
</ul>
</li>
<li>Create an alias called “la” for the command “ls -a”<ul>
<li>解答 : <code>alias la=&#39;ls -a&#39;</code></li>
</ul>
</li>
<li>The names of the directories that a shell searches to find the file corresponding to an external command are stored in the shell variable named<ul>
<li>解答 : <code>PATH</code></li>
</ul>
</li>
</ol>
<h3 id="10-链接命令"><a href="#10-链接命令" class="headerlink" title="10.链接命令"></a>10.链接命令</h3><ol>
<li>软链接<br>类似于Windows下的快捷方式，当一个源文件的目录层级比较深，我们想要方便使用它可以给源文件创建一个软链接,方便文件操作<br><img src="/2024/04/27/Linux%E6%8C%87%E4%BB%A4/link.png" alt="alt text"></li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s 源文件路径 软链接名字</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ln -s</td>
<td>创建软链接</td>
</tr>
</tbody></table>
<h3 id="11-解压缩命令"><a href="#11-解压缩命令" class="headerlink" title="11.解压缩命令"></a>11.解压缩命令</h3><ul>
<li>.gz和.bz2的压缩包需要使用<code>tar</code>命令来压缩和解压缩</li>
<li>不加z参数，就没有压缩，只是打包成一个文件</li>
</ul>
<table>
<thead>
<tr>
<th>压缩格式</th>
<th>说明</th>
<th>压缩包后缀</th>
</tr>
</thead>
<tbody><tr>
<td>bz2</td>
<td>常见的压缩文件格式，由bzip2生成，具有高压缩率</td>
<td>.bz2</td>
</tr>
<tr>
<td>gz</td>
<td>常见的压缩文件格式，由gzip生成，广泛应用于Linux和Unix系统</td>
<td>.gz</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>tar命令选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-c</td>
<td>创建打包文件</td>
</tr>
<tr>
<td>-v</td>
<td>显示打包或者解包的详细信息</td>
</tr>
<tr>
<td>-f</td>
<td>指定文件名称, 必须放到所有选项后面</td>
</tr>
<tr>
<td>-z</td>
<td>压缩(.gz)</td>
</tr>
<tr>
<td>-j</td>
<td>压缩(.bz2)</td>
</tr>
<tr>
<td>-x</td>
<td>解压缩</td>
</tr>
<tr>
<td>-C</td>
<td>解压缩到指定目录</td>
</tr>
</tbody></table>
<h3 id="12-关机和重启命令的使用"><a href="#12-关机和重启命令的使用" class="headerlink" title="12.关机和重启命令的使用"></a>12.关机和重启命令的使用</h3><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>shutdown -h now</code></td>
<td align="center">立刻关机。这个命令会立即关闭系统，并断开所有用户的连接。</td>
</tr>
<tr>
<td align="center"><code>reboot</code></td>
<td align="center">重启。这个命令会重新启动系统，相当于按下计算机的重启按钮。</td>
</tr>
</tbody></table>
<h3 id="13-远程登陆，远程拷贝命令"><a href="#13-远程登陆，远程拷贝命令" class="headerlink" title="13.远程登陆，远程拷贝命令"></a>13.远程登陆，远程拷贝命令</h3><h4 id="13-1-ssh命令的使用"><a href="#13-1-ssh命令的使用" class="headerlink" title="13.1 ssh命令的使用"></a>13.1 ssh命令的使用</h4><p>安装步骤:<br>① 假如Ubuntu作为服务端,需要安装ssh服务端软件,执行命令: sudo apt-get install openssh-server<br>② 客户端电脑如果是macOS系统则不需要安装ssh客户端软件，默认已经安装过了，直接可以使用ssh命令<br>③ 客户端电脑如果是Windows系统则需要安装OpenSSH for Windows这个软件</p>
<h4 id="13-2-scp命令的使用"><a href="#13-2-scp命令的使用" class="headerlink" title="13.2 scp命令的使用"></a>13.2 scp命令的使用</h4><p><code>scp</code> 是基于 SSH 进行安全的远程文件拷贝的命令，也就是说需要保证服务端和客户端电脑安装了相应的 SSH 软件。</p>
<p><strong>scp命令格式:</strong></p>
<ol>
<li><p>远程拷贝文件:</p>
<ul>
<li><code>scp 本地文件 远程服务器用户名@远程服务器ip地址:指定拷贝到远程服务器的路径</code></li>
<li><code>scp 远程服务器用户名@远程服务器ip地址:远程服务器文件 指定拷贝到本地的路径</code></li>
</ul>
</li>
<li><p>远程拷贝目录:</p>
<ul>
<li><code>scp -r 本地目录 远程服务器用户名@远程服务器ip地址:指定拷贝到远程服务器的路径</code></li>
<li><code>scp -r 远程服务器用户名@远程服务器ip地址:远程服务器目录 指定拷贝到本地的路径</code></li>
<li><code>-r</code> 表示递归拷贝整个目录<br><img src="/2024/04/27/Linux%E6%8C%87%E4%BB%A4/scp.png" alt="alt text"></li>
</ul>
</li>
<li><p><code>ssh</code>命令是远程登录主机电脑，相当于直接操作的是远程电脑。</p>
</li>
<li><p><code>scp</code>命令是可以把本机文件拷贝到远程主机，也可以把远程主机文件远程拷贝的本机，注意:拷贝文件夹需要加<code>-r</code>选项。</p>
</li>
<li><p>大量的文件上传和下载可以通过可视化工具<code>FileZilla</code>来完成。</p>
</li>
</ol>
<h5 id="软件安装和卸载"><a href="#软件安装和卸载" class="headerlink" title="软件安装和卸载"></a>软件安装和卸载</h5><table>
<thead>
<tr>
<th>安装方式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>离线安装：deb文件格式安装</td>
<td>从本地存储介质安装软件，使用Debian软件包格式安装软件</td>
</tr>
<tr>
<td>在线安装：apt-get方式安装</td>
<td>通过网络下载并安装软，使用apt-get命令从仓库安装软件</td>
</tr>
</tbody></table>
<ul>
<li>更改镜像源<br>因为使用 apt-get 命令默认是从国外的服务器下载安装软件的，会导致下载安装速度很慢，所以需要更改成国内的镜像源服务器</li>
<li>镜像源就是下载软件来源的服务器。</li>
<li>apt-get 方式卸载命令: sudo apt-get remove 安装包名</li>
</ul>
<h2 id="第三章-文件和文件系统"><a href="#第三章-文件和文件系统" class="headerlink" title="第三章 文件和文件系统"></a>第三章 文件和文件系统</h2><ul>
<li>Linux系统中把一切可以用字节流传输的都看作一个文件</li>
<li>Linux系统里面的文件系统类型ext2 xfs jfs ext3 ext4</li>
<li>Windows系统里的文件系统类型: ntfs fat32<br><img src="/2024/04/27/Linux%E6%8C%87%E4%BB%A4/unix_device.png" alt="alt text"><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第一块SATA硬盘./dev/sda</span><br><span class="line">第二块SATA硬盘 /dev/sdb</span><br><span class="line">fdisk /dev/sdb  分区指令</span><br><span class="line">mkfs -t  ext4 /dev/sdb  格式化指令,-t参数表示要创建什么样的文件系统</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Linux系统下的重要文件"><a href="#Linux系统下的重要文件" class="headerlink" title="Linux系统下的重要文件"></a>Linux系统下的重要文件</h3><ul>
<li><code>/etc/passwd</code>: 每个用户在该文件中都有一行记录，其中包含了用户的登录名、密码（通常是一个指向加密密码的指针）、用户ID、组ID、用户信息、用户主目录和默认shell等信息<ol>
<li>&#x2F;usr&#x2F;bin&#x2F;chsh可以改变默认用户登陆的shell</li>
<li>&#x2F;etc&#x2F;passwd和&#x2F;usr&#x2F;bin&#x2F;passwd是两个不同文件,一个是记录用户口令等信息的文本文件,另一个是改变用户口令的可执行文件</li>
</ol>
</li>
<li><code>/dev/null</code>是Unix和类Unix操作系统（包括Linux）中的一个特殊文件，也被称为“空设备”或“空设备文件”。<ol>
<li>这个文件的主要特点是会丢弃所有写入到它的数据，就好像这些数据进入了一个黑洞一样。同时，当你尝试从&#x2F;dev&#x2F;null读取数据时，它会立即返回一个文件结束（EOF）标记。</li>
<li>在命令行操作中，&#x2F;dev&#x2F;null常被用作丢弃不需要的输出。例如，当你运行一个命令但并不关心其输出时，你可以将输出重定向到&#x2F;dev&#x2F;null，这样命令的输出就不会显示在终端或写入到其他文件。这对于清理不需要的日志信息或避免在脚本中产生垃圾数据非常有用。</li>
<li>简单来说，&#x2F;dev&#x2F;null就像一个数据的“黑洞”，任何写入其中的数据都会消失无踪，而读取它则不会得到任何实际内容。</li>
</ol>
</li>
</ul>
<h3 id="mount挂载命令"><a href="#mount挂载命令" class="headerlink" title="mount挂载命令"></a><code>mount</code>挂载命令</h3><ul>
<li>mount [-t vfstype][-o options] device dir</li>
<li>vfstype :vfat(window fat32 format)、ext3、ext4、iso9660(cdrom format)<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/sdc1 /mnt</span><br><span class="line">umount .mnt</span><br><span class="line">umount /dev/sdc1</span><br></pre></td></tr></table></figure>
<img src="/2024/04/27/Linux%E6%8C%87%E4%BB%A4/mount.png" alt="alt text"></li>
</ul>
<h3 id="Types-of-Files文件种类"><a href="#Types-of-Files文件种类" class="headerlink" title="Types of Files文件种类"></a>Types of Files文件种类</h3><ul>
<li><code>Simple/ordinary Files(普通文件)</code></li>
<li><code>Directory Files(目录文件)</code><br> 目录文件只包含两个字段:一个包含目录下的所有文件名,另一个是索引节点号<br> <img src="/2024/04/27/Linux%E6%8C%87%E4%BB%A4/direct.png" alt="alt text"></li>
<li><code>Link Files(链接文件)</code><br>A Link File is created by the system when a symbolic linkin created to an existing file.</li>
<li><code>Special(Device) Files(设备文件)</code><br>A special File is a means of accessinghardware devicesincluding the keyboard, hard disk, Cb-ROM drive, tapedrive andprinter.<ol>
<li>character special files(字符设备)</li>
<li>block special files(块设备)</li>
</ol>
</li>
<li><code>Named Pipe(FIFO)</code><br>Tools that enable processes to communicate with each other</li>
<li>Socket(网络插口)</li>
</ul>
<h3 id="动态库和静态库文件"><a href="#动态库和静态库文件" class="headerlink" title="动态库和静态库文件"></a>动态库和静态库文件</h3><ul>
<li>widows下</li>
</ul>
<ol>
<li>动态库.dll,不把代码打包进可执行文件,只是链接</li>
<li>静态库.o</li>
</ol>
<ul>
<li>linux</li>
</ul>
<ol>
<li>动态.so</li>
<li>静态.a</li>
</ol>
<h3 id="Linux下的目录结构"><a href="#Linux下的目录结构" class="headerlink" title="Linux下的目录结构"></a>Linux下的目录结构</h3><p><img src="/2024/04/27/Linux%E6%8C%87%E4%BB%A4/directory_struct.jpg" alt="alt text"></p>
<h3 id="和文件操作相关的命令"><a href="#和文件操作相关的命令" class="headerlink" title="和文件操作相关的命令"></a>和文件操作相关的命令</h3><ul>
<li><code>df</code>命令  显示分区使用情况(挂载)<br><img src="/2024/04/27/Linux%E6%8C%87%E4%BB%A4/df.png" alt="alt text"></li>
<li><code>du</code>命令  查看文件分配的存储空间大小<br><img src="/2024/04/27/Linux%E6%8C%87%E4%BB%A4/du.png" alt="alt text"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">du -s /etc</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看目录占用空间</span></span><br></pre></td></tr></table></figure></li>
<li><code>mkdir</code>命令  创建目录<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p dira/dirb</span><br><span class="line">参数p表示创建路径上的所有目录</span><br></pre></td></tr></table></figure></li>
<li><code>rmdir</code>命令  只能删除空目录<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir dira</span><br><span class="line">rmdir dira</span><br></pre></td></tr></table></figure></li>
<li><code>ls</code>命令 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ls -a 目录或文件名</span><br><span class="line">参数a表示显示出所有以.开头的隐藏文件</span><br><span class="line">ls -l 目录或文件名</span><br><span class="line">参数p表示以列表的形式列出详细信息</span><br></pre></td></tr></table></figure>
<img src="/2024/04/27/Linux%E6%8C%87%E4%BB%A4/ls-l.png" alt="alt text"><br>第一个字段第一个字符表示文件类型,<code>-</code>表示普通文件<br>第二个字段: 链接数,有多少个条目指向了这个文件的索引节点<br>第三个字段:所属用户<br>第四个字段:所属组<br>第五个字段:大小(以字节为单位)<br>第六个字段:文件最后修改时间<br>第七个字段:文件名<br><img src="/2024/04/27/Linux%E6%8C%87%E4%BB%A4/Determining_File_Attributes.png" alt="alt text"></li>
<li><code>touch</code>命令  创建文件或修改文件最后修改时间<br>如果文件不存在,则创建文件,否则修改最后修改时间</li>
<li><code>rm</code>命令  删除文件或目录<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rm -i file1</span><br><span class="line">参数i表示交互式的</span><br><span class="line">rm -rf dirb</span><br><span class="line">参数r表示递归删除子目录在删除所有文件</span><br><span class="line">参数f表示强制删除</span><br></pre></td></tr></table></figure></li>
<li><code>mv</code>命令  移动文件或者文件重命名</li>
<li><code>file</code>命令  查看文件详细信息</li>
<li><img src="/2024/04/27/Linux%E6%8C%87%E4%BB%A4/file.png" alt="alt text"></li>
</ul>
<h3 id="逻辑卷管理-好处-可以动态扩充"><a href="#逻辑卷管理-好处-可以动态扩充" class="headerlink" title="逻辑卷管理(好处:可以动态扩充)"></a>逻辑卷管理(好处:可以动态扩充)</h3><ul>
<li>挂载: 把一个硬件设备和对应的目录关联起来</li>
<li>硬盘变成可用存储空间要经过三步<ol>
<li>分区</li>
<li>格式化</li>
<li>挂载</li>
</ol>
</li>
<li>逻辑卷管理软件工具:用多块硬盘上的分区虚拟成一个分区</li>
</ul>
<p> 逻辑卷管理软件工具，如逻辑卷管理器（LVM），允许用户将多块硬盘上的分区虚拟成一个分区，从而更有效地管理和使用硬盘资源。以下是使用LVM将多块硬盘上的分区虚拟成一个分区的基本步骤：</p>
<ol>
<li><strong>准备磁盘并标记物理卷</strong>：首先，你需要准备要进行逻辑卷管理的硬盘分区，并将这些分区标记为物理卷。物理卷是LVM管理的基本单位，可以是一个硬盘分区或者整个硬盘。</li>
<li><strong>创建卷组</strong>：接下来，你需要创建一个卷组。卷组是由一个或多个物理卷组成的集合，它提供了逻辑卷管理的框架。</li>
<li><strong>创建逻辑卷</strong>：在卷组中，你可以创建逻辑卷。逻辑卷是最终提供给操作系统使用的虚拟分区，它们可以跨多个物理卷或卷组。</li>
<li><strong>格式化逻辑卷</strong>：创建逻辑卷后，你需要对其进行格式化，以便操作系统可以识别和使用。</li>
<li><strong>挂载逻辑卷</strong>：最后，将逻辑卷挂载到操作系统的文件系统中，这样你就可以像访问其他分区一样访问逻辑卷上的数据。</li>
</ol>
<p>此外，LVM还提供了许多其他功能，如逻辑卷的扩容、缩小、迁移和备份等，这些都可以在不中断数据访问的情况下进行。</p>
<h2 id="第五章-文件安全"><a href="#第五章-文件安全" class="headerlink" title="第五章 文件安全"></a>第五章 文件安全</h2><h3 id="1-Protection-based-on-AccessPermission"><a href="#1-Protection-based-on-AccessPermission" class="headerlink" title="1.Protection based on AccessPermission"></a>1.Protection based on AccessPermission</h3><ul>
<li>Types of users <ol>
<li>User&#x2F;owner(文件拥有者)</li>
<li>groups(同组用户)</li>
<li>others(其他人)</li>
</ol>
</li>
<li>Types of Access Permissions<ul>
<li>Read, write, and execute(执行)</li>
</ul>
</li>
<li>Access Permissions for Directories<ul>
<li>Read: list the files</li>
<li>Write: create or remove directories and files</li>
</ul>
</li>
</ul>
<p>所以,对于每个文件,三个身份和三种权限组成九个权限位<br><img src="/2024/04/27/Linux%E6%8C%87%E4%BB%A4/file_permission.png" alt="alt text"></p>
<ul>
<li>目录也有权限<ol>
<li>目录的x执行权限:所有要进入到目录里的操作,包括(<code>cd</code>命令,<code>touch</code>命令,删除目录里的文件)<br>目录文件只包含两个字段:一个包含目录下的所有文件名,另一个是索引节点号<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">想要查看目录权限要加参数d</span></span><br><span class="line">ls -ld dira</span><br></pre></td></tr></table></figure>
<img src="/2024/04/27/Linux%E6%8C%87%E4%BB%A4/ls_view_dir.png" alt="alt text"></li>
</ol>
</li>
</ul>
<h3 id="2-改变权限或者所属组的命令"><a href="#2-改变权限或者所属组的命令" class="headerlink" title="2. 改变权限或者所属组的命令"></a>2. 改变权限或者所属组的命令</h3><ul>
<li><code>chgrp  组1 文件或目录路径</code>: 改变组</li>
<li><code>chown newowner 文件</code>: 改变所属用户</li>
<li><code>id user</code>: Find the user id</li>
<li><code>group user</code>: Find the user group</li>
</ul>
<h3 id="3-Changing-File-Access-Privileges"><a href="#3-Changing-File-Access-Privileges" class="headerlink" title="3.Changing File Access Privileges"></a>3.Changing File Access Privileges</h3><p><code>chmod  权限语句 文件或目录对象</code>命令:改变文件权限位<br>权限语句由三部分组成:</p>
<ul>
<li>例如 <code>u-x</code><br>第一部分是要修改谁的权限:a表示所有,u表示owner,g表示group,o表示others,ugo也表示所有<br><img src="/2024/04/27/Linux%E6%8C%87%E4%BB%A4/chmod.png" alt="alt text"></li>
<li>也可以用八进制数来代替权限语句,能够一次性设定所有文件权限位<br>如要给一个文件设置rwxr-x—权限,每三位(111 101 000)转化成八进制数就是750,所以命令就是<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 750 hello</span><br></pre></td></tr></table></figure>
<img src="/2024/04/27/Linux%E6%8C%87%E4%BB%A4/rm_file_withoutpermisn.png" alt="alt text"></li>
</ul>
<h3 id="Default-file-access-privileges-默认文件权限"><a href="#Default-file-access-privileges-默认文件权限" class="headerlink" title="Default file access privileges 默认文件权限"></a>Default file access privileges 默认文件权限</h3><ul>
<li>通过掩码值umask来设定默认访问权限</li>
<li><code>umask</code>命令  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示掩码值</span></span><br><span class="line">input: umask</span><br><span class="line">ouput: 0022</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置掩码值</span></span><br><span class="line">input: umask 077</span><br></pre></td></tr></table></figure></li>
<li>umask怎么决定文件访问权限<ol>
<li>The access permission value onexecutable file or directory iscomputed by(针对目录或者可执行文件): <code>file access permission=777-mask</code></li>
<li>The access permission value on otherfile is computed by(对于普通文件):<code>file access permission = 666-mask</code><br><img src="/2024/04/27/Linux%E6%8C%87%E4%BB%A4/umask01.png" alt="alt text"></li>
</ol>
</li>
</ul>
<p><img src="/2024/04/27/Linux%E6%8C%87%E4%BB%A4/umask02.png" alt="alt text"></p>
<h3 id="三个特殊权限位"><a href="#三个特殊权限位" class="headerlink" title="三个特殊权限位"></a>三个特殊权限位</h3><ul>
<li><p><code>SUID</code>位<br><img src="/2024/04/27/Linux%E6%8C%87%E4%BB%A4/suid.png" alt="alt text"><br>If this bit is set for a file containing an executable program for a command,the command takes on the privileges of the owner of the file when it executes.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 设置suid位 --&gt;</span><br><span class="line">sudo chmod u+s /usr/bin/passwd</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>SGID</code>位<br>执行命令时,会把身份临时切换成同组成员(groups)</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 设置sgid位 --&gt;</span><br><span class="line">sudo chmod g+s /usr/bin/passwd</span><br></pre></td></tr></table></figure></li>
<li><p><code>STICKY</code>黏着位(对于目录)<br> 设置黏着位意味着在对于一些共享目录(所有人都能创建文件)时,不同用户只能删除自己的文件</p>
 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 设置/取消设置黏着位 --&gt;</span><br><span class="line">chmod +t /tmp</span><br><span class="line">chmod -t /tmp</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="第六章-File-Processing"><a href="#第六章-File-Processing" class="headerlink" title="第六章 File Processing"></a>第六章 File Processing</h2><h3 id="view-complete-file"><a href="#view-complete-file" class="headerlink" title="view complete file"></a>view complete file</h3><h4 id="显示文件全部内容"><a href="#显示文件全部内容" class="headerlink" title="显示文件全部内容"></a>显示文件全部内容</h4><ul>
<li><code>cat</code>命令 <ol>
<li>参数<code>n</code>: 显示行号</li>
<li><code>cat</code>命令不加文件时,默认从标准输入中读取数据(等待键盘输入)</li>
</ol>
</li>
<li><code>nl</code>命令</li>
</ul>
<h4 id="分页查看文本文件"><a href="#分页查看文本文件" class="headerlink" title="分页查看文本文件"></a>分页查看文本文件</h4><ul>
<li><code>more</code>或<code>less</code>命令<ol>
<li>输入<code>/s22</code>会在文件中查找s22相对应文字</li>
<li>按Q退出</li>
</ol>
</li>
<li><code>od</code>命令 显示不可见字符<br><img src="/2024/04/27/Linux%E6%8C%87%E4%BB%A4/od.png" alt="alt text"><ol>
<li>参数<code>-c</code>表示以字符形式显示,例如空行会变成<code>\n</code></li>
<li><code>-h</code>以十六进制显示</li>
</ol>
</li>
</ul>
<h4 id="Viewing-the-head-or-tail-of-a-file"><a href="#Viewing-the-head-or-tail-of-a-file" class="headerlink" title="Viewing the head or tail of a file"></a>Viewing the head or tail of a file</h4><ul>
<li><code>head</code>默认显示文件前五行<ol>
<li>参数<code>-n5</code>表示显示文件开头前5行,数字可任意改,<code>n</code>可以不写</li>
</ol>
</li>
<li><code>tail</code>默认显示文件最后五行<ol>
<li>参数<code>-5</code>表示显示文件开头前5行,数字可任意改</li>
<li>参数<code>-f</code>实时刷新 ctrl+c退出</li>
</ol>
</li>
<li><code>wc</code> 查看文件大小的命令(Determining file size)<br> <img src="/2024/04/27/Linux%E6%8C%87%E4%BB%A4/wc.png" alt="alt text"><ol>
<li>参数<code>-l</code>表示只显示行数</li>
<li><code>-w</code>只显示单词数</li>
<li><code>-c</code>表示只显示字符数<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wc -l /tmp/hello.cpp</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看系统里有多少个用户</span></span><br><span class="line">wc -l /etc/passwd</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h4 id="比较两个文本文件"><a href="#比较两个文本文件" class="headerlink" title="比较两个文本文件"></a>比较两个文本文件</h4><ul>
<li><code>diff</code>命令<br>diff [options] [file1] [file2]</li>
</ul>
<h3 id="查找文件命令"><a href="#查找文件命令" class="headerlink" title="查找文件命令"></a>查找文件命令</h3><h4 id="普通文件"><a href="#普通文件" class="headerlink" title="普通文件"></a>普通文件</h4><ul>
<li><code>find</code>命令</li>
<li><code>find</code> 后面跟一个目录,表示在此目录中寻找,  </li>
<li>expression:<ul>
<li><code>-name</code> pattern</li>
<li><code>-size</code> +&#x2F;-N  加号&#x2F;减号表示 大小&#x2F;小于 大于N的文件</li>
<li><code>-exec</code> or <code>-ok</code> CMD 表示对find找到的结果每一个都执行一条命令CMD,exec和ok的区别在于ok每一次都要询问 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /tmp  \( -name &quot;*.txt&quot; -a -size 0 \) -exec ls -l &#123;&#125; \; 2&gt;/dev/null</span><br></pre></td></tr></table></figure>
 <img src="/2024/04/27/Linux%E6%8C%87%E4%BB%A4/find_exec.png" alt="alt text"></li>
<li><code>\( 组合 \)</code> 使用括号来把多个条件组合在一起 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /tmp  \( -name &quot;*.txt&quot; -a -size 0 \) 2&gt;/dev/null</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<ol>
<li>通配符的使用,通配符是一种特殊语句，主要有星号(*)和问号(?)，用来模糊搜索文件</li>
</ol>
<table>
<thead>
<tr>
<th>通配符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>代表0个或多个任意字符</td>
</tr>
<tr>
<td>?</td>
<td>代表任意一个字符</td>
</tr>
</tbody></table>
<p><img src="/2024/04/27/Linux%E6%8C%87%E4%BB%A4/find.png" alt="alt text"><br>通配符不仅能结合 find 命令使用，还可以结合其它命令使用,比如: ls、mv、cp 等，这里需要注意只有find命令使用通配符需要加上引号。<br><img src="/2024/04/27/Linux%E6%8C%87%E4%BB%A4/dev_null.png" alt="alt text"></p>
<h4 id="命令文件"><a href="#命令文件" class="headerlink" title="命令文件"></a>命令文件</h4><ul>
<li><code>whereis</code> 查找命令文件，会找出可执行文件的位置和帮助文档的位置</li>
<li><code>which</code> 查找命令文件</li>
</ul>
<h3 id="对文件内容操作"><a href="#对文件内容操作" class="headerlink" title="对文件内容操作"></a>对文件内容操作</h3><h4 id="去掉重复内容"><a href="#去掉重复内容" class="headerlink" title="去掉重复内容"></a>去掉重复内容</h4><ul>
<li><code>uniq</code>命令<br>uniq命令只能除去中间没有其他行的重复行</li>
<li>参数<ol>
<li><code>-c</code> 统计连续重复出现的次数</li>
<li><code>-d</code> 显示重复的行</li>
<li><code>uniq 源文件名a 文件名b</code>表示把去重结果输出到文件中<br><img src="/2024/04/27/Linux%E6%8C%87%E4%BB%A4/uniq.png" alt="alt text"></li>
</ol>
</li>
</ul>
<h4 id="sort对文件内容进行排序"><a href="#sort对文件内容进行排序" class="headerlink" title="sort对文件内容进行排序"></a><code>sort</code>对文件内容进行排序</h4><ul>
<li><code>sort</code> 排序</li>
<li>参数<ul>
<li><code>-k3</code> 表示按第3个字段来排序</li>
<li><code>-n</code> 默认按字符串来排，看编码，想要把字段当作数字来排序，加参数<code>-n</code></li>
<li><code>-r</code> 逆序排列 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort -nrk4 /tmp/student_record</span><br></pre></td></tr></table></figure></li>
<li><code>-t&quot;分隔符&quot;</code> sort命令默认按空格分割字段，参数<code>-t</code>可以切换分隔符 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort -nrk4 -t&quot;:&quot; /tmp/student_record</span><br></pre></td></tr></table></figure></li>
<li><code>-f</code> 表示不区分大小写</li>
</ul>
</li>
</ul>
<h4 id="cut命令剪切文件内容"><a href="#cut命令剪切文件内容" class="headerlink" title="cut命令剪切文件内容"></a><code>cut</code>命令剪切文件内容</h4><ul>
<li>cut -blist [-n][file-list]</li>
<li>cut -clist [file-list]</li>
<li>cut -flist [-dchar][-s][file-list]</li>
<li>参数<ul>
<li><code>-f参数1,参数2...</code>  表示切割出第（参数）列字段</li>
<li><code>-d&quot;分隔符&quot;</code> <code>cut</code>命令默认使用<code>TAB制表符</code>来作为分隔符，加<code>-d</code>参数可以修改分隔符<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cut -d&quot;:&quot; -f2 /etc/passwd | head -3</span><br></pre></td></tr></table></figure></li>
<li><code>-c参数1,参数2</code> 表示切割出第（参数）列字符</li>
</ul>
</li>
</ul>
<h4 id="拼接命令"><a href="#拼接命令" class="headerlink" title="拼接命令"></a>拼接命令</h4><ul>
<li><code>paste 文件a 文件b</code>命令 简单的把文件a和b按行拼接，第一行拼第一行…</li>
<li><code>join</code>命令 实现按关键字拼接 <!-- * # TODO --></li>
</ul>
<h4 id="查找文件内容"><a href="#查找文件内容" class="headerlink" title="查找文件内容"></a>查找文件内容</h4><p><code>grep</code>命令: 查找或搜索文件内容</p>
<ul>
<li><code>grep</code> 查找内容 文件名</li>
</ul>
<ol>
<li>grep命令及选项的使用</li>
</ol>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-v</td>
<td>显示不包含匹配文本的所有行</td>
</tr>
<tr>
<td>-n</td>
<td>显示匹配行号</td>
</tr>
<tr>
<td>-i</td>
<td>忽略大小写</td>
</tr>
<tr>
<td>-l</td>
<td>只列出包含内容的文件列表，不关心内容</td>
</tr>
<tr>
<td>-c</td>
<td>只计数，对每个文件进行计数操作</td>
</tr>
</tbody></table>
<ol start="2">
<li>grep命令结合正则表达式使用</li>
</ol>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>(行)以指定字符开头</td>
</tr>
<tr>
<td>$</td>
<td>(行)以指定字符结尾</td>
</tr>
<tr>
<td>.</td>
<td>匹配任意一个非换行符的字符</td>
</tr>
<tr>
<td>*</td>
<td>代表前一个字符可以出现一次或者任意多次</td>
</tr>
<tr>
<td>[]</td>
<td>代表集合的意思,eg. [Hh]ello</td>
</tr>
<tr>
<td><code>[^]</code></td>
<td>方括号里上箭头表示取反,匹配除了括号里的其他所有字符</td>
</tr>
<tr>
<td><code>\&lt;</code></td>
<td>表示一个单词的开头,或者可以用grep的参数<code>-w</code></td>
</tr>
<tr>
<td><code>\&gt;</code></td>
<td>表示一个单词的结束</td>
</tr>
<tr>
<td><code>\&#123;a,b\&#125;</code></td>
<td>表示前一个字符出现a到b次,a为0表示至多出现b次,b不填表示至少出现a次以上</td>
</tr>
<tr>
<td><code>| </code></td>
<td>表示或,要用grep的升级版egrep</td>
</tr>
<tr>
<td><code>?</code></td>
<td>出现一次或者不出现</td>
</tr>
<tr>
<td><code>+</code></td>
<td>表示前一个字符至少出现一次</td>
</tr>
<tr>
<td><code>()</code></td>
<td>Grouping</td>
</tr>
<tr>
<td><code>\</code></td>
<td>转义斜杠</td>
</tr>
</tbody></table>
<p><img src="/2024/04/27/Linux%E6%8C%87%E4%BB%A4/re.png" alt="alt text"></p>
<p><img src="/2024/04/27/Linux%E6%8C%87%E4%BB%A4/grep.png" alt="alt text"></p>
<ul>
<li>通过 grep 命令可以在指定文件中查找指定搜索内容，这里扩展一下，grep 还可以查找管道中的内容<br>比如:ls&#x2F;| grep ‘lib’</li>
<li>在使用 grep 命令时，还可以省略查找内容的引号比如:ls&#x2F;| grep lib , grep hello 1.txt</li>
</ul>
<h4 id="对文本批量修改"><a href="#对文本批量修改" class="headerlink" title="对文本批量修改"></a>对文本批量修改</h4><ul>
<li><p><code>sed</code>流处理<br> 对文件流水线处理,读一行处理一行sed ‘[address]command’ filename(s)</p>
<ul>
<li>根据行号选中行处理<ol>
<li><code>d</code> 删除操作对1到3行进行删除操作<code>sed &#39;1,3d&#39; filename</code></li>
</ol>
</li>
<li>根据正则表达式选中包含匹配项的行处理,<code>sed &#39;/正则表达式/&#39; file</code><ol>
<li><code>s</code>替换操作 对计算机系CS的学生替换成EECS<code>sed &#39;s/&lt;CS/EECS/&#39; file</code></li>
<li><code>s///g</code>全局替换操作 把数字替换成*屏蔽成绩<code>sed &#39;s/[0-9]/*/g&#39; file</code></li>
<li><code>p</code>打印前三行<code>sed &#39;1,3p&#39; file</code></li>
<li><code>a</code>在匹配行后加一行内容<code>sed &#39;/\&lt;CS/a =====High Salary=====&#39; file</code></li>
<li><code>i</code>在匹配后前加一行内容<code>sed &#39;/\&lt;CS/i =====High Salary=====&#39; file</code></li>
<li><code>!</code>否定</li>
</ol>
</li>
<li><code>-n</code>参数 表示只执行操作,不默认输出缓冲区</li>
<li><code>-i</code>参数（或 <code>--in-place</code>）是一个非常重要的选项，它允许你直接修改输入文件，而不是仅仅将结果发送到标准输出。</li>
</ul>
<ul>
<li><code>sed</code>格式<br>  <code>sed &#39;/正则表达式/s#原文#替换文本#&#39;</code><br>  <code>sed &#39;/^[[:space:]]*$/d&#39; output_sort.txt</code>严格删除所有空行<code>[[:space:]]</code>这是sed中的一个字符类，表示空白字符。它匹配任何空白字符，如空格、制表符、换行符、回车符等</li>
</ul>
</li>
<li><p><code>awk</code>命令</p>
<ul>
<li><code>awk</code>命令里的正则表达式格式为<code>awk &#39;/re/&#39; filename</code><br> <img src="/2024/04/27/Linux%E6%8C%87%E4%BB%A4/awk01.png" alt="alt text"></li>
<li>在awk命令中,美元符号表示字段的意思<code>$</code><br> <img src="/2024/04/27/Linux%E6%8C%87%E4%BB%A4/awk_$.png" alt="alt text"></li>
<li><code>F</code>参数指定分割符<ul>
<li>默认情况下，awk 使用空格或制表符作为字段分隔符</li>
<li>如果你有一个以逗号, 分隔的文件，并希望使用 awk 来处理它，你可以这样指定分隔符:<code>awk -F, &#39;&#123;print $1, $2&#125;&#39; filename</code></li>
<li>如果有都多个分隔符,用<code>[]</code>括起来,例如<code>-F&#39;[ab]&#39;</code></li>
</ul>
</li>
<li><code>$1~</code>字段匹配<ul>
<li><code>awk &#39;$2~/^D/&#123;print $1,$2&#125;&#39;</code>表示对字段2进行匹配,如果是以D开头的,就打印字段1,字段2</li>
<li><code>awk &#39;$2!~/^D/&#123;print $1,$2&#125;&#39;</code>表示对字段2不进行匹配以D开头的,就打印字段1,字段2</li>
</ul>
</li>
</ul>
</li>
<li><p><code>tr</code>命令(映射替换)</p>
<ul>
<li>tr 被映射域 映射域(可用区间表示)<br> <img src="/2024/04/27/Linux%E6%8C%87%E4%BB%A4/tr.png" alt="alt text"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;/\&lt;CS/&#123;print $1,$2&#125;&#x27; /tmp/student_record</span><br><span class="line"></span><br><span class="line">awk &#x27;$2~/^D/&#123;print $1,$2&#125;&#x27;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="variable">$2</span>~/^D/：这是一个条件，它检查第二列（由字段分隔符分隔，默认为空格或制表符）是否以字母 <span class="string">&quot;D&quot;</span> 开头,~ 是 awk 中用于模式匹配的操作符</span></span><br><span class="line"></span><br><span class="line">awk -F: &#x27;$2 !~ /916/ &#123;print $1&#125;&#x27; /tmp/donors</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这条命令将根据冒号分隔符(:)来解析文件中的内容，并打印出第二个字段中不包含916区号的人的名字。</span></span><br><span class="line"></span><br><span class="line">awk &#x27;&#123;print NR &quot;: &quot; $0&#125;&#x27; /tmp/donors</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">请将<span class="string">&quot;文件名&quot;</span>替换为您要处理的文件名。这条命令将打印出每条记录的行号（记录号）后面跟着记录的内容。记录号由NR内置变量提供，表示当前处理的记录的序号。</span></span><br><span class="line"></span><br><span class="line"> awk  -F&#x27;[: ]&#x27; &#x27;$7 &lt;= 85 &#123;print $1,$2,$4&#125;&#x27; /tmp/donors</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="文件解压缩"><a href="#文件解压缩" class="headerlink" title="文件解压缩"></a>文件解压缩</h3><ul>
<li><p><code>gzip</code> 只能保留压缩或者未压缩二选一</p>
<ul>
<li>压缩命令格式<code>gzip filename</code></li>
<li>解压格式<code>gzip -d ziped_filename</code></li>
</ul>
</li>
<li><p><code>bzip2</code> .bz2后缀</p>
<ul>
<li>压缩命令格式<code>bzip2 filename</code></li>
<li>解压格式<code>bzip2 -d ziped_filename</code></li>
</ul>
</li>
<li><p><code>Linux</code>下文本文件和<code>Windows</code>下文本文件不同:<br> <code>Windows</code>下文本文件会每行包含一个<code>\r</code><br> <img src="/2024/04/27/Linux%E6%8C%87%E4%BB%A4/linuxtxt_dif_windows.png" alt="alt text"></p>
</li>
</ul>
<h2 id="第七章-vim的使用"><a href="#第七章-vim的使用" class="headerlink" title="第七章 vim的使用"></a>第七章 vim的使用</h2><h3 id="7-1-vim的三种模式"><a href="#7-1-vim的三种模式" class="headerlink" title="7.1 vim的三种模式"></a>7.1 vim的三种模式</h3><ol>
<li>命令模式<br>命令模式下按i进入编辑模式（插入模式）</li>
<li>插入模式<br>在此模式下编辑文件内容，按esc退出，进入末行模式</li>
<li>末行模式<br>在此模式下输入<code>:q</code>表示直接退出，<code>:q！</code>强制退出<br><code>w</code>表示保存，<code>wq</code>保存且退出</li>
</ol>
<h3 id="7-2-vim的常用命令"><a href="#7-2-vim的常用命令" class="headerlink" title="7.2 vim的常用命令"></a>7.2 vim的常用命令</h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>yy</td>
<td>复制当前行</td>
</tr>
<tr>
<td>p</td>
<td>粘贴</td>
</tr>
<tr>
<td>dd</td>
<td>删除当前行</td>
</tr>
<tr>
<td>v</td>
<td>普通视图模式</td>
</tr>
<tr>
<td>u</td>
<td>撤销</td>
</tr>
<tr>
<td>ctrl+r</td>
<td>重做,反撤销</td>
</tr>
<tr>
<td>g</td>
<td>跳到文件头</td>
</tr>
<tr>
<td>G</td>
<td>跳到文件尾</td>
</tr>
<tr>
<td>数字+G</td>
<td>跳转到指定行</td>
</tr>
<tr>
<td>&#x2F;关键词</td>
<td>向下查找关键词</td>
</tr>
<tr>
<td>:&#x2F;搜索的内容</td>
<td>搜索指定内容</td>
</tr>
<tr>
<td>?关键词</td>
<td>向上查找关键词</td>
</tr>
<tr>
<td>n</td>
<td>查找下一个</td>
</tr>
<tr>
<td>N</td>
<td>查找上一个</td>
</tr>
<tr>
<td>:%s&#x2F;原字符串&#x2F;新字符串&#x2F;g</td>
<td>全局替换</td>
</tr>
<tr>
<td>:开始行数,结束行数s&#x2F;原字符串&#x2F;新字符串&#x2F;g</td>
<td>局部替换</td>
</tr>
<tr>
<td>快捷键</td>
<td>功能</td>
</tr>
<tr>
<td>———</td>
<td>—————</td>
</tr>
<tr>
<td><code>.</code></td>
<td>重复上一次命令操作</td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>跳至基地</td>
</tr>
<tr>
<td><code>shift</code>+<code>6</code></td>
<td>切换成蓝色主题的外观</td>
</tr>
<tr>
<td><code>shift</code>+<code>4</code></td>
<td>回到浅灰色主题</td>
</tr>
<tr>
<td><code>ctrl</code>+<code>f</code></td>
<td>回到黑暗主题</td>
</tr>
<tr>
<td><code>ctrl</code>+<code>b</code></td>
<td>上传一屏</td>
</tr>
</tbody></table>
<h2 id="第八章-File-Share"><a href="#第八章-File-Share" class="headerlink" title="第八章 File Share"></a>第八章 File Share</h2><h3 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h3><ul>
<li><p><code>ln 源文件名  链接文件名</code><br> 修改链接文件的内容,原文件也会改变</p>
</li>
<li><p>不能跨文件系统(设备)创建链接,也不能对目录创建硬链接</p>
</li>
<li><p>创建硬链接文件,链接文件与原文件分配同样的索引节点号(文件系统)</p>
</li>
</ul>
<h3 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h3><ul>
<li><code>ln -s 源文件名  链接文件名</code><br> 分配<strong>不同于源文件的索引节点</strong>,当访问链接文件时,先去根据索引节点号找到链接文件所在硬盘位置,访问<strong>链接文件内容(源文件路径信息等)<strong>找到源文件,在根据源文件的文件名和索引节点号找到源文件索引节点,从而找到</strong>源文件路径,对源文件进行访问</strong>。<code>要访问两次硬盘</code></li>
</ul>
<h2 id="第九章-重定向和管道"><a href="#第九章-重定向和管道" class="headerlink" title="第九章 重定向和管道"></a>第九章 重定向和管道</h2><h3 id="1-文件描述符表"><a href="#1-文件描述符表" class="headerlink" title="1.文件描述符表"></a>1.文件描述符表</h3><p><strong>文件描述符表</strong>（File Descriptor Table）是操作系统中用于管理打开的文件、套接字、管道等文件类型对象的一种数据结构。在Unix和类Unix系统（如Linux）中，每一个进程都有一个与之关联的文件描述符表。</p>
<ol>
<li><strong>文件描述符</strong>：这是一个非负整数，用于在进程中唯一地标识一个打开的文件或套接字。例如，当你使用<code>open()</code>函数打开一个文件时，系统会返回一个文件描述符。</li>
<li><strong>文件描述符表</strong>：这个表是一个数组，其索引是文件描述符，数组的元素是指向打开文件的指针（在更底层，这通常是一个指向文件表项的指针）。</li>
<li><strong>文件表</strong>：每个打开的文件在内核中都有一个对应的文件表项（也称为v-node或inode）。这个表项包含了文件的详细信息，如文件的大小、访问权限、偏移量等。</li>
<li><strong>关系</strong>：文件描述符表是进程级别的，而文件表是系统级别的。一个文件表项可以被多个进程共享（通过不同的文件描述符），但每个进程都有自己的文件描述符表。</li>
<li><strong>操作</strong>：当进程执行如<code>read()</code>、<code>write()</code>等系统调用时，它会使用文件描述符作为参数。系统会根据文件描述符在文件描述符表中查找对应的文件表项，并执行相应的操作。</li>
<li><strong>关闭文件</strong>：当进程使用<code>close()</code>系统调用关闭一个文件时，它实际上是在文件描述符表中删除对应的条目，而不是删除文件表项。只有当所有引用该文件的进程都关闭了该文件时，文件表项才会被释放。</li>
</ol>
<p><img src="/2024/04/27/Linux%E6%8C%87%E4%BB%A4/file_desc_specl.png" alt="alt text"></p>
<ul>
<li>有三个特殊的文件描述符,是系统自动打开的<ol>
<li>标准输入描述符<code>stdin</code> 0</li>
<li>标准输出描述符<code>stdout</code> 1</li>
<li>标准错误输出描述符<code>stderr</code> 2</li>
</ol>
</li>
</ul>
<h3 id="2-重定向"><a href="#2-重定向" class="headerlink" title="2.重定向"></a>2.重定向</h3><h4 id="2-1标准输出重定向"><a href="#2-1标准输出重定向" class="headerlink" title="2.1标准输出重定向"></a>2.1标准输出重定向</h4><ul>
<li>格式: <code>command &lt; input_file</code></li>
<li>例子 把&#x2F;tmp&#x2F;studnet_record 里的所有小写字母变成大写<br><img src="/2024/04/27/Linux%E6%8C%87%E4%BB%A4/input_rediect.png" alt="alt text"></li>
</ul>
<h4 id="2-2标准输出重定向"><a href="#2-2标准输出重定向" class="headerlink" title="2.2标准输出重定向"></a>2.2标准输出重定向</h4><p>重定向也称为输出重定向，把在终端执行命令的结果保存到目标文件。</p>
<ul>
<li>格式: <code>command &gt; output_file</code></li>
</ul>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>&gt;</td>
<td>如果文件存在，会覆盖原有文件内容，相当于文件操作中的’w’模式</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>如果文件存在，会追加写入文件末尾，相当于文件操作中的’a’模式</td>
</tr>
</tbody></table>
<p><img src="/2024/04/27/Linux%E6%8C%87%E4%BB%A4/%E9%87%8D%E5%AE%9A%E5%90%91.png" alt="alt text"></p>
<ul>
<li>可以使用输出重定向合并文件<ol>
<li>按列合并 cat filea fileb &gt; newfile</li>
<li>按行合并 paste filea fileb &gt; newfile</li>
</ol>
</li>
</ul>
<h4 id="2-2标准错误输出重定向"><a href="#2-2标准错误输出重定向" class="headerlink" title="2.2标准错误输出重定向"></a>2.2标准错误输出重定向</h4><ul>
<li>格式: <code>2 &gt; output_file</code><br> <code>2</code>表示标准错误输出</li>
<li>使用pipe出现错误输出时,<code>2&gt;/dev/null</code>放在出现错误命令的后面</li>
</ul>
<p><img src="/2024/04/27/Linux%E6%8C%87%E4%BB%A4/stderr.png" alt="alt text"></p>
<ul>
<li><code>/dev/null</code> 空设备,一般不关心的错误输出就丢到空设备文件中</li>
</ul>
<h4 id="多种重定向结合"><a href="#多种重定向结合" class="headerlink" title="多种重定向结合"></a>多种重定向结合</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">find /tmp -name &quot;*.cpp&quot; 2&gt;/dev/null &gt;result </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">即丢弃结果也保存正常输出文件</span></span><br><span class="line"></span><br><span class="line">find /tmp -name &quot;*.cpp&quot; &gt;&amp;result </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">把标准输出和标准错误输出都保存到文件result中</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>Redirecting stdin and stdout in OneCommand<br> Command <input-file > out-file</p>
</li>
<li><p>Redirecting stdout and stderr in OneCommand<br> Command &gt;out-file 2&gt;err-file<br> Command &gt;out-file 2&gt;&amp;1<br> Command &gt;&amp; out-file</p>
</li>
</ul>
<h3 id="进程间通信的方式"><a href="#进程间通信的方式" class="headerlink" title="进程间通信的方式"></a>进程间通信的方式</h3><ul>
<li>匿名管道：是一种半双工的通信方式，只能在有亲缘关系的进程之间使用。管道可以实现在一个进程中生成输出，而在另一个进程中读取该输出</li>
<li>命名管道：是一种有名的FIFO文件，在文件系统中以文件形式存在，可以在不相关的进程之间进行通信</li>
<li>消息队列：是一种进程间通信的方式，一方发送消息到队列，而另一方则从队列中接收消息</li>
<li>信号量：用于进程间的同步与互斥，可以实现进程对临界资源的访问控制</li>
<li>信号：是一种异步的通知机制，用于通知进程发生了某种事件，比如接收到了某种信号或者错误</li>
<li>共享内存：是一种高效的进程间通信方式，多个进程可以共享同一块内存区域，以实现数据的共享</li>
<li>socket：是一种网络编程的通信方式，通过网络套接字实现不同主机的进程间通信</li>
</ul>
<h3 id="KISS原则"><a href="#KISS原则" class="headerlink" title="KISS原则"></a><code>KISS</code>原则</h3><p>Linux设计时,遵循<code>KISS(Keep It Simple Stupid)</code>原则</p>
<h3 id="匿名-管道命令"><a href="#匿名-管道命令" class="headerlink" title="(匿名)管道命令"></a>(匿名)管道命令</h3><p>管道<code>|</code>相当于一个容器,可以把命令执行的结果存储到里面,在释放出来</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tree /bin/ | more</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">统计当前登陆主机人数</span></span><br><span class="line">who | wc -l </span><br><span class="line"></span><br><span class="line">du /tmp/* 2&gt; /dev/null | sort -n -k1 | tail -3| awk &#x27;&#123;print$2&#125;&#x27;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>tee</code>命令<br> 接收上一条命令的输出,拷贝保存到一个文件中,并把输出传入下一个管道命令的输入<br><img src="/2024/04/27/Linux%E6%8C%87%E4%BB%A4/tee.png" alt="alt text"></li>
</ul>
<h3 id="命名管道FIFOs"><a href="#命名管道FIFOs" class="headerlink" title="命名管道FIFOs"></a>命名管道FIFOs</h3><ul>
<li><p>FIFOs（命名管道）可用于系统上两个进程之间的通信。它们允许两个进程在系统上独立执行时进行通信，而不像普通管道那样只能在同一个进程内进行通信。</p>
</li>
<li><p>FIFOs（命名管道）是在磁盘上创建的，并且有一个类似文件名的名称。这意味着像操作文件一样，必须先创建并打开 FIFOs（命名管道）才能用于进程间通信。</p>
</li>
<li><p>可以在独立执行的程序之间使用 FIFOs（命名管道），这使得它成为进程间跨应用程序通信的一种有效方式。</p>
</li>
</ul>
<h4 id="FIFOs的使用"><a href="#FIFOs的使用" class="headerlink" title="FIFOs的使用"></a>FIFOs的使用</h4><ul>
<li><code>mkfifo [option] file-list</code>创建命名管道命令<ul>
<li><code>-m 八进制权限数</code> 参数用来设定管道文件的权限<br><img src="/2024/04/27/Linux%E6%8C%87%E4%BB%A4/fifo.png" alt="alt text"></li>
</ul>
</li>
</ul>
<h2 id="第十章-进程Processing"><a href="#第十章-进程Processing" class="headerlink" title="第十章 进程Processing"></a>第十章 进程Processing</h2><ul>
<li><code>进程</code>就是程序的一次运行</li>
<li>A process is a program in execution</li>
<li>A process is created every time you run an external command and is removed after the command finishes its execution</li>
</ul>
<h3 id="进程调度方式"><a href="#进程调度方式" class="headerlink" title="进程调度方式"></a>进程调度方式</h3><ul>
<li>先来先服务（FCFS）调度算法</li>
<li>短作业优先（SJF）调度算法</li>
<li>优先级调度算法</li>
<li>多优先级队列</li>
<li>高响应比优先调度算法</li>
<li>时间片轮转调度算法</li>
<li>多级反馈队列调度算法</li>
</ul>
<h3 id="Linux下的进程"><a href="#Linux下的进程" class="headerlink" title="Linux下的进程"></a>Linux下的进程</h3><p>Linux系统采用多级优先队列的方式</p>
<p><strong>1. Processor Scheduler（处理器调度器）</strong></p>
<ul>
<li><p><strong>定义</strong>：</p>
<ul>
<li>处理器调度器是操作系统中负责实现CPU调度算法的代码部分。</li>
</ul>
</li>
<li><p><strong>功能</strong>：</p>
<ul>
<li>确定下一个要运行哪个进程。</li>
<li>考虑多种因素，如进程优先级、等待时间、I&#x2F;O需求等。</li>
</ul>
</li>
<li><p><strong>目标</strong>：</p>
<ul>
<li>确保系统资源的公平分配。</li>
<li>提高系统的吞吐量和响应速度。</li>
</ul>
</li>
</ul>
<p><strong>2. Dispatcher（调度器）</strong></p>
<ul>
<li><p><strong>定义</strong>：</p>
<ul>
<li>调度器是操作系统中负责将CPU控制权从当前进程转移到新调度进程的组件。</li>
</ul>
</li>
<li><p><strong>功能</strong>：</p>
<ul>
<li>停止当前进程的执行。</li>
<li>保存当前进程的上下文（如程序计数器、寄存器状态等）。</li>
<li>加载新进程的上下文。</li>
<li>将新进程置于就绪状态，以便其可以开始执行。</li>
</ul>
</li>
<li><p><strong>要求</strong>：</p>
<ul>
<li>上下文切换过程需要快速且准确，以确保系统的稳定性和性能。</li>
</ul>
</li>
</ul>
<p><strong>3. 进程优先级值计算</strong></p>
<ul>
<li><p><strong>影响因素</strong>：</p>
<ul>
<li>Nice值：一个介于-20（最高优先级）和19（最低优先级）之间的整数。</li>
<li>CPU使用情况：进程占用的CPU资源量。</li>
</ul>
</li>
<li><p><strong>调整方式</strong>：</p>
<ul>
<li>用户可以使用<code>nice</code>命令或<code>renice</code>命令来调整进程的Nice值。</li>
<li>操作系统根据进程的CPU使用情况动态地调整其优先级值。</li>
</ul>
</li>
<li><p><strong>目的</strong>：</p>
<ul>
<li>确保所有进程能够公平地获得CPU资源。</li>
<li>防止某个进程长时间占用过多CPU资源，影响其他进程的执行。</li>
</ul>
</li>
<li><p>怎么改变Nice_Value值</p>
<ul>
<li><code>nice -n nice_value</code>命令</li>
</ul>
</li>
</ul>
<h3 id="进程相关命令"><a href="#进程相关命令" class="headerlink" title="进程相关命令"></a>进程相关命令</h3><ul>
<li><code>ps</code>命令<ul>
<li><code>-l</code>参数: 显示详细信息</li>
<li><code>-e</code>选项: 显示系统中所有进程</li>
</ul>
</li>
</ul>
<p><img src="/2024/04/27/Linux%E6%8C%87%E4%BB%A4/ps.png" alt="alt text"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改进程优先级(普通用户只能降低优先级---&gt;给nice_value赋正值)</span></span><br><span class="line">nice -n -20 ps -l </span><br></pre></td></tr></table></figure>
<p><img src="/2024/04/27/Linux%E6%8C%87%E4%BB%A4/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6.png" alt="alt text"></p>
<p><strong>Shell命令</strong>可以是内部的（内建的）或外部的。</p>
<ul>
<li><p><strong>内部（内建）命令</strong>：这些命令的代码是shell进程的一部分。内部命令直接由shell解释和执行，不需要创建新的进程。您列举的内部命令包括<code>bg</code>（将后台暂停的任务继续执行）、<code>cd</code>（更改目录）、<code>continue</code>（在循环中跳过当前迭代的剩余部分）、<code>echo</code>（在终端显示文本或将文本写入文件）、<code>exec</code>（替换当前shell进程为新的进程）。</p>
</li>
<li><p><strong>外部命令</strong>：这些命令的代码存储在文件中，文件内容可以是二进制代码或shell脚本。外部命令需要shell创建一个新的子进程来执行。您列举的外部命令包括<code>grep</code>（搜索文件中的文本模式）、<code>more</code>（分页查看文件内容）、<code>cat</code>（连接并打印文件内容）、<code>mkdir</code>（创建目录）、<code>rmdir</code>（删除空目录）和<code>ls</code>（列出目录内容）。</p>
</li>
</ul>
<p>在UNIX系统中，一个进程可以通过使用<strong>fork系统调用</strong>来创建另一个进程。这个系统调用会创建一个与原始进程完全相同的内存映射。</p>
<ul>
<li><strong>父进程</strong>：执行fork系统调用的原始进程被称为父进程。</li>
<li><strong>子进程</strong>：通过fork系统调用创建的新进程被称为子进程。</li>
</ul>
<p>可以使用type命令来查看是内部命令还是外部命令</p>
<ul>
<li><code>type</code>命令</li>
</ul>
<p><img src="/2024/04/27/Linux%E6%8C%87%E4%BB%A4/type.png" alt="alt text"></p>
<h3 id="shell环境下执行命令"><a href="#shell环境下执行命令" class="headerlink" title="shell环境下执行命令"></a>shell环境下执行命令</h3><ul>
<li>命令执行</li>
</ul>
<p>在Linux下，Bash执行外部命令的过程涉及多个步骤。以下是该过程的大致描述：</p>
<ol>
<li><p><strong>命令输入</strong>：</p>
<ul>
<li>用户在Bash shell中输入一个命令，例如<code>ls</code>。</li>
</ul>
</li>
<li><p><strong>词法分析</strong>：</p>
<ul>
<li>Bash首先对输入的命令进行词法分析，将命令分解为单词或标记（tokens），例如命令名、选项、参数等。</li>
</ul>
</li>
<li><p><strong>路径搜索</strong>：</p>
<ul>
<li>Bash需要确定输入的是内部命令（如<code>cd</code>、<code>echo</code>等Bash内置的命令）还是外部命令。</li>
<li>对于外部命令，Bash会在环境变量<code>PATH</code>指定的目录中搜索该命令的可执行文件。<code>PATH</code>环境变量包含了一系列用冒号分隔的目录路径，Bash会按照这些路径的顺序进行搜索。</li>
</ul>
</li>
<li><p><strong>创建子进程</strong>：</p>
<ul>
<li>一旦找到可执行文件，Bash会使用<code>fork()</code>系统调用来创建一个新的子进程。这个子进程是当前Bash进程的副本，它将用于执行外部命令。</li>
</ul>
</li>
<li><p><strong>执行外部命令</strong>：</p>
<ul>
<li>在子进程中，Bash使用<code>exec()</code>系统调用来替换当前进程的映像为外部命令的可执行文件映像，从而开始执行该命令。</li>
<li><code>exec()</code>调用会导致子进程完全变成另一个程序（即外部命令），执行完毕后不会返回到原Bash进程，除非遇到错误或外部命令执行完成。</li>
</ul>
</li>
<li><p><strong>等待命令完成</strong>：</p>
<ul>
<li>父进程（即原始的Bash进程）会等待子进程（执行外部命令的进程）完成。这通常是通过<code>wait()</code>系统调用来实现的，它允许父进程挂起执行，直到子进程结束。</li>
</ul>
</li>
<li><p><strong>处理命令输出</strong>：</p>
<ul>
<li>外部命令执行过程中可能会产生标准输出（stdout）和标准错误输出（stderr）。这些输出通常会被打印到终端上，除非用户通过重定向（<code>&gt;</code>、<code>&gt;&gt;</code>、<code>2&gt;</code>等）或管道（<code>|</code>）改变了输出的方向。</li>
</ul>
</li>
<li><p><strong>命令结束</strong>：</p>
<ul>
<li>当外部命令执行完毕后，控制权会返回到Bash进程。如果命令成功执行，Bash通常会返回一个成功的退出状态（通常是0）；如果命令执行失败，则会返回一个非零的退出状态。</li>
</ul>
</li>
</ol>
<ul>
<li><p>脚本文件执行<br><img src="/2024/04/27/Linux%E6%8C%87%E4%BB%A4/script.png" alt="alt text"></p>
</li>
<li><p><code>top</code>命令<br>动态实时的显示系统中进程变化<br><img src="/2024/04/27/Linux%E6%8C%87%E4%BB%A4/top.png" alt="alt text"></p>
<ul>
<li><code>d</code>: 按D键切换刷新时间</li>
<li><code>h</code>: 显示可选项</li>
<li><code>q</code>: 退出</li>
</ul>
</li>
<li><p><code>pstree</code>命令<br>用树的方式显示进程之间的关系</p>
</li>
</ul>
<h3 id="对进程进行控制"><a href="#对进程进行控制" class="headerlink" title="对进程进行控制"></a>对进程进行控制</h3><p>前台进程的概念:<br>   前台进程是与用户直接交互的进程。以下是对前台进程的详细解释：</p>
<ol>
<li><strong>定义</strong>：前台进程指的是那些当前正在与用户进行直接交互的进程。这类进程通常位于屏幕的最前端，接收用户的输入并显示输出结果。</li>
<li><strong>特性</strong>：<ul>
<li>交互性：前台进程能够直接响应用户的操作，如点击、输入等。</li>
<li>阻塞性：当一个前台进程正在运行时，它通常会阻塞用户终端，意味着用户无法进行其他操作，直到该进程完成。</li>
<li>单一性：在任何时刻，通常只有一个进程（或进程组）可以在前台运行。</li>
</ul>
</li>
<li><strong>与后台进程的区别</strong>：与前台进程不同，后台进程在后台运行，不会阻塞用户终端，允许用户在同一终端启动新的前台或后台进程。后台进虽&gt;然可以向终端发送输出，但通常不能从终端接收输入。</li>
<li><strong>操作系统中的表现</strong>：在Unix-like操作系统中，用户可以通过特定的命令在前台和后台之间切换进程。</li>
<li><strong>实例</strong>：以Oracle数据库为例，当用户运行一个应用进程时，系统会为该应用建立一个服务进程，这个服务进程可以被视为前台进程，用于处理连接到数据库实例的用户进程的请求。</li>
<li><strong>其他系统中的应用</strong>：在Android系统中，前台进程也是极其重要的，它代表当前正在与用户交互的应用程序。这类进程在系统资源分配中通常享有优先级，以确保流畅的用户体验。<br>   总的来说，前台进程是计算机系统中直接与用户进行交互的进程，它具有高度的交互性和实时性要求。在不同的操作系统和应用场景中，前台进程的具体表现和管理方式可能会有所不同。</li>
</ol>
<ul>
<li>执行命令时指定其为后台进程<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/tmp/loop &amp;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">此时后台进程loop不断输出数字,按CTRL+C无效,因为是后台进程</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>jobs命令</strong>是Linux系统中的一个内置命令，它用于显示当前shell中正在运行或已经挂起的任务列表。</p>
<ol>
<li><p><strong>基本功能</strong>：</p>
<ul>
<li>显示当前shell中所有正在运行或挂起的任务。</li>
<li>通过任务编号、状态、进程编号和任务名称来展示任务信息。</li>
</ul>
</li>
<li><p><strong>常用操作</strong>：</p>
<ul>
<li>使用<code>jobs</code>命令直接查看任务列表。</li>
<li><code>fg [%n]</code>用于将后台执行的进程调到前台。</li>
<li><code>bg [%n]</code>用于将后台暂停的进程继续运行。</li>
<li><code>Ctrl+Z</code>可以将当前正在运行的前台进程暂停，并将其移动到后台。</li>
</ul>
</li>
<li><p><strong>任务状态</strong>：</p>
<ul>
<li>任务的状态可以是停止状态(S)、运行状态(R)或已完成状态(D)。</li>
</ul>
</li>
<li><p><strong>命令参数</strong>：</p>
<ul>
<li><code>-l</code>选项：显示详细的任务信息，包括进程ID（PID）、状态、作业编号、命令和进程组ID。</li>
<li><code>-n</code>选项：只显示上次显示过的已经停止的或已经退出的作业。</li>
<li><code>-p</code>选项：仅显示选定作业的进程组的进程ID。</li>
<li><code>-r</code>选项：仅显示正在运行的作业。</li>
<li><code>-s</code>选项：仅显示停止的作业。</li>
</ul>
</li>
<li><p><strong>使用场景</strong>：</p>
<ul>
<li>当你在终端中运行了多个命令或脚本，并且想要查看或管理这些任务时，可以使用jobs命令。</li>
<li>特别是当你需要切换任务的执行前后台，或者查看哪些任务正在运行、哪些已经暂停时，jobs命令会非常有用。</li>
</ul>
</li>
</ol>
<p><img src="/2024/04/27/Linux%E6%8C%87%E4%BB%A4/loop.png" alt="alt text"></p>
<ul>
<li><code>fg</code><br>   把后台进程变成前台进程<ul>
<li>默认把带<code>+</code>的进程调到前台</li>
<li><code>%1</code>: 指定把哪个(进程id)进程变成前台进程</li>
</ul>
</li>
</ul>
<p><img src="/2024/04/27/Linux%E6%8C%87%E4%BB%A4/fg.png" alt="alt text"></p>
<ul>
<li><code>bg</code><br>   挂起前台任务使用<code>CTRL+Z</code>，<code>bg</code>命令来把后台挂起的任务唤醒</li>
</ul>
<h3 id="命令的顺序和并行执行（Sequential-and-Parallel-Execution-of-Commands）"><a href="#命令的顺序和并行执行（Sequential-and-Parallel-Execution-of-Commands）" class="headerlink" title="命令的顺序和并行执行（Sequential and Parallel Execution of Commands）"></a>命令的顺序和并行执行（Sequential and Parallel Execution of Commands）</h3><ul>
<li>串行: cmd1 ; cmd2</li>
<li>并行: cmd1 &amp; cmd2</li>
</ul>
<p><img src="/2024/04/27/Linux%E6%8C%87%E4%BB%A4/%E5%91%BD%E4%BB%A4%E4%B8%B2%E5%B9%B6%E8%A1%8C.png" alt="alt text"></p>
<h3 id="如何终止进程"><a href="#如何终止进程" class="headerlink" title="如何终止进程"></a>如何终止进程</h3><ul>
<li>终止前台进程<ul>
<li>CTRL+C</li>
</ul>
</li>
<li>终止后台进程<ul>
<li><code>kill</code>命令<br><img src="/2024/04/27/Linux%E6%8C%87%E4%BB%A4/kill.png" alt="alt text"></li>
</ul>
</li>
</ul>
<h4 id="kill命令"><a href="#kill命令" class="headerlink" title="kill命令"></a><code>kill</code>命令</h4><p><code>kill</code> 命令在 Unix 和 Linux 系统中用于向进程发送信号。其基本语法是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> [-信号编号] 进程ID</span><br></pre></td></tr></table></figure>

<ul>
<li><code>信号编号</code> 是一个可选参数，用于指定要发送给进程的信号。如果省略，则默认信号是 SIGTERM（软件终止信号，通常为编号 15）。</li>
<li><code>进程ID</code> 是要发送信号的进程的 ID。</li>
</ul>
<p><code>kill -l</code> 命令会列出所有可用的信号。</p>
<p>目的：将 <code>信号编号</code> 指定的信号发送给 <code>proc-list</code> 中指定的进程ID（PID）对应的进程。作业ID通常用于 shell 作业控制，必须以 <code>%</code> 符号开头。</p>
<p><code>kill -l</code> 命令返回所有信号及其名称的列表。在某些系统上，信号编号可能不会与名称一起显示。</p>
<p>常用的信号编号包括：</p>
<ul>
<li>HUP（挂起，通常为信号编号 1）</li>
<li>INT（中断，通常由按 Ctrl+C 发送，信号编号 2）</li>
<li>QUIT（退出，通常由按 Ctrl+\ 发送，信号编号 3）</li>
<li>KILL（强制杀死，信号编号 9）</li>
<li>TERM（软件信号，如果没有指定则为默认信号，通常为编号 15）</li>
</ul>
<p>请注意，向进程发送某些信号，尤其是 KILL（信号 9），应该谨慎进行，因为它可以在不给进程机会适当清理资源的情况下突然终止进程。</p>
<p>如果你想向多个进程发送信号，可以通过空格分隔指定多个 PID，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -SIGTERM 1234 5678 9012</span><br></pre></td></tr></table></figure>

<p>此命令将 SIGTERM 信号发送给 PID 为 1234、5678 和 9012 的进程。</p>
<h4 id="信号的处理"><a href="#信号的处理" class="headerlink" title="信号的处理"></a>信号的处理</h4><p>命令和进程的异常终止（续）</p>
<p><code>kill</code>命令的主要目的是向进程发送信号（软件中断）。进程在接收到信号时可以采取以下三种行动之一：</p>
<ol>
<li>接受由UNIX内核决定的默认操作。</li>
<li>忽略该信号。</li>
<li>拦截信号并执行用户定义的操作。</li>
</ol>
<p>由进程内部事件引起的信号被称为内部信号或陷阱（trap）。由进程外部事件引起的信号被称为外部信号。</p>
<h2 id="第十一章-Shell脚本编程"><a href="#第十一章-Shell脚本编程" class="headerlink" title="第十一章 Shell脚本编程"></a>第十一章 Shell脚本编程</h2><ol>
<li><p><strong>Shell Script (Shell 程序)</strong>:</p>
<ul>
<li>一个Shell脚本是一个包含一系列Shell命令的文本文件。这些命令可以由Shell（如bash, zsh, sh等）解释并执行。</li>
<li>Shell脚本通常用于自动化任务和简化复杂的命令序列。</li>
</ul>
</li>
<li><p><strong>Shell Variable (Shell 变量)</strong>:</p>
<ul>
<li>Shell变量是用户或程序员在Shell环境中用于存储和引用数据的机制。</li>
<li>变量可以存储字符串、数字或其他数据类型（取决于Shell）。</li>
<li>Shell变量通常用于在脚本中传递和存储数据，以及动态地构建命令。</li>
</ul>
</li>
<li><p><strong>Program Control Flow Commands (程序控制流命令)</strong>:</p>
<ul>
<li>这些命令允许在Shell脚本中执行非顺序的命令，以及重复执行命令块。</li>
<li>常见的控制流命令包括<code>if</code>、<code>for</code>、<code>while</code>、<code>until</code>、<code>case</code>等。</li>
<li>这些命令使得脚本能够基于条件执行不同的命令序列，或者重复执行某个命令块，直到满足某个条件为止。</li>
</ul>
</li>
</ol>
<p>总结：Shell脚本是包含一系列Shell命令的文本文件，用于自动化任务和简化命令序列。Shell变量用于存储和引用数据，而程序控制流命令则允许在脚本中执行非顺序的命令和重复执行命令块。</p>
<p>Shell脚本也是一种编程语言(解释型)<br>编程语言分为两种</p>
<ul>
<li>编译型: 如C++这种,通过g++先生成可执行文件</li>
<li>解释型: python或java,读一行命令,解释执行一行</li>
</ul>
<p><img src="/2024/04/27/Linux%E6%8C%87%E4%BB%A4/shellscript.png" alt="alt text"></p>
<h3 id="编写shell脚本"><a href="#编写shell脚本" class="headerlink" title="编写shell脚本"></a>编写shell脚本</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim first.sh</span><br><span class="line"></span><br><span class="line">date</span><br><span class="line">echo &quot;Hello world&quot;</span><br></pre></td></tr></table></figure>
<p>shell脚本有三种执行方式</p>
<ol>
<li><code>bash first.sh</code> 指定运行shell来执行脚本</li>
<li><code>first.sh</code> 直接执行shell脚本</li>
<li><code>. first.sh</code>或<code>source first.sh</code></li>
</ol>
<ul>
<li>在脚本文件第一行指定shell环境<code>#! /bin/bash</code>表示把<code>/bin/bash</code>程序加载进来,由它来解释执行脚本文件<br><img src="/2024/04/27/Linux%E6%8C%87%E4%BB%A4/%E6%8C%87%E5%AE%9A%E8%84%9A%E6%9C%AC%E8%A7%A3%E9%87%8A%E5%99%A8.png" alt="alt text"></li>
</ul>
<h3 id="shell变量分类及操作"><a href="#shell变量分类及操作" class="headerlink" title="shell变量分类及操作"></a>shell变量分类及操作</h3><ul>
<li>环境变量(子进程无法修改父进程的环境变量)<br> 使用<code>env</code>命令直接显示环境变量</li>
<li>用户自定义变量</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">! /usr/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">定义变量,不能加空格</span></span><br><span class="line">nam=&quot;Jack&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不能使用双引号</span></span><br><span class="line">echo &quot;Hello, $nam&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>readonly</code>: 把一个变量变成只读</li>
<li><code>export</code>: 把一个用户定义变量变成环境变量</li>
<li><code>source</code>: 允许脚本修改环境变量值(使用<code>source</code>或者<code>.</code>执行脚本文件时,不会再创建子进程来执行,使用当前shell进程来解释执行脚本)<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">! /usr/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置父(当前)进程环境变量值</span></span><br><span class="line">PS1=&#x27;Study Hard/$&#x27;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行时使用 . first.sh  或者 <span class="built_in">source</span> first.sh</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="内置的环境变量"><a href="#内置的环境变量" class="headerlink" title="内置的环境变量"></a>内置的环境变量</h3><ol>
<li><p><code>PATH</code></p>
<ul>
<li><strong>Purpose</strong>: 包含目录名称的列表，shell在查找外部命令或程序时会搜索这些目录。</li>
<li><strong>Default</strong>: 通常包括<code>/usr/bin</code>, <code>/bin</code>, <code>/usr/local/bin</code>等目录。</li>
</ul>
</li>
<li><p><code>EDITOR</code></p>
<ul>
<li><strong>Purpose</strong>: 指定默认文本编辑器，如<code>vi</code>, <code>nano</code>, <code>emacs</code>等。</li>
<li><strong>Default</strong>: 根据系统配置和用户偏好而定。</li>
</ul>
</li>
<li><p><code>ENV</code></p>
<ul>
<li><strong>Purpose</strong>: 指定shell启动时要读取的初始化文件。在某些shell中，如<code>ksh</code>，它可能用于指定环境设置文件。</li>
<li><strong>Default</strong>: 通常不设置，但在某些shell配置中可能使用。</li>
</ul>
</li>
<li><p><code>HOME</code></p>
<ul>
<li><strong>Purpose</strong>: 用户的主目录路径。当用户首次登录时，shell通常会切换到这个目录。</li>
<li><strong>Default</strong>: <code>/home/username</code>（其中<code>username</code>是用户的登录名）。</li>
</ul>
</li>
<li><p><code>MAIL</code></p>
<ul>
<li><strong>Purpose</strong>: 用户的系统邮箱文件的路径。当有新邮件时，某些shell会显示通知。</li>
<li><strong>Default</strong>: <code>/var/spool/mail/username</code>（其中<code>username</code>是用户的登录名）。</li>
</ul>
</li>
<li><p><code>MAILCHECK</code></p>
<ul>
<li><strong>Purpose</strong>: 指定shell检查用户邮箱以查找新邮件的频率（以秒为单位）。</li>
<li><strong>Default</strong>: 通常设置为60秒，但可能因系统而异。</li>
</ul>
</li>
<li><p><code>PPID</code></p>
<ul>
<li><strong>Purpose</strong>: 当前进程的父进程ID（PID）。这不是一个通常设置的环境变量，而是可以通过shell命令（如<code>$!</code>或<code>$PPID</code>在某些shell中）或程序内部API获取的。</li>
<li><strong>Default</strong>: 由操作系统在进程创建时设置。</li>
</ul>
</li>
<li><p><code>PS1</code></p>
<ul>
<li><strong>Purpose</strong>: 主shell提示符，显示在命令行上。</li>
<li><strong>Default</strong>: 通常设置为类似<code>$</code>或<code>#</code>（对于root用户）的字符，但用户可以通过修改<code>.bashrc</code>、<code>.bash_profile</code>等文件来定制它。</li>
</ul>
</li>
<li><p><code>PWD</code></p>
<ul>
<li><strong>Purpose</strong>: 当前工作目录的路径。</li>
<li><strong>Default</strong>: 由shell在每次更改目录时设置。</li>
</ul>
</li>
<li><p><code>TERM</code></p>
<ul>
<li><strong>Purpose</strong>: 终端类型。它告诉应用程序（如文本编辑器、终端仿真器等）关于终端的功能和特性。</li>
<li><strong>Default</strong>: 根据用户使用的终端仿真器而定，如<code>xterm</code>, <code>vt100</code>, <code>linux</code>等。</li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th>变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>$0</code></td>
<td>程序的名称</td>
</tr>
<tr>
<td><code>$1 - $9</code></td>
<td>命令行参数1到9的值</td>
</tr>
<tr>
<td><code>$@</code></td>
<td>所有命令行参数的值</td>
</tr>
<tr>
<td><code>$*</code></td>
<td>所有命令行参数的值,单一字符串<code>&quot;a b c d&quot;</code></td>
</tr>
<tr>
<td><code>&quot;$@&quot;</code></td>
<td>所有命令行参数的值；每个参数都单独引用 <code>&quot;a&quot; &quot;b&quot; &quot;c&quot; &#39;d&quot;</code></td>
</tr>
<tr>
<td><code>$#</code></td>
<td>命令行参数的总数</td>
</tr>
<tr>
<td><code>$$</code></td>
<td>当前进程的进程ID（PID）</td>
</tr>
<tr>
<td><code>$?</code></td>
<td>最近命令的退出状态,执行成功返回值0</td>
</tr>
<tr>
<td><code>$!</code></td>
<td>最近后台进程的PID</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Study Hard:$cat first.sh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo $0</span><br><span class="line">echo $1</span><br><span class="line">echo $2</span><br><span class="line"></span><br><span class="line">Study Hard:$first.sh a b c</span><br><span class="line"></span><br><span class="line">./first.sh</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line"></span><br><span class="line">Study Hard:$vim first.sh</span><br><span class="line">Study Hard:$cat first.sh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bashecho <span class="variable">$1</span></span></span><br><span class="line"></span><br><span class="line">Study Hard:$first.sh Tom</span><br><span class="line">Tom</span><br></pre></td></tr></table></figure>
<h3 id="shell变量的数据类型"><a href="#shell变量的数据类型" class="headerlink" title="shell变量的数据类型"></a>shell变量的数据类型</h3><p><strong>变量声明</strong></p>
<p><strong>语法：</strong></p>
<ul>
<li><code>declare [选项][名称[=值]]</code></li>
<li><code>typeset [选项][名称[=值]]</code></li>
</ul>
<p><strong>目的：</strong><br>声明变量并初始化它们，设置它们的属性。在函数内部，会创建新的变量副本。使用<code>+</code>代替<code>-</code>关闭属性。</p>
<p><strong>输出：</strong></p>
<ul>
<li>没有名称和选项时，在当前shell环境中显示所有shell变量的名称和值。</li>
<li>使用选项时，显示具有特定属性的变量名称和其值。</li>
</ul>
<p><strong>常用选项&#x2F;特性：</strong></p>
<ul>
<li><code>-a</code>：将每个“名称”标记为数组</li>
<li><code>-f</code>：将每个“名称”标记为函数</li>
<li><code>-i</code>：将“名称”标记为整数</li>
<li><code>-r</code>：将“名称”标记为只读（无法通过<code>+x</code>关闭）</li>
<li><code>-x</code>：将“名称”标记为环境变量</li>
</ul>
<p>shell变量被默认为是字符串类型</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input: a=1</span><br><span class="line">Input: b=2</span><br><span class="line">Input: c=$a+$b</span><br><span class="line">Input: echo $c</span><br><span class="line"></span><br><span class="line">Output: 1+2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">正确输出加法公式</span></span><br><span class="line">Input: declare -i z</span><br><span class="line">Input: z=a+b</span><br><span class="line">Iuput: echo $z</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>


<h3 id="命令替换-把命令结果存储成变量"><a href="#命令替换-把命令结果存储成变量" class="headerlink" title="命令替换(把命令结果存储成变量)"></a>命令替换(把命令结果存储成变量)</h3><ul>
<li><strong>变量名&#x3D;`cmd`</strong></li>
</ul>
<p><img src="/2024/04/27/Linux%E6%8C%87%E4%BB%A4/%E5%91%BD%E4%BB%A4%E6%9B%BF%E6%8D%A2.png" alt="alt text"></p>
<h3 id="变量的输入输出"><a href="#变量的输入输出" class="headerlink" title="变量的输入输出"></a>变量的输入输出</h3><h4 id="变量的输入"><a href="#变量的输入" class="headerlink" title="变量的输入"></a>变量的输入</h4><p><code>read</code> 是一个在Linux中常用的命令，用于从标准输入或其他文件描述符中读取输入并赋值给变量。它的基本语法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span> [选项] 变量名(列表)</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>选项</code> 是可选的，可以用来指定read命令的特定行为。</li>
<li><code>变量名</code> 是要将输入赋值给的变量。</li>
</ul>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Please enter your name:&quot;</span></span><br><span class="line"><span class="built_in">read</span> name</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello, <span class="variable">$name</span>. Welcome!&quot;</span></span><br></pre></td></tr></table></figure>

<p>在这个示例中，当用户输入其名字并按下回车后，<code>read</code> 命令将输入的内容赋值给变量 <code>name</code>，然后 <code>echo</code> 命令使用这个变量进行输出。</p>
<p>常用选项包括：</p>
<ul>
<li><code>-p</code> ：用于显示提示信息而不是使用<code>echo</code>命令来显示。</li>
<li><code>-a</code> ：将输入分配到数组而不是普通变量。</li>
<li><code>-n</code> ：限制输入的字符数。</li>
<li><code>-s</code> ：用于静默模式，输入时不显示在屏幕上。</li>
<li><code>-t</code> ：设置等待时间，如果超过指定秒数没有输入，则读取终止。</li>
</ul>
<p><img src="/2024/04/27/Linux%E6%8C%87%E4%BB%A4/read.png" alt="alt text"></p>
<h4 id="变量的输出-echo"><a href="#变量的输出-echo" class="headerlink" title="变量的输出-&gt;echo"></a>变量的输出-&gt;<code>echo</code></h4><p><code>echo</code> 命令用于在终端中显示文本或变量的内容。它的基本语法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> [选项] [字符串或变量]</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>[选项]</code> 是可选的，可以用来指定特定行为，比如 <code>-e</code> 用于解释转义字符。</li>
<li><code>[字符串或变量]</code> 是要显示的文本或变量的内容。</li>
</ul>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello, World!&quot;</span></span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>echo</code> 命令会在终端中显示 “Hello, World!”。</p>
<p>常用选项包括：</p>
<ul>
<li><code>-e</code> ：允许使用反斜杠转义字符。</li>
<li><code>-n</code> ：不在结尾添加换行符。</li>
<li><code>-E</code> ：关闭反斜杠转义功能，将反斜杠字符输出为原始字符。</li>
<li><code>&gt;&gt; 文件</code> ：将输出追加到指定文件。</li>
<li><code>-E</code> ：关闭 <code>-e</code> 选项开启的转义字符解释功能。</li>
</ul>
<h3 id="对数值进行处理"><a href="#对数值进行处理" class="headerlink" title="对数值进行处理"></a>对数值进行处理</h3><p>因为shell变量被默认为是字符串类型</p>
<h4 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h4><ul>
<li><code>declare</code></li>
<li><code>expr 表达式</code></li>
<li><code>let</code>命令<br><img src="/2024/04/27/Linux%E6%8C%87%E4%BB%A4/expr&let.png" alt="alt text"></li>
</ul>
<h4 id="小数"><a href="#小数" class="headerlink" title="小数"></a>小数</h4><ul>
<li><code>bc</code>命令: 默认从标准输入读取小数<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a=1.1</span><br><span class="line">b=2.1</span><br><span class="line">echo $a + $b | bc</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从标准输出中通过管道变成标准输入在交给bc命令</span></span><br><span class="line"></span><br><span class="line">Output: 3.2</span><br></pre></td></tr></table></figure></li>
</ul>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>0zxm</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="https://0zxm.github.io/2024/04/27/Linux%E6%8C%87%E4%BB%A4/">https://0zxm.github.io/2024/04/27/Linux%E6%8C%87%E4%BB%A4/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Do you believe in <strong>DESTINY</strong>?</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/Linux/"># Linux</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2024/05/20/VisualStudio-with-Mysql/">VisualStudio with Mysql</a>
            
            
            <a class="next" rel="next" href="/2024/03/20/css/">css</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© 0zxm | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>