<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>cpp11新特性 | 0zxm</title><meta name="author" content="0zxm"><meta name="copyright" content="0zxm"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="c++11版本语法的新特性">
<meta property="og:type" content="article">
<meta property="og:title" content="cpp11新特性">
<meta property="og:url" content="https://0zxm.github.io/2024/12/25/cpp11-xin-te-xing/index.html">
<meta property="og:site_name" content="0zxm">
<meta property="og:description" content="c++11版本语法的新特性">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://0zxm.github.io/img/default_cover.jpg">
<meta property="article:published_time" content="2024-12-25T12:52:06.000Z">
<meta property="article:modified_time" content="2025-03-07T15:14:00.080Z">
<meta property="article:author" content="0zxm">
<meta property="article:tag" content="c++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://0zxm.github.io/img/default_cover.jpg"><link rel="shortcut icon" href="/favicon.png"><link rel="canonical" href="https://0zxm.github.io/2024/12/25/cpp11-xin-te-xing/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        if (name && globalFn[key][name]) return
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"prismjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: 0zxm","link":"链接: ","source":"来源: 0zxm","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'cpp11新特性',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-03-07 23:14:00'
}</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/favicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">57</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">65</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/src/"><i class="fa-fw fas fa-cloud"></i><span> 资源</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo/"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/default_cover.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">0zxm</span></a><a class="nav-page-title" href="/"><span class="site-name">cpp11新特性</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/src/"><i class="fa-fw fas fa-cloud"></i><span> 资源</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo/"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">cpp11新特性</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-12-25T12:52:06.000Z" title="发表于 2024-12-25 20:52:06">2024-12-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-07T15:14:00.080Z" title="更新于 2025-03-07 23:14:00">2025-03-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/c/">c++</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">52.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>201分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1bX4y1G7ks/">bilibili教程</a></p>
<p><a target="_blank" rel="noopener" href="https://subingwen.cn/cpp/constexpr/#1-1-const">部分引用自爱编程的大丙</a></p>
<h2 id="1-c-原始字面量"><a href="#1-c-原始字面量" class="headerlink" title="1.c++原始字面量"></a>1.c++原始字面量</h2><h3 id="1-1-什么是字面量"><a href="#1-1-什么是字面量" class="headerlink" title="1.1 什么是字面量"></a>1.1 什么是字面量</h3><p>在编程语言中，“字面量”（Literal）是指在源代码中直接表示某一固定值的符号。字面量是编程语言中最基本的数据表示方式之一，它们是编译时已知的常量值，不需要通过变量或其他表达式计算得到。以下是一些常见的字面量类型：</p>
<ol>
<li><p><strong>数值字面量</strong>：直接表示数字的字面量，如整数、浮点数等。</p>
<ul>
<li>整数：<code>123</code>，<code>0xFF</code>（十六进制），<code>0b1010</code>（二进制）等。</li>
<li>浮点数：<code>3.14</code>，<code>2.5e-3</code>（科学记数法）等。</li>
</ul>
</li>
<li><p><strong>字符字面量</strong>：用单引号括起来的单个字符，如 <code>&#39;A&#39;</code>、<code>&#39;5&#39;</code>、<code>&#39;\n&#39;</code>（换行符）等。</p>
</li>
<li><p><strong>字符串字面量</strong>：用双引号括起来的字符序列，如 <code>&quot;Hello, World!&quot;</code>。</p>
</li>
<li><p><strong>布尔字面量</strong>：表示逻辑值的字面量，如 <code>true</code> 和 <code>false</code>。</p>
</li>
<li><p><strong>空字面量</strong>：表示空值的字面量，如 C++11 中的 <code>nullptr</code>。</p>
</li>
<li><p><strong>复合字面量</strong>：某些语言支持复合字面量，如数组或结构体的初始化。</p>
<ul>
<li>数组：<code>int arr[] = &#123;1, 2, 3&#125;;</code></li>
<li>结构体：<code>Point p = &#123;10, 20&#125;;</code></li>
</ul>
</li>
</ol>
<p>字面量在编程中非常重要，因为它们提供了一种简洁的方式来表示和使用常量值。在编译过程中，字面量会被替换为它们对应的值，这有助于提高代码的可读性和效率。</p>
<h3 id="1-2-原始字面量的必要性"><a href="#1-2-原始字面量的必要性" class="headerlink" title="1.2 原始字面量的必要性"></a>1.2 原始字面量的必要性</h3><p><code>字符串&quot;h\t&quot;</code>会产生歧义,因为<code>\</code>在c++中是转义字符,<code>\t</code>可以表示制表符,所以输出可能不是你想的预期结果</p>
<ul>
<li>反斜杠可以将原始字符转成有特殊含义的字符,<code>\r</code>,<code>\n</code>,<code>\t</code>分别表示回车,换行以及制表符</li>
<li>反斜杠同样可以将有特殊含义的字符转成原始字符,例如<code>\\t</code>在输出的时候将会被看作一个普通的t来输出</li>
</ul>
<p>所以,使用原始字面量就很有必要了,在c++11及以后的版本中,可以使用<code>R&quot;xxx(你想输出的原始字符串的内容)xxx&quot;</code>来输出不会被转义的字符串常量,其中xxx是对原始字面量的描述,在编译时会被省略.</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    string s1 <span class="token operator">=</span> <span class="token string">"hello \
    world"</span><span class="token punctuation">;</span> <span class="token comment">// 使用连接符连接多个字符串</span>

    string s2 <span class="token operator">=</span> <span class="token raw-string string">R"(hello
    world)"</span><span class="token punctuation">;</span> <span class="token comment">// 使用原始字符串字面量的时候可以不用加连接符,语法不会错</span>

    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token raw-string string">R"(h\ello world)"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>           <span class="token comment">// 原始字面量</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token raw-string string">R"hello(h\ello world)hello"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 描述内容必须一样,并且不能为中文</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"h\t"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>                                 <span class="token comment">// 不使用原始字面量</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"h\\t"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>                                <span class="token comment">// 使用两个反斜杠转义</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="2-指针空值类型nullptr"><a href="#2-指针空值类型nullptr" class="headerlink" title="2.指针空值类型nullptr"></a>2.指针空值类型nullptr</h2><p><code>NULL</code> 是一个在 C 和 C++ 编程语言中广泛使用的宏定义，它表示一个空指针常量，即一个不指向任何对象或函数的指针。<code>NULL</code> 的值通常是 <code>0</code>（在大多数平台上），但这个定义允许编译器和运行时系统识别它是一个空指针，而不是一个普通的整数。</p>
<p>在 C 语言中，<code>NULL</code> 被定义在 <code>&lt;stddef.h&gt;</code> 或 <code>&lt;stdlib.h&gt;</code> 头文件中，而在 C++ 中，它被定义在 <code>&lt;cstddef&gt;</code> 或 <code>&lt;cstdlib&gt;</code> 头文件中。<code>NULL</code> 的定义如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NULL</span> <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>或者在 C++ 中：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/* A null pointer constant.  */</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token function">defined</span> <span class="token punctuation">(</span>_STDDEF_H<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">defined</span> <span class="token punctuation">(</span>__need_NULL<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">undef</span> <span class="token expression"><span class="token constant">NULL</span>		</span><span class="token comment">/* in case &lt;stdio.h> has defined it. */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token function">defined</span><span class="token punctuation">(</span>__GNUG__<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> __GNUG__ <span class="token operator">>=</span> <span class="token number">3</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NULL</span> <span class="token expression">__null</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span>   <span class="token comment">/* G++ */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">__cplusplus</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NULL</span> <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span>   <span class="token comment">/* C++ */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">_WIN64</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NULL</span> <span class="token expression"><span class="token number">0</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NULL</span> <span class="token expression"><span class="token number">0LL</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span>  <span class="token comment">/* W64 */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span>  <span class="token comment">/* C++ */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span>  <span class="token comment">/* G++ */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span>	<span class="token comment">/* NULL not defined and &lt;stddef.h> or need NULL.  */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">undef</span>	<span class="token expression">__need_NULL</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在 C++11 及以后的版本中，<code>NULL</code> 被 <code>nullptr</code> 取代，因为 <code>nullptr</code> 是一个类型安全的关键字，它只能被用来表示空指针。<code>nullptr</code> 的类型是 <code>std::nullptr_t</code>，它是一个特殊的指针类型，可以被隐式转换为任何指针类型或引用类型，但不能转换为其他类型。</p>
<p>在给<code>int*</code>变量初始化的时候会被自动转成<code>int*</code>类型</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"func(int p) called"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"func(char* p) called"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token keyword">const</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>ptr1 <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">// 空指针,会被隐式转换</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>ptr1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> ptr1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 输出 0</span>
    <span class="token keyword">double</span> <span class="token operator">*</span>ptr2 <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>ptr3 <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>ptr4 <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token comment">// void * ptr4 = (void *)0;</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>ptr <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span> <span class="token comment">// 自动隐式转换成 "int *" 类型</span>

    <span class="token comment">// int *ptr5 = ptr4;     //"void *" 类型的值不能用于初始化 "int *" 类型的实体C/C++,这在C++11中是不允许的</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>ptr5 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span>ptr4<span class="token punctuation">;</span> <span class="token comment">// 显式类型转换</span>

    <span class="token function">func</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用func(int p)函数</span>
    <span class="token comment">// func(NULL); // 还是使用 func(int p)函数，因为NULL是其实是一个(void *)0</span>

    <span class="token comment">// 所以想调用func(char* p)函数，需要使用nullptr关键字</span>
    <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用func(char* p)函数</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>使用 <code>NULL</code> 或 <code>nullptr</code> 而不是直接使用 <code>0</code> 作为空指针的理由是：</p>
<ol>
<li><strong>类型安全</strong>：<code>NULL</code> 和 <code>nullptr</code> 提供了类型安全的空指针表示，它们明确地告诉编译器这是一个指针值，而不是一个整数。</li>
<li><strong>可移植性</strong>：不同的系统和编译器可能有不同的空指针表示，使用 <code>NULL</code> 或 <code>nullptr</code> 可以确保代码的可移植性。</li>
<li><strong>清晰性</strong>：在代码中使用 <code>NULL</code> 或 <code>nullptr</code> 可以提高代码的可读性，让其他开发者更容易理解代码的意图。</li>
<li><strong>避免歧义</strong>：在某些上下文中，<code>0</code> 可能被解释为整数，而 <code>NULL</code> 或 <code>nullptr</code> 明确表示这是一个空指针。</li>
</ol>
<h3 id="2-1-隐式转换和显式转换的必要"><a href="#2-1-隐式转换和显式转换的必要" class="headerlink" title="2.1 隐式转换和显式转换的必要"></a>2.1 隐式转换和显式转换的必要</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stddef.h></span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression"><span class="token constant">NULL</span></span></span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"NULL is defined as: "</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">NULL</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// NULL is defined as: 0</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>

    <span class="token comment">// void *ptr = NULL;</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>ptr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// ptr就是把0转化为指向void类型的指针,类似于内存0???</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>ptr2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span>ptr<span class="token punctuation">;</span> <span class="token comment">// ptr2就是指向0的int指针</span>
    <span class="token comment">// int *ptr5 = ptr;         // 不合法, 因为ptr5的类型是int*，而ptr的类型是void*,需要进行类型转换</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ptr: "</span> <span class="token operator">&lt;&lt;</span> ptr <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ptr2: "</span> <span class="token operator">&lt;&lt;</span> ptr2 <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token comment">// std::cout &lt;&lt; "ptr5: " &lt;&lt; ptr5 &lt;&lt; std::endl;</span>

    <span class="token keyword">int</span> <span class="token operator">*</span>ptr_i <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">// NULL相当于0</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>ptr_i_ <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression"><span class="token constant">NULL</span></span></span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"NULL is defined as: "</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">NULL</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="3-constexpr新关键字"><a href="#3-constexpr新关键字" class="headerlink" title="3.constexpr新关键字"></a>3.constexpr新关键字</h2><h3 id="3-1-const关键字"><a href="#3-1-const关键字" class="headerlink" title="3.1 const关键字"></a>3.1 const关键字</h3><p>在C++11之前只有<code>const关键字</code>，从功能上来说这个关键字有双重语义：<code>变量只读</code>，<code>修饰常量</code>，举一个简单的例子：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> num<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">const</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">24</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> array<span class="token punctuation">[</span>num<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment">// 报错，num是一个只读变量，不是常量 因为const修饰参数</span>
    <span class="token keyword">int</span> array1<span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token comment">// ok，count是一个常量</span>

    <span class="token keyword">int</span> a1 <span class="token operator">=</span> <span class="token number">520</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> a2 <span class="token operator">=</span> <span class="token number">250</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> array2<span class="token punctuation">[</span>a1<span class="token punctuation">]</span><span class="token punctuation">;</span>				<span class="token comment">// 报错, 定义数组不能使用变量</span>
    
    <span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> b <span class="token operator">=</span> a1<span class="token punctuation">;</span>
    b <span class="token operator">=</span> a2<span class="token punctuation">;</span>                         <span class="token comment">// 报错</span>
    a1 <span class="token operator">=</span> <span class="token number">1314</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"b: "</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>     <span class="token comment">// 输出结果为1314</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>函数 <code>void func(const int num)</code> 的参数 <code>num</code> 表示这个变量是只读的，但不是常量，因此使用 <code>int array[num];</code> 这种方式定义一个数组，编译器是会报错的，提示 <code>num不可用作为常量来使用。</code></li>
<li><code>const int count = 24;</code>中的<code>count</code>却是一个常量，因此可以使用这个常量来定义一个静态数组。</li>
</ul>
<p>另外，<code>变量只读并不等价于常量</code>，二者是两个概念不能混为一谈，分析一下这句测试代码<code>const int&amp; b = a1;</code></p>
<ul>
<li>b是一个常量的引用，所以 <code>b</code> 引用的变量是不能被修改的，也就是说 <code>b = a2; </code> 这句代码语法是错误的。</li>
<li>语句的<code>const</code> 对于 <code>变量a1</code> 是没有任何约束的，a1 的值变了 b 的值也就变了</li>
<li>引用b是<code>只读的</code>，但是并不能保证它的值是不可改变的，也就是说它不是常量。</li>
</ul>
<h3 id="3-2-constexpr常量表达式"><a href="#3-2-constexpr常量表达式" class="headerlink" title="3.2 constexpr常量表达式"></a>3.2 constexpr常量表达式</h3><p>在C++11中添加了一个新的关键字 <code>constexpr</code>，这个关键字是用来修饰 <code>常量表达式</code> 的。所谓常量表达式，指的就是<code>由多个（≥1）常量（值不会改变）组成并且在编译过程中就得到计算结果的表达式</code>。</p>
<p>在介绍<code>gcc/g++工作流程</code>的时候说过，C++ 程序从编写完毕到执行分为四个阶段：<code>预处理</code>、 <code>编译</code>、<code>汇编</code>和<code>链接</code>4个阶段，得到可执行程序之后就可以运行了。需要额外强调的是，<code>常量表达式和非常量表达式的计算时机不同，非常量表达式只能在程序运行阶段计算出结果，但是常量表达式的计算往往发生在程序的编译阶段，这可以极大提高程序的执行效率，因为表达式只需要在编译阶段计算一次，节省了每次程序运行时都需要计算一次的时间。</code></p>
<p>那么问题来了，<code>编译器如何识别</code>表达式是不是常量表达式呢？在C++11中添加了 <code>constexpr</code> 关键字之后就可以在程序中使用它来修饰常量表达式，用来提高程序的执行效率。在使用中建议将 <code>const</code> 和 <code>constexpr</code> 的功能区分开，即凡是表达<code>“只读”语义</code>的场景都使用 <code>const</code>，表达<code>“常量”语义</code>的场景都使用 <code>constexpr</code>。</p>
<p>在定义常量的时候,使用<code>const</code>和<code>constexpr</code>都可以:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>          <span class="token comment">// 常量表达式</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> doubled <span class="token operator">=</span> num <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 常量表达式</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">constexpr</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>     <span class="token comment">// 常量表达式</span>
<span class="token keyword">constexpr</span> <span class="token keyword">int</span> b <span class="token operator">=</span> a <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment">// 常量表达式</span>
<span class="token keyword">constexpr</span> <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 报错 => 不能作为常量表达式,因为func()在运行时才会返回值,所以不能在编译时确定值</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>对于C++内置类型的数据,可以直接使用<code>constexpr</code>修饰,但是对于<code>自定义数据类型</code>,例如 <code>struct</code> 和 <code>class</code> 定义的结构体和类,直接使用 <code>constexpr </code>是不行的</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/* 这样会报错: constexpr无效 */</span>
<span class="token keyword">constexpr</span> <span class="token keyword">struct</span> <span class="token class-name">Person</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> age<span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果要定义一个<code>结构体/类常量对象</code>，可以这样写：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Test</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> id<span class="token punctuation">;</span>
    <span class="token keyword">int</span> num<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">constexpr</span> Test t<span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token keyword">constexpr</span> <span class="token keyword">int</span> id <span class="token operator">=</span> t<span class="token punctuation">.</span>id<span class="token punctuation">;</span>
    <span class="token keyword">constexpr</span> <span class="token keyword">int</span> num <span class="token operator">=</span> t<span class="token punctuation">.</span>num<span class="token punctuation">;</span>
    <span class="token comment">// 报错，不能修改常量</span>
    t<span class="token punctuation">.</span>num <span class="token operator">+=</span> <span class="token number">100</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"id: "</span> <span class="token operator">&lt;&lt;</span> id <span class="token operator">&lt;&lt;</span> <span class="token string">", num: "</span> <span class="token operator">&lt;&lt;</span> num <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在第13行的代码中<code>t.num += 100;</code>的操作是<strong>错误的</strong>，<strong>对象t是一个常量</strong>，因此它的成员也是常量，<code>常量是不能被修改的</code>。</p>
<h3 id="3-3-常量表达式函数"><a href="#3-3-常量表达式函数" class="headerlink" title="3.3 常量表达式函数"></a>3.3 常量表达式函数</h3><p>为了提高C++程序的执行效率，我们可以将程序中值不需要发生变化的变量定义为常量，也可以使用<code>constexpr</code>修饰某些特定函数的返回值，这种函数被称作<code>常量表达式函数</code>，这些函数主要包括以下几种：<code>普通函数/类成员函数</code>、<code>类的构造函数</code>、<code>模板函数</code>。</p>
<h4 id="a-修饰普通函数"><a href="#a-修饰普通函数" class="headerlink" title="a. 修饰普通函数"></a>a. 修饰普通函数</h4><p><code>constexpr</code>并不能任意函数的返回值，使这些函数成为<code>常量表达式函数</code>，必须满足以下条件：</p>
<ol>
<li><code>函数必须要有返回值</code>，并且<strong>return返回的表达式必须是常量表达式</strong></li>
</ol>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// error，不是常量表达式函数</span>
<span class="token keyword">constexpr</span> <span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"a: "</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// error，不是常量表达式函数</span>
<span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> a<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><strong>函数func1()没有返回值</strong>，不满足常量表达式函数要求</li>
<li><strong>函数func2()返回值不是常量表达式</strong>，不满足常量表达式函数要求</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/12/25/cpp11-xin-te-xing/constexpr%E4%B8%8D%E5%90%8C%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC.png" alt="image-20241225232916249"></p>
<p>由此可见在<code>更新的C++标准</code>里边放宽了对 <code>constexpr</code> 的语法限制。</p>
<ol start="2">
<li><code>函数在使用之前,必须有与之相对应的定义</code></li>
</ol>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">constexpr</span> <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// error</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">constexpr</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> a<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在测试程序<code>constexpr int num = func1();</code>中，还没有定义<code>func1()</code>就直接调用了，应该将<code>func1()</code>函数的定义放到<code>main()</code>函数的上边。</p>
<ol start="3">
<li>整个函数的函数体中，<code>不</code>能出现<code>非常量表达式</code>之外的语句（<code>using 指令、typedef 语句以及 static_assert 断言、return语句除外</code>）。</li>
</ol>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// error</span>
<span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">constexpr</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
    <span class="token keyword">constexpr</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> b<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"i: "</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// ok</span>
<span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">using</span> mytype <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">;</span>
    <span class="token keyword">constexpr</span> mytype a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
    <span class="token keyword">constexpr</span> mytype b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token keyword">constexpr</span> mytype c <span class="token operator">=</span> a <span class="token operator">*</span> b<span class="token punctuation">;</span>
    <span class="token keyword">return</span> c <span class="token operator">-</span> <span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在C++中，<code>constexpr</code>函数要求函数体中所有的操作都必须是常量表达式。这意味着函数体中不能包含任何运行时的操作，比如I&#x2F;O操作（如<code>cout</code>），以及任何依赖于非常量值的操作。</p>
<ul>
<li><code>func1()</code>函数中包含了一个<code>for</code>循环，并且在循环体内使用了<code>cout</code>进行输出。<code>cout</code>是一个运行时的I&#x2F;O操作，不是常量表达式，因此会导致<code>constexpr</code>函数的定义失败。即使<code>for</code>循环本身可能是基于常量表达式的，但由于包含了非<code>constexpr</code>的操作（<code>cout</code>），整个函数都不能被标记为<code>constexpr</code>。</li>
<li><code>func2()</code>函数中没有包含任何运行时的操作，所有的计算都是在编译时完成的，因此它可以被标记为<code>constexpr</code>。</li>
</ul>
<blockquote>
<p>以上三条规则不仅对于普通的函数生效，并且对于类的成员函数同样生效</p>
</blockquote>
<h4 id="b-修饰成员函数"><a href="#b-修饰成员函数" class="headerlink" title="b. 修饰成员函数"></a>b. 修饰成员函数</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Test</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">constexpr</span> <span class="token keyword">int</span> var <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">5</span> <span class="token operator">*</span> var<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Test t<span class="token punctuation">;</span>
    <span class="token keyword">constexpr</span> <span class="token keyword">int</span> num <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"num: "</span> <span class="token operator">&lt;&lt;</span> num <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="c-修饰模板函数"><a href="#c-修饰模板函数" class="headerlink" title="c. 修饰模板函数"></a>c. 修饰模板函数</h4><p>在C++中，”模板函数”指的是一种允许函数在编译时根据给定的参数类型生成特定实现的机制。这种机制使得同一个函数可以用于不同的数据类型，而不需要为每种类型编写不同的函数代码。</p>
<p>函数模板的基本语法如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">myFunction</span><span class="token punctuation">(</span>T param<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 函数体，使用T作为参数类型</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>这里的<code>template &lt;typename T&gt;</code>声明了一个模板，其中<code>T</code>是一个类型参数，可以在调用函数时指定。<code>typename</code>关键字用于指定<code>T</code>是一个类型。你也可以使用<code>class</code>关键字代替<code>typename</code>，但在现代C++中，<code>typename</code>是首选。</p>
<p>函数模板的使用示例：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
T <span class="token function">max</span><span class="token punctuation">(</span>T a<span class="token punctuation">,</span> T b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>a <span class="token operator">></span> b<span class="token punctuation">)</span> <span class="token operator">?</span> a <span class="token operator">:</span> b<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 使用int类型调用</span>
<span class="token keyword">int</span> maxInt <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 使用double类型调用</span>
<span class="token keyword">double</span> maxDouble <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token number">3.14</span><span class="token punctuation">,</span> <span class="token number">2.71</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在这个例子中，<code>max</code>函数模板可以根据传入的参数类型自动实例化出<code>int</code>和<code>double</code>版本的<code>max</code>函数。</p>
<p>函数模板也可以接受多个类型参数：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T1</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">T2</span><span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">printPair</span><span class="token punctuation">(</span><span class="token keyword">const</span> T1<span class="token operator">&amp;</span> a<span class="token punctuation">,</span> <span class="token keyword">const</span> T2<span class="token operator">&amp;</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">" and "</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 使用</span>
<span class="token function">printPair</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">3.14</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这里，<code>printPair</code>函数模板接受两个参数，这两个参数可以是不同的类型。</p>
<p>函数模板也可以使用非类型模板参数，这些参数在编译时必须是常量：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">int</span> N<span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">printArray</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">)</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 使用</span>
<span class="token keyword">int</span> myArray<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token function">printArray</span><span class="token punctuation">(</span>myArray<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在这个例子中，<code>printArray</code>函数模板接受一个数组，并使用非类型模板参数<code>N</code>来指定数组的大小。</p>
<blockquote>
<p>C++11 语法中，<code>constexpr</code> 可以修饰函数模板，但由于模板中类型的不确定性，因此函数模板实例化后的模板函数是否符合常量表达式函数的要求也是不确定的。<code>如果 constexpr 修饰的模板函数实例化结果不满足常量表达式函数的要求，则 constexpr 会被自动忽略，即该函数就等同于一个普通函数。</code></p>
</blockquote>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> name<span class="token punctuation">;</span>
    <span class="token keyword">int</span> age<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token comment">// 定义函数模板</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">constexpr</span> T <span class="token function">dispaly</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> t<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">struct</span> <span class="token class-name">Person</span> p <span class="token punctuation">&#123;</span> <span class="token string">"luffy"</span><span class="token punctuation">,</span> <span class="token number">19</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token comment">//普通函数</span>
    <span class="token keyword">struct</span> <span class="token class-name">Person</span> ret <span class="token operator">=</span> <span class="token function">dispaly</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"luffy's name: "</span> <span class="token operator">&lt;&lt;</span> ret<span class="token punctuation">.</span>name <span class="token operator">&lt;&lt;</span> <span class="token string">", age: "</span> <span class="token operator">&lt;&lt;</span> ret<span class="token punctuation">.</span>age <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token comment">//常量表达式函数</span>
    <span class="token keyword">constexpr</span> <span class="token keyword">int</span> ret1 <span class="token operator">=</span> <span class="token function">dispaly</span><span class="token punctuation">(</span><span class="token number">250</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> ret1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token keyword">constexpr</span> <span class="token keyword">struct</span> <span class="token class-name">Person</span> p1 <span class="token punctuation">&#123;</span> <span class="token string">"luffy"</span><span class="token punctuation">,</span> <span class="token number">19</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// 使用constexpr修饰， p1是一个常量表达式</span>
    <span class="token keyword">constexpr</span> <span class="token keyword">struct</span> <span class="token class-name">Person</span> p2 <span class="token operator">=</span> <span class="token function">dispaly</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"luffy's name: "</span> <span class="token operator">&lt;&lt;</span> p2<span class="token punctuation">.</span>name <span class="token operator">&lt;&lt;</span> <span class="token string">", age: "</span> <span class="token operator">&lt;&lt;</span> p2<span class="token punctuation">.</span>age <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上面示例程序中定义了一个函数模板 <code>display()</code>，但由于其返回值类型未定，因此在实例化之前无法判断其是否符合常量表达式函数的要求：</p>
<ul>
<li><code>struct Person ret = dispaly(p);</code> 由于参数<code>p</code>是变量，所以实例化后的函数不是常量表达式函数，此时<code>constexpr</code>是无效的</li>
<li><code>constexpr int ret1 = dispaly(250);</code> 参数是常量，符合常量表达式函数的要求，此时<code>constexpr</code>是有效的</li>
<li><code>constexpr struct Person p2 = dispaly(p1);</code> 参数是常量，符合常量表达式函数的要求，此时<code>constexpr</code>是有效的</li>
</ul>
<h4 id="d-修饰构造函数"><a href="#d-修饰构造函数" class="headerlink" title="d. 修饰构造函数"></a>d. 修饰构造函数</h4><p>在C++中，<code>constexpr</code>构造函数允许在编译时初始化对象，这意味着构造函数创建的对象可以被用作常量表达式的一部分。这对于创建在编译时就需要确定值的<code>常量对象</code>非常有用。</p>
<ol>
<li><strong>构造函数的参数必须是常量表达式</strong>：<ul>
<li><code>constexpr</code> 构造函数的参数应当是可以在编译时求值的常量。例如，基本数据类型的常量、常量变量和字面量等。</li>
</ul>
</li>
<li><strong>函数体必须包含允许的操作</strong>：<ul>
<li><code>constexpr</code> 构造函数的函数体必须仅包含可以在编译时执行的表达式。这意味着不能使用诸如动态内存分配、输入输出等运行时操作。</li>
</ul>
</li>
<li><strong>以常量对象的形式使用</strong>：<ul>
<li>构造函数的结果必须是用于创建一个常量对象，可以是 <code>constexpr</code> 变量或用 <code>constexpr</code> 表达式初始化的对象。</li>
</ul>
</li>
<li><strong>返回类型</strong>：<ul>
<li><code>constexpr</code> 构造函数的返回类型必须是该类类型，即生成的对象类型</li>
</ul>
</li>
</ol>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>

<span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment">// 常量表达式构造函数</span>
    <span class="token keyword">constexpr</span> <span class="token function">Point</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">x_</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">y_</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

    <span class="token comment">// 获取 x 和 y 的常量成员函数</span>
    <span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> x_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>
    <span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">getY</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> y_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> x_<span class="token punctuation">;</span>
    <span class="token keyword">int</span> y_<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 在编译时创建常量对象</span>
    <span class="token keyword">constexpr</span> Point <span class="token function">p</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 输出常量对象的值</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Point: ("</span> <span class="token operator">&lt;&lt;</span> p<span class="token punctuation">.</span><span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span> <span class="token operator">&lt;&lt;</span> p<span class="token punctuation">.</span><span class="token function">getY</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">")"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="4-auto类型推导"><a href="#4-auto类型推导" class="headerlink" title="4.auto类型推导"></a>4.auto类型推导</h2><p>在C++11中，可以使用<code>auto</code>来自动推测变量的类型，还可以结合使用<code>decltype</code>关键字来推测函数或者表达式的返回值。允许程序员编写更灵活和通用的代码，尤其是在模板编程中。通过<code>decltype</code>，我们可以避免显式指定类型，从而减少代码的复杂性，并提高代码的可读性和可维护性。</p>
<h3 id="4-1-auto的推导规则"><a href="#4-1-auto的推导规则" class="headerlink" title="4.1 auto的推导规则"></a>4.1 auto的推导规则</h3><p>在<code>C++11之前</code>，<code>auto</code>关键字用于声明<code>自动存储期</code>的变量，但由于非<code>static</code>的局部变量默认就是自动存储期的，所以这个关键字的使用变得不那么常见。</p>
<p>C++11引入了新的<code>auto</code>关键字用法，它主要用于<code>自动类型推导</code>，使得程序员可以不必显式声明变量的类型，而让编译器根据<code>变量的初始值</code>自动推导出类型。</p>
<h4 id="a-自动存储期"><a href="#a-自动存储期" class="headerlink" title="a. 自动存储期"></a>a. 自动存储期</h4><p>在C++中，<code>自动存储期（Automatic Storage Duration）</code>是指变量的生命周期，它描述了变量在程序执行过程中存在的时间。具有自动存储期的变量通常是在函数或代码块内部定义的局部变量，它们在定义它们的代码块被执行时创建，在代码块执行结束时销毁。</p>
<p>以下是自动存储期的一些特点：</p>
<ol>
<li><p><strong>局部作用域</strong>：</p>
<ul>
<li>自动存储期的变量具有局部作用域，它们只能在定义它们的函数或代码块内部被访问。</li>
</ul>
</li>
<li><p><strong>栈内存分配</strong>：</p>
<ul>
<li>这些变量通常在栈（stack）上分配内存。当函数被调用时，局部变量的内存被分配；当函数返回时，这些内存被释放。</li>
</ul>
</li>
<li><p><strong>生命周期</strong>：</p>
<ul>
<li>自动存储期的变量的生命周期仅限于它们被定义的代码块。一旦代码块执行结束，这些变量就会被销毁，它们的内存空间会被回收。</li>
</ul>
</li>
<li><p><strong>初始化</strong>：</p>
<ul>
<li>在C++中，局部变量（具有自动存储期的变量）不会自动初始化。如果它们没有被显式初始化，它们的值是未定义的。</li>
</ul>
</li>
<li><p><strong>与静态存储期的区别</strong>：</p>
<ul>
<li>与自动存储期相对的是静态存储期（Static Storage Duration），具有静态存储期的变量在程序的整个运行期间都存在，它们通常在全局区域或在函数外部定义。</li>
</ul>
</li>
<li><p><strong>例子</strong>：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> localVariable<span class="token punctuation">;</span> <span class="token comment">// 自动存储期的局部变量，未初始化，其值是未定义的</span>
    localVariable <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">// 初始化后，可以安全使用</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这个例子中，<code>localVariable</code>是一个局部变量，它具有自动存储期。它只在<code>function</code>函数内部有效，并且在函数结束时被销毁。</p>
</li>
</ol>
<h4 id="b-auto的推导规则"><a href="#b-auto的推导规则" class="headerlink" title="b. auto的推导规则"></a>b. auto的推导规则</h4><p>C++11 中 auto 并不代表一种实际的数据类型，只是一个类型声明的 “占位符”，auto并不是万能的在任意场景下都能够推导出变量的实际类型，<code>使用auto声明的变量必须要进行初始化，以让编译器推导出它的实际类型，在编译时将auto占位符替换为真正的类型</code>。使用语法如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> 变量名 <span class="token operator">=</span> 变量值<span class="token punctuation">;</span> 

<span class="token keyword">auto</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token comment">// x会被推导为int类型</span>
<span class="token keyword">auto</span> y <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span>      <span class="token comment">// y会被推导为double类型</span>
<span class="token keyword">auto</span> z <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>   <span class="token comment">// z会被推导为const char[]类型</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>不仅如此，auto还可以和指针、引用结合起来使用也可以带上<code>const</code>、<code>volatile限定符</code>，在不同的场景下有对应的推导规则，规则内容如下：</p>
<ul>
<li>当变量<strong>不是指针或者引用类型</strong>时，推导的结果中不会保留<code>const</code>、<code>volatile</code>关键字</li>
<li>当变量<strong>是指针或者引用类型</strong>时，推导的结果中会保留<code>const</code>、<code>volatile</code>关键字</li>
<li><code>volatile</code>关键字用于告诉编译器该变量可能会被程序之外的因素（如硬件或其他线程）改变，因此编译器需要在每次访问该变量时从内存中重新读取其值，而不是使用寄存器中的值。</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> temp <span class="token operator">=</span> <span class="token number">150</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> <span class="token operator">*</span>a <span class="token operator">=</span> <span class="token operator">&amp;</span>temp<span class="token punctuation">;</span>   <span class="token comment">// 变量a的数据类型为 int*，因此auto关键字被推导为 int类型</span>
<span class="token keyword">auto</span> b <span class="token operator">=</span> <span class="token operator">&amp;</span>temp<span class="token punctuation">;</span>    <span class="token comment">// 变量b的数据类型为 int*，因此auto关键字被推导为 int*类型</span>
<span class="token keyword">auto</span> <span class="token operator">&amp;</span>c <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token comment">// 变量c的数据类型为 int&amp;，因此auto关键字被推导为 int类型</span>
<span class="token keyword">auto</span> d <span class="token operator">=</span> temp<span class="token punctuation">;</span>     <span class="token comment">// 变量d的数据类型为 int，因此auto关键字被推导为 int类型</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> tmp <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">auto</span> a1 <span class="token operator">=</span> tmp<span class="token punctuation">;</span>       
<span class="token keyword">auto</span> a2 <span class="token operator">=</span> a1<span class="token punctuation">;</span>              
<span class="token keyword">const</span> <span class="token keyword">auto</span> <span class="token operator">&amp;</span>a3 <span class="token operator">=</span> tmp<span class="token punctuation">;</span>      
<span class="token keyword">auto</span> <span class="token operator">&amp;</span>a4 <span class="token operator">=</span> a3<span class="token punctuation">;</span>             <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>变量<strong>a1</strong>的数据类型为 <code>const int</code>，因此auto关键字被推导为 <code>int类型</code></li>
<li>变量<strong>a2</strong>的数据类型为 <code>int</code>，但是a2<code>没有声明为指针或引用</code>因此 const属性被去掉, auto被推导为 <code>int</code></li>
<li>变量<strong>a3</strong>的数据类型为 <code>const int&amp;</code>，a3被声明为<code>引用</code>因此 const属性被保留，auto关键字被推导为 <code>int类型</code></li>
<li>变量<strong>a4</strong>的数据类型为 <code>const int&amp;</code>，a4被声明为<code>引用</code>因此 const属性被保留，auto关键字被推导为 <code>const int类型</code></li>
</ul>
<h3 id="4-2-auto的限制"><a href="#4-2-auto的限制" class="headerlink" title="4.2 auto的限制"></a>4.2 auto的限制</h3><p><code>auto</code>的类型推导并不是万能的，对于在<code>编译时无法完成类型推导的情况</code>，不能使用自动推导</p>
<ol>
<li><code>auto</code>不能作为函数的参数使用，因为C++中，函数参数的类型必须在编译时已知。<code>auto</code>是一个类型推导关键字，它依赖于初始化表达式来确定具体的类型，这意味着<code>auto</code>需要在变量声明时立即跟随一个初始化表达式，以便编译器可以推导出类型。</li>
</ol>
<blockquote>
<p>因为只有在函数调用的时候才给函数参数传递实参，auto 要求必须要给修饰的变量赋值，因此二者矛盾</p>
</blockquote>
  <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">auto</span> a<span class="token punctuation">,</span> <span class="token keyword">auto</span> b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">// 错误</span>
    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<ol start="2">
<li><code>auto</code>不能用于<code>非静态成员</code>的初始化，这是因为<code>非静态成员</code>是属于类的实例对象的，而对象需要在程序运行时才会被创建，所以不能使用自动类型推导</li>
</ol>
  <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">auto</span> age <span class="token operator">=</span> <span class="token number">18</span><span class="token punctuation">;</span> <span class="token comment">// 错误</span>
    <span class="token keyword">static</span> <span class="token keyword">auto</span> name <span class="token operator">=</span> <span class="token string">"Tom"</span><span class="token punctuation">;</span> <span class="token comment">// 错误，类的静态非常量成员不允许在类内部直接初始化</span>
    <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">auto</span> sex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 正确，</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ol start="3">
<li>不能使用<code>auto</code>关键字<code>定义数组</code></li>
</ol>
  <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// 定义数组</span>
    <span class="token keyword">auto</span> t1 <span class="token operator">=</span> array<span class="token punctuation">;</span>               <span class="token comment">// ok, t1被推导为 int* 类型</span>
    <span class="token keyword">auto</span> t2<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">;</span>             <span class="token comment">// error, auto无法定义数组</span>
    <span class="token keyword">auto</span> t3<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>   <span class="token comment">// error, auto无法定义数组</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ol start="4">
<li>不能用于<code>模板参数的推导</code>，在C++中，<code>auto</code>关键字用于自动类型推导，但它不能用于模板参数的推导。这是因为模板参数需要在编译时就确定，而<code>auto</code>的类型推导依赖于初始化表达式的类型，这通常在模板实例化时已经太晚了。</li>
</ol>
  <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">struct</span> <span class="token class-name">Test</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Test<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span> t<span class="token punctuation">;</span>
    Test<span class="token operator">&lt;</span><span class="token keyword">auto</span><span class="token operator">></span> t1 <span class="token operator">=</span> t<span class="token punctuation">;</span> <span class="token comment">// error, 无法推导出模板类型</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="4-3-auto的应用"><a href="#4-3-auto的应用" class="headerlink" title="4.3 auto的应用"></a>4.3 auto的应用</h3><p><code>auto</code> 关键字在 C++ 中主要用于自动类型推导，它可以在多种场景下简化代码和提高代码的可读性。以下是一些常见的应用场景：</p>
<ol>
<li><code>遍历容器</code></li>
</ol>
<p>当遍历标准库容器（如 <code>std::vector</code>、<code>std::list</code>、<code>std::map</code> 等）时，<code>auto</code> 可以用来简化迭代器的类型。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> vec <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">=</span> vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> vec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>it<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>it <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">// 输出：1 2 3 4 5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ol start="2">
<li><code>简化复杂类型</code></li>
</ol>
<p>对于复杂的类型，如嵌套的模板或自定义类型的嵌套定义，<code>auto</code> 可以减少代码的复杂性。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>map<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> myMap<span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> pair <span class="token operator">:</span> myMap<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> pair<span class="token punctuation">.</span>first <span class="token operator">&lt;&lt;</span> <span class="token string">": "</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> num <span class="token operator">:</span> pair<span class="token punctuation">.</span>second<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> num <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ol start="3">
<li><code>函数返回值</code></li>
</ol>
<p>当函数返回复杂类型时，<code>auto</code> 可以用来简化函数调用。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">getVector</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">auto</span> vec <span class="token operator">=</span> <span class="token function">getVector</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// vec 的类型被推导为 std::vector&lt;int></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ol start="4">
<li><code>Lambda 表达式</code></li>
</ol>
<p>在 Lambda 表达式中，<code>auto</code> 可以用来推导捕获的变量类型。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> lambda <span class="token operator">=</span> <span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> x<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<ol start="5">
<li><code>初始化列表</code></li>
</ol>
<p>使用花括号初始化列表时，<code>auto</code> 可以用来推导数组或 <code>std::vector</code> 的类型。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> arr <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// arr 的类型被推导为 std::initializer_list&lt;int></span>
<span class="token keyword">auto</span> vec <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// vec 的类型被推导为 std::vector&lt;int></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<ol start="6">
<li><code>智能指针</code></li>
</ol>
<p>当使用智能指针如 <code>std::unique_ptr</code> 或 <code>std::shared_ptr</code> 时，<code>auto</code> 可以简化类型声明。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> ptr <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_unique</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ptr 的类型被推导为 std::unique_ptr&lt;int></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ol start="7">
<li><code>泛型编程</code></li>
</ol>
<p>在模板编程中，<code>auto</code> 可以用来推导模板实例化的具体类型。在使用模板的时候，很多情况下我们不知道变量应该定义为什么类型</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">T1</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">T2</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">static</span> string <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token string">"hello, world"</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">auto</span> val <span class="token operator">=</span> <span class="token class-name">A</span><span class="token double-colon punctuation">::</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"val: "</span> <span class="token operator">&lt;&lt;</span> val <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token generic-function"><span class="token function">func</span><span class="token generic class-name"><span class="token operator">&lt;</span>T1<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token generic-function"><span class="token function">func</span><span class="token generic class-name"><span class="token operator">&lt;</span>T2<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ol start="8">
<li><code>错误处理</code></li>
</ol>
<p>在处理异常和错误代码时，<code>auto</code> 可以用来简化错误类型的处理。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> error <span class="token operator">=</span> <span class="token function">someFunctionThatReturnsErrorCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>error <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    std<span class="token double-colon punctuation">::</span>cerr <span class="token operator">&lt;&lt;</span> <span class="token string">"Error occurred: "</span> <span class="token operator">&lt;&lt;</span> error <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="4-4-decltype关键字"><a href="#4-4-decltype关键字" class="headerlink" title="4.4 decltype关键字"></a>4.4 decltype关键字</h3><p><code>decltype</code>的作用是在不需要或者不能进行<code>表达式的计算</code>的时候，希望能够得到表达式的<code>结果类型</code>，这个时候就可以运用到<code>decltype关键字</code>了，语法如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">decltype</span> <span class="token punctuation">(</span>表达式<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><code>decltype</code>是<code>declare type</code>声明类型的缩写，其推导是在<code>编译期</code>完成的，它只用于表达式类型的推导，不会在内部进行计算表达式的值。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">auto</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token keyword">decltype</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> b <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>               <span class="token comment">// int</span>
    <span class="token keyword">decltype</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> c <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>            <span class="token comment">// int</span>
    <span class="token keyword">decltype</span><span class="token punctuation">(</span>b <span class="token operator">*</span> <span class="token number">10.25</span> <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">)</span> d <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token comment">// double</span>

    <span class="token comment">// 输出类型</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Type of a: "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Type of b: "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Type of c: "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Type of d: "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="4-5-decltype的推导规则"><a href="#4-5-decltype的推导规则" class="headerlink" title="4.5 decltype的推导规则"></a>4.5 decltype的推导规则</h3><ol>
<li>表达式为<code>普通变量</code>或者<code>普通表达式</code>或者<code>类表达式(有类的限定的或者对象参与的)</code>，在这种情况下，使用<strong>decltype推导出的类型和表达式的类型是一致的</strong>。</li>
</ol>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Test</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    string text<span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">110</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">99</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>y <span class="token operator">=</span> x<span class="token punctuation">;</span>
    <span class="token keyword">decltype</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> a <span class="token operator">=</span> x<span class="token punctuation">;</span>
    <span class="token keyword">decltype</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> b <span class="token operator">=</span> x<span class="token punctuation">;</span>
    <span class="token keyword">decltype</span><span class="token punctuation">(</span>Test<span class="token double-colon punctuation">::</span>value<span class="token punctuation">)</span> c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    Test t<span class="token punctuation">;</span>
    <span class="token keyword">decltype</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>text<span class="token punctuation">)</span> d <span class="token operator">=</span> <span class="token string">"hello, world"</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>变量<code>a</code>被推导为 <code>int</code>类型</li>
<li>变量<code>b</code>被推导为 <code>const int &amp;</code> 类型</li>
<li>变量<code>c</code>被推导为 <code>const int</code> 类型</li>
<li>变量<code>d</code>被推导为 <code>string</code> 类型</li>
</ul>
<ol start="2">
<li>表达式是<code>函数调用</code>，使用 <strong>decltype 推导出的类型和函数返回值一致。</strong>(有一个特殊,纯右值)</li>
</ol>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token comment">//函数声明</span>
<span class="token keyword">int</span> <span class="token function">func_int</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">// 返回值为 int</span>
<span class="token keyword">int</span><span class="token operator">&amp;</span> <span class="token function">func_int_r</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">// 返回值为 int&amp;</span>
<span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> <span class="token function">func_int_rr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 返回值为 int&amp;&amp;</span>

<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token function">func_cint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 返回值为 const int</span>
<span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> <span class="token function">func_cint_r</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 返回值为 const int&amp;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> <span class="token function">func_cint_rr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 返回值为 const int&amp;&amp;</span>

<span class="token keyword">const</span> Test <span class="token function">func_ctest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 返回值为 const Test</span>

<span class="token comment">//decltype类型推导</span>
<span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">func_int</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>		
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">func_int_r</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> b <span class="token operator">=</span> n<span class="token punctuation">;</span>	
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">func_int_rr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>	
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">func_cint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> d <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>	
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">func_cint_r</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> e <span class="token operator">=</span> n<span class="token punctuation">;</span>	
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">func_cint_rr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> f <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>	
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">func_ctest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> g <span class="token operator">=</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>变量<code>a</code>被推导为 <code>int </code>类型</li>
<li>变量<code>b</code>被推导为 <code>int&amp; </code>类型</li>
<li>变量<code>c</code>被推导为 <code>int&amp;&amp;</code> 类型</li>
<li>变量<code>d</code>被推导为 <code>int</code> 类型</li>
<li>变量<code>e</code>被推导为 <code>const int &amp;</code> 类型</li>
<li>变量<code>f</code>被推导为 <code>const int &amp;&amp;</code> 类型</li>
<li>变量<code>g</code>被推导为 <code>const Test</code> 类型</li>
</ul>
<p>函数 <code>func_cint()</code> 返回的是一个<code>纯右值</code>（<strong>在表达式执行结束后不再存在的数据，也就是临时性的数据，或者例如字面量</strong>），<code>对于纯右值而言，只有类类型可以携带const</code>、<code>volatile限定符</code>，除此之外需要忽略掉这两个限定符，因此推导出的变量 <code>d</code> 的类型为 <code>int</code> 而不是 <code>const int</code>。</p>
<ol start="3">
<li><code>表达式是一个左值，或者被括号( )包围</code>，使用 <code>decltype</code> 推导出的是表达式类型的引用（如果有<code>const、volatile限定符</code>不能忽略）。</li>
</ol>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Test</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> num<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">const</span> Test obj<span class="token punctuation">;</span>
    <span class="token comment">//带有括号的表达式</span>
    <span class="token comment">// a : int</span>
    <span class="token keyword">decltype</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>num<span class="token punctuation">)</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">// b : const int&amp;</span>
    <span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>
    <span class="token comment">//加法表达式</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> m <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">// c : int </span>
    <span class="token keyword">decltype</span><span class="token punctuation">(</span>n <span class="token operator">+</span> m<span class="token punctuation">)</span> c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">// n+m最后保存在n中,n是可以取地址的左值,所以 d : int&amp;</span>
    <span class="token keyword">decltype</span><span class="token punctuation">(</span>n <span class="token operator">=</span> n <span class="token operator">+</span> m<span class="token punctuation">)</span> d <span class="token operator">=</span> n<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="4-6-decltype在泛型编程的应用"><a href="#4-6-decltype在泛型编程的应用" class="headerlink" title="4.6 decltype在泛型编程的应用"></a>4.6 decltype在泛型编程的应用</h3><p>关于decltype的应用多出现在<code>泛型编程</code>中。比如我们编写一个类模板，在里边添加遍历容器的函数，操作如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;list></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">class</span> <span class="token class-name">Container</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> c<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>m_it <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> m_it <span class="token operator">!=</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>m_it<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>m_it <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token operator">?</span><span class="token operator">?</span><span class="token operator">?</span> m_it<span class="token punctuation">;</span>  <span class="token comment">// 这里不能确定迭代器类型</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">const</span> list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> lst<span class="token punctuation">;</span>
    Container<span class="token operator">&lt;</span><span class="token keyword">const</span> list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> obj<span class="token punctuation">;</span>
    obj<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span>lst<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在程序的<strong>第17行</strong>出了问题，关于迭代器变量一共有两种类型：<code>只读（T::const_iterator）</code>和<code>读写（T::iterator）</code>，有了<code>decltype</code>就可以完美的解决这个问题了，当 T 是一个 非 const 容器得到一个 T::iterator，当 T 是一个 const 容器时就会得到一个<code>T::const_iterator</code>。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;list></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">class</span> <span class="token class-name">Container</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> c<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>m_it <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> m_it <span class="token operator">!=</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>m_it<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>m_it <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> m_it<span class="token punctuation">;</span>  <span class="token comment">// 这里不能确定迭代器类型</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">const</span> list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> lst<span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    Container<span class="token operator">&lt;</span><span class="token keyword">const</span> list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> obj<span class="token punctuation">;</span>
    obj<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span>lst<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p><code>decltype(*T*().begin()) iter; // 推导出对应的容器的迭代器类型</code></p>
</blockquote>
<h3 id="4-7-返回类型的后置-声明返回类型"><a href="#4-7-返回类型的后置-声明返回类型" class="headerlink" title="4.7 返回类型的后置(声明返回类型?)"></a>4.7 返回类型的后置(声明返回类型?)</h3><p>在泛型编程中，可能需要通过<code>参数的运算</code>来得到<code>返回值的类型</code>，比如下面这个场景：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token comment">// R->返回值类型, T->参数1类型, U->参数2类型</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">R</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">U</span><span class="token operator">></span>
R <span class="token function">add</span><span class="token punctuation">(</span>T t<span class="token punctuation">,</span> U u<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> t <span class="token operator">+</span> u<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">520</span><span class="token punctuation">;</span>
    <span class="token keyword">double</span> y <span class="token operator">=</span> <span class="token number">13.14</span><span class="token punctuation">;</span>
    <span class="token comment">// auto z = add&lt;decltype(x + y), int, double>(x, y);</span>
    <span class="token keyword">auto</span> z <span class="token operator">=</span> <span class="token generic-function"><span class="token function">add</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>x <span class="token operator">+</span> y<span class="token punctuation">)</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 简化之后的写法</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"z: "</span> <span class="token operator">&lt;&lt;</span> z <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>关于返回值，从上面的代码可以推断出和表达式 <code>t+u</code> 的结果类型是一样的，因此可以通过通过<code>decltype</code>进行推导，关于模板函数的参数<code>t</code>和<code>u</code>可以通过实参自动推导出来，因此在程序中就也可以不写。虽然通过上述方式问题被解决了，但是解决方案有点过于理想化，因为对于调用者来说，是不知道函数内部执行了什么样的处理动作的。(如例子中的 <code>t + u</code>,自然也不能通过<code>decltype</code>来声明表达式类型)</p>
<p>因此如果要想解决这个问题就得直接在 <code>add()</code> 函数身上做文章，自然而然地想到在<code>函数声明</code>的时候使用<strong>decltype来推导返回值类型</strong></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">U</span><span class="token operator">></span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span>t<span class="token operator">+</span>u<span class="token punctuation">)</span> <span class="token function">add</span><span class="token punctuation">(</span>T t<span class="token punctuation">,</span> U u<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> t <span class="token operator">+</span> u<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>但这样显然是错误的,因为decltype中的 t 和 u 都是函数参数，直接这样写相当于变量还没有定义就直接用上了，这时候变量还不存在，有点心急了。</p>
</blockquote>
<p>在C++11中增加了<code>返回类型后置语法</code>，说明白一点就是将<code>decltype和auto结合起来完成返回类型的推导</code>。其语法格式如下:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 符号 -> 后边跟随的是函数返回值的类型</span>
<span class="token keyword">auto</span> <span class="token function">func</span><span class="token punctuation">(</span>参数<span class="token number">1</span><span class="token punctuation">,</span> 参数<span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>参数表达式<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>通过对上述返回类型后置语法代码的分析，得到结论：<code>auto 会追踪 decltype() 推导出的类型</code>，因此上边的<code>add()函数</code>可以做如下的修改：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">U</span><span class="token operator">></span>
<span class="token comment">// 返回类型后置语法</span>
<span class="token keyword">auto</span> <span class="token function">add</span><span class="token punctuation">(</span>T t<span class="token punctuation">,</span> U u<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>t<span class="token operator">+</span>u<span class="token punctuation">)</span>  <span class="token comment">// 声明函数时就设定返回的类型由t+u推导出来</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> t <span class="token operator">+</span> u<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">520</span><span class="token punctuation">;</span>
    <span class="token keyword">double</span> y <span class="token operator">=</span> <span class="token number">13.14</span><span class="token punctuation">;</span>
    <span class="token comment">// auto z = add&lt;int, double>(x, y);</span>
    <span class="token keyword">auto</span> z <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// 简化之后的写法</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"z: "</span> <span class="token operator">&lt;&lt;</span> z <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>为了进一步说明这个语法，我们再看一个例子：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span><span class="token operator">&amp;</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>i<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> i<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">double</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">double</span> <span class="token operator">&amp;</span>d<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    d <span class="token operator">=</span> d <span class="token operator">+</span> <span class="token number">100</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> d<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token comment">// 返回类型后置语法</span>
<span class="token keyword">auto</span> <span class="token function">myFunc</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> t<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">test</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token function">test</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">520</span><span class="token punctuation">;</span>
    <span class="token keyword">double</span> y <span class="token operator">=</span> <span class="token number">13.14</span><span class="token punctuation">;</span>
    <span class="token comment">// auto z = myFunc&lt;int>(x);</span>
    <span class="token keyword">auto</span> z <span class="token operator">=</span> <span class="token function">myFunc</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">// 简化之后的写法</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"z: "</span> <span class="token operator">&lt;&lt;</span> z <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token comment">// auto z = myFunc&lt;double>(y);</span>
    <span class="token keyword">auto</span> z1 <span class="token operator">=</span> <span class="token function">myFunc</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 简化之后的写法</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"z1: "</span> <span class="token operator">&lt;&lt;</span> z1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在这个例子中，通过<code>decltype结合返回值后置</code>语法很容易推导出来, <code>test(t)</code>函数可能出现的返回值类型，并将其作用到了函数<code>myFunc()</code>上。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 输出结果</span>
z<span class="token operator">:</span> <span class="token number">520</span>
z1<span class="token operator">:</span> <span class="token number">113.14</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>类模板的实例化（生成对应类型的具体代码）和<code>decltype类型推导</code>都是在编译期完成的，所以decltype和模板能够一起使用</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">+------------------+
| 调用 myFunc(x)   |
+------------------+
          |
+---------v---------+
| 模板实例化 myFunc&lt;int> |
+---------+---------+
          |
+---------v---------+
| decltype(test(t)) 推导为 int&amp; |
+---------+---------+
          |
+---------v---------+
| 调用 test(int&amp;)   返回 x 的引用 |
+------------------+


+------------------+
| 调用 myFunc(y)   |
+------------------+
          |
+---------v---------+
| 模板实例化 myFunc&lt;double> |
+---------+---------+
          |
+---------v---------+
| decltype(test(t)) 推导为 double |
+---------+---------+
          |
+---------v---------+
| 调用 test(double&amp;) 修改 y 并返回副本 |
+------------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</blockquote>
<h2 id="5-final和override"><a href="#5-final和override" class="headerlink" title="5.final和override"></a>5.final和override</h2><p>C++ 中增加了 <code>final 关键字</code>来 <code>限制某个类不能被继承</code>，或者<code>某个虚函数不能被重写</code>，和 <code>Java</code> 的 final 关键字的功能是类似的。<br>如果使用 final 修饰函数，只能<code>修饰虚函数</code>，并且 要把 <code>final关键字放到类或者函数的后面。</code></p>
<h3 id="5-1-final-修饰函数"><a href="#5-1-final-修饰函数" class="headerlink" title="5.1 final 修饰函数"></a>5.1 final 修饰函数</h3><p>如果使用<code>final</code>修饰函数，只能<code>修饰虚函数</code>，这样就能<strong>阻止子类重写父类的这个函数</strong>了：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Base class..."</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">final</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Child class..."</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">GrandChild</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Child</span></span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment">// 语法错误, 不允许重写</span>
    <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"GrandChild class..."</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="5-2-final-修饰类"><a href="#5-2-final-修饰类" class="headerlink" title="5.2 final 修饰类"></a>5.2 final 修饰类</h3><p>使用<code>final关键字</code>修饰过的类是<code>不允许被继承</code>的，也就是说这个类<strong>不能有派生类</strong>。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Person</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                                                 <span class="token comment">// 定义纯虚函数</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">finalRun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">final</span> <span class="token punctuation">&#123;</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Person::finalRun()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">// 定义final修饰的虚函数</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">SportsMan</span> <span class="token keyword">final</span> <span class="token operator">:</span> <span class="token keyword">public</span> Person
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">override</span> <span class="token punctuation">&#123;</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"SportsMan::run()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>
    <span class="token keyword">void</span> <span class="token function">finalRun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">override</span> <span class="token punctuation">&#123;</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"SportsMan::finalRun()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">// 无法重写final修饰的虚函数</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">FinalAthlete</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">SportsMan</span> <span class="token comment">// 不允许继承final修饰的类</span></span>
<span class="token punctuation">&#123;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="5-3-overide"><a href="#5-3-overide" class="headerlink" title="5.3 overide"></a>5.3 overide</h3><p><code>override关键字</code>确保在派生类中声明的重写函数与基类的虚函数有<strong>相同的签名</strong>，同时也明确<code>表明</code>将会重写基类的虚函数，这样就可以保证重写的虚函数的正确性，也提高了代码的可读性，和<code>final</code>一样这个关键字要写到方法的后面。使用方法如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Object_My</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">print_a</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Object_My::print_a()"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">ClassA</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Object_My</span></span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">override</span>
    <span class="token punctuation">&#123;</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ClassA::print()"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Object_My <span class="token operator">*</span>obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ClassA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将子类对象指针指向父类对象,用来实现多态</span>
    obj<span class="token operator">-></span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment">// 子类虚函数表寻址,调用子类的print()函数</span>
    obj<span class="token operator">-></span><span class="token function">print_a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 调用父类的print_a()函数,因为子类没有重写该函数</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="6-模板的优化"><a href="#6-模板的优化" class="headerlink" title="6.模板的优化"></a>6.模板的优化</h2><h3 id="6-1-模板嵌套右尖括号的优化"><a href="#6-1-模板嵌套右尖括号的优化" class="headerlink" title="6.1 模板嵌套右尖括号的优化"></a>6.1 模板嵌套右尖括号的优化</h3><p>在泛型编程中，模板实例化有一个非常繁琐的地方，那就是<code>连续的两个右尖括号（&gt;&gt;）</code>会被编译器解析成<code>右移操作符</code>，而不是模板参数表的结束。我们先来看一段关于容器遍历的代码，在创建的类模板<code>Base</code>中提供了遍历容器的操作函数<code>traversal()</code>:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// test.cpp</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">class</span> <span class="token class-name">Base</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">traversal</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> t<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">auto</span> it <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> t<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>it<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>it <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>


<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v<span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    Base<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> b<span class="token punctuation">;</span>
    b<span class="token punctuation">.</span><span class="token function">traversal</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果使用<code>C++98/03</code>标准来编译上边的这段代码，就会得到如下的错误提示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">test.cpp:25:20: error: <span class="token string">'>>'</span> should be <span class="token string">'> >'</span> within a nested template argument list
     Base<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>int<span class="token operator">>></span> b<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>根据错误提示中描述模板的两个右尖括之间需要<strong>添加空格</strong>，这样写起来就非常的麻烦，<code>C++11</code>改进了编译器的解析规则，尽可能地将<code>多个右尖括号（&gt;）解析成模板参数结束符</code>，方便我们编写模板相关的代码。</p>
<p>上面的这段代码，在支持C++11的编译器中编译是没有任何问题的，如果使用g++直接编译需要加参数<code>-std=c++11</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">g++ test.cpp <span class="token parameter variable">-std</span><span class="token operator">=</span>c++11 <span class="token parameter variable">-o</span> app<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="6-2-默认模板参数"><a href="#6-2-默认模板参数" class="headerlink" title="6.2 默认模板参数"></a>6.2 默认模板参数</h3><p>在<code>C++98/03</code>标准中，<code>类模板</code>可以有默认的模板参数：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">=</span><span class="token keyword">int</span><span class="token punctuation">,</span> T t<span class="token operator">=</span><span class="token number">520</span><span class="token operator">></span>
<span class="token keyword">class</span> <span class="token class-name">Test</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"current value: "</span> <span class="token operator">&lt;&lt;</span> t <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Test<span class="token operator">&lt;</span><span class="token operator">></span> t<span class="token punctuation">;</span>
    t<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    Test<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token number">1024</span><span class="token operator">></span> t1<span class="token punctuation">;</span>
    t1<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>但是不支持函数的默认模板参数，在C++11中添加了对<code>函数模板</code>默认参数的支持:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">=</span><span class="token keyword">int</span><span class="token operator">></span>	<span class="token comment">// C++98/03不支持这种写法, C++11中支持这种写法</span>
<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"current value: "</span> <span class="token operator">&lt;&lt;</span> t <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">func</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>通过上面的例子可以得到如下结论：当<code>所有模板参数都有默认参数时，函数模板的调用如同一个普通函数</code>。但对于<code>类模板</code>而言，哪怕所有参数都有<strong>默认参数</strong>，在使用时也必须在模板名后跟随<code>&lt; &gt;</code>来实例化。</p>
<p><strong>另外：</strong>函数模板的默认模板参数在使用规则上和其他的默认参数也有一些不同，它没有必须写在<code>参数表最后的限制</code>。这样当默认模板参数和模板参数<code>自动推导</code>结合起来时，书写就显得非常灵活了。我们可以指定函数模板中的<strong>一部分模板参数使用默认参数，另一部分使用自动推导</strong>, 像下面的例子:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span> <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">,</span> T t <span class="token operator">=</span> <span class="token number">520</span><span class="token operator">></span>
<span class="token keyword">class</span> <span class="token class-name">Test</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"current value: "</span> <span class="token operator">&lt;&lt;</span> t <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span> <span class="token operator">=</span> <span class="token keyword">long</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">U</span> <span class="token operator">=</span> <span class="token keyword">int</span><span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">myTest</span><span class="token punctuation">(</span>T t <span class="token operator">=</span> <span class="token char">'A'</span><span class="token punctuation">,</span> U u <span class="token operator">=</span> <span class="token char">'B'</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"t = "</span> <span class="token operator">&lt;&lt;</span> t <span class="token operator">&lt;&lt;</span> <span class="token string">", u = "</span> <span class="token operator">&lt;&lt;</span> u <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 默认会将'A'和'B'转换为long, int类型</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span> y <span class="token operator">=</span> <span class="token number">10.0</span><span class="token punctuation">)</span> <span class="token comment">// 要么全部指定参数,要么将默认参数放在后面</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Test<span class="token operator">&lt;</span><span class="token operator">></span> t2<span class="token punctuation">;</span>
    t2<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    Test<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token number">1024</span><span class="token operator">></span> t1<span class="token punctuation">;</span>
    t1<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"==========\n"</span><span class="token punctuation">;</span>
    <span class="token function">myTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token comment">// 使用默认模板参数和默认函数参数</span>
    <span class="token function">myTest</span><span class="token punctuation">(</span><span class="token number">123L</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment">// 使用默认的 U 类型和自定义的 T 类型（long）</span>
    <span class="token generic-function"><span class="token function">myTest</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token char">'C'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment">// 使用自定义的 T 类型（char）和默认的 U 类型（int）</span>
    <span class="token generic-function"><span class="token function">myTest</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">,</span> <span class="token number">3.14f</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 完全指定模板参数和默认函数参数</span>

    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"==========\n"</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>       <span class="token comment">// 使用默认参数</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">25.0</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 自定义参数</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>对于上述调用，<strong>输出将是：</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">current value: <span class="token number">520</span>
current value: <span class="token number">1024</span>
<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>
t <span class="token operator">=</span> <span class="token number">65</span>, u <span class="token operator">=</span> <span class="token number">66</span>  // <span class="token string">'A'</span> 和 <span class="token string">'B'</span> 的 ASCII 值
t <span class="token operator">=</span> <span class="token number">123</span>, u <span class="token operator">=</span> <span class="token number">66</span> // <span class="token number">123</span> 是 long 类型，<span class="token string">'B'</span> 是 int 类型
t <span class="token operator">=</span> <span class="token number">67</span>, u <span class="token operator">=</span> <span class="token number">66</span>  // <span class="token string">'C'</span> 是 char 类型，<span class="token string">'B'</span> 是 int 类型
t <span class="token operator">=</span> <span class="token number">42</span>, u <span class="token operator">=</span> <span class="token number">3.14</span> // <span class="token number">42</span> 是 int 类型，3.14 是 float 类型
<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>
<span class="token number">20</span>
<span class="token number">45</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>当<code>默认模板参数</code>和<code>模板参数自动推导</code>同时使用时（<code>优先级从高到低</code>）：</p>
<ul>
<li><code>如果可以推导出参数类型则使用推导出的类型</code></li>
<li><code>如果函数模板无法推导出参数类型，那么编译器会使用默认模板参数</code></li>
<li><code>如果无法推导出模板参数类型并且没有设置默认模板参数，编译器就会报错。</code></li>
<li>当有多个模板类型却只指定少于实际的模板类型,从左到右依次赋值</li>
</ul>
<p>再看下面的例子:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token comment">// 函数模板定义</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">U</span> <span class="token operator">=</span> <span class="token keyword">char</span><span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>T arg1 <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">,</span> U arg2 <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"arg1: "</span> <span class="token operator">&lt;&lt;</span> arg1 <span class="token operator">&lt;&lt;</span> <span class="token string">", arg2: "</span> <span class="token operator">&lt;&lt;</span> arg2 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 模板函数调用</span>
    <span class="token function">func</span><span class="token punctuation">(</span><span class="token char">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">func</span><span class="token punctuation">(</span><span class="token number">97</span><span class="token punctuation">,</span> <span class="token char">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// func();    //编译报错,默认的模板参数不全,默认的函数参数不能用于类型推导</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="7-using关键字"><a href="#7-using关键字" class="headerlink" title="7.using关键字"></a>7.using关键字</h2><blockquote>
<p>在<code>C++11</code>之前, <code>using关键字</code>一般有两种用法:</p>
<ul>
<li>引入<code>命名空间</code>，这样可以使用命名空间里的函数和变量，防止命名冲突</li>
<li><strong>派生类</strong>使用基类的成员或者函数</li>
</ul>
</blockquote>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token comment">// using namespace std; // using声明命名空间后可以省略命名空间，直接使用cout</span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>cout<span class="token punctuation">;</span> <span class="token comment">// 也可以只使用using声明命名空间中的一个对象</span>
<span class="token keyword">class</span> <span class="token class-name">Base</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> a<span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Base::print()"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">using</span> Base<span class="token double-colon punctuation">::</span>a<span class="token punctuation">;</span>     <span class="token comment">// 继承父类的a成员</span>
    <span class="token keyword">using</span> Base<span class="token double-colon punctuation">::</span>print<span class="token punctuation">;</span> <span class="token comment">// 继承父类的print成员</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello, world!\n"</span><span class="token punctuation">;</span>
    Child c<span class="token punctuation">;</span>
    c<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出Child::print()</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="7-1-给类定义别名"><a href="#7-1-给类定义别名" class="headerlink" title="7.1 给类定义别名"></a>7.1 给类定义别名</h3><p><strong>在c++中</strong>，可以用 <code>typedef</code> 重定义一个类型，语法如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">typedef</span> 旧的类型名 新的类型名<span class="token punctuation">;</span>
<span class="token comment">// 使用举例</span>
<span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> uint_t<span class="token punctuation">;</span>

<span class="token keyword">unsigned</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
uint_t b <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>typedef</code> 重定义的类型并不是一个新的类型，仅仅只是<strong>原有的类型取了一个新的名字</strong>。和以前的声明语句一样，这里的声明符也可以包含类型修饰(例如<code>const</code>，<code>volatile</code>），从而也能由基本数据类型构造出**复合类型(指针或者数组)**来。C++11中规定了一种新的方法，使用别名声明(alias declaration)来定义类型的别名，即使用 <code>using</code>。</p>
<p>在使用的时候，关键字 <code>using</code> 作为别名声明的开始，其后紧跟别名和等号，其作用是把等号左侧的名字规定成等号右侧类型的别名。<code>类型别名和类型的名字等价，只要是类型的名字能出现的地方，就能使用类型别名。使用typedef定义的别名和使用using定义的别名在语义上是等效的。</code></p>
<p>使用using定义别名的语法格式是这样的：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">using</span> 新的类型 <span class="token operator">=</span> 旧的类型<span class="token punctuation">;</span>
<span class="token comment">// 使用举例</span>
<span class="token keyword">using</span> uint_t <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>通过<code>using</code>和<code>typedef</code>的语法格式可以看到二者的使用没有太大的区别，假设我们定义一个<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_27825451/article/details/103081289">函数指针</a>，<code>using</code>的优势就能凸显出来了，看一下下面的例子：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 使用typedef定义函数指针</span>
<span class="token keyword">typedef</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span>func_ptr<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 使用using定义函数指针</span>
<span class="token keyword">using</span> func_ptr1 <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token comment">// using定义别名</span>
<span class="token keyword">using</span> u_int <span class="token operator">=</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">;</span>
u_int a <span class="token operator">=</span> <span class="token number">64</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"add("</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> <span class="token string">")="</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">+</span> b <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">// 函数指针类型定义, 这两种方法同效果</span>
<span class="token keyword">typedef</span> <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>add_ptr<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">using</span> add_ptr_ <span class="token operator">=</span> <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    add_ptr func <span class="token operator">=</span> add<span class="token punctuation">;</span>
    <span class="token comment">// add_ptr_ func = add;</span>
    
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>add_func<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">=</span> add<span class="token punctuation">;</span>
    <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">,</span> <span class="token char">'c'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 不使用别名</span>
    <span class="token function">func</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">(</span><span class="token operator">*</span>func<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="7-2-给模板定义别名"><a href="#7-2-给模板定义别名" class="headerlink" title="7.2 给模板定义别名"></a>7.2 给模板定义别名</h3><p>使用<code>typedef重定义类</code>时很方便，但是它有一点限制，比如无法<code>重定义一个模板</code>，比如我们需要一个<code>固定以int类型为key的map</code>，它可以和很多类型的<code>value</code>值进行映射，如果使用<code>typedef</code>这样直接定义就非常麻烦:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">typedef</span> map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token operator">></span> map_s<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> map_i<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token operator">></span> map_d<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>在这种情况下我们就不自觉的想到了模板：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">typedef</span> map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> T<span class="token operator">></span> type<span class="token punctuation">;</span>	<span class="token comment">// error, 语法错误</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>使用<strong>typename不支持给模板定义别名</strong>，这个简单的需求仅通过<code>typedef</code>很难办到，需要添加一个<code>外敷类</code>：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;functional></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;map></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token comment">// 定义外敷类</span>
<span class="token keyword">struct</span> <span class="token class-name">MyMap</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">typedef</span> map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> T<span class="token operator">></span> type<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    MyMap<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token double-colon punctuation">::</span>type m<span class="token punctuation">;</span>
    m<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token function">make_pair</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"luffy"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    m<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token function">make_pair</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"ace"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    MyMap<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token double-colon punctuation">::</span>type m1<span class="token punctuation">;</span>
    m1<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    m1<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>通过上边的例子可以直观的感觉到，需求简单但是实现起来并不容易。在<code>C++11</code>中，新增了一个特性就是可以通过<code>使用using来为一个模板定义别名</code>，对于上面的需求可以写成这样：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/* 使用using为模板定义别名 */</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">using</span> MyMap <span class="token operator">=</span> map<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>完整的实例代码如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;map></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">struct</span> <span class="token class-name">MyContainer</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span>T <span class="token operator">&amp;</span>t<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> iter <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> iter <span class="token operator">!=</span> t<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> iter<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            cout <span class="token operator">&lt;&lt;</span> iter<span class="token operator">-></span>first <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> iter<span class="token operator">-></span>second <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token comment">/* 使用using为模板定义别名 */</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">using</span> MyMap <span class="token operator">=</span> map<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    MyMap<span class="token operator">&lt;</span>string<span class="token operator">></span> map<span class="token punctuation">;</span> <span class="token comment">// ok</span>
    map<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">pair</span><span class="token generic class-name"><span class="token operator">&lt;</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    map<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">pair</span><span class="token generic class-name"><span class="token operator">&lt;</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    map<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">pair</span><span class="token generic class-name"><span class="token operator">&lt;</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    MyContainer<span class="token operator">&lt;</span>MyMap<span class="token operator">&lt;</span>string<span class="token operator">>></span> c<span class="token punctuation">;</span> <span class="token comment">// ok</span>
    c<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment">// ok</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面的例子中通过使用<code>using给模板指定别名</code>，就可以基于别名非常方便的给<code>value</code>指定相应的类型，这样使编写的程序变得更加灵活，看起来也更加简洁一些。</p>
<p>最后在强调一点：<code>using</code>语法和<code>typedef</code>一样，并不会创建出新的类型，它们只是给<strong>某些类型定义了新的别名</strong>。<code>using相较于typedef的优势在于定义函数指针别名时看起来更加直观，并且可以给模板定义别名。</code></p>
<h2 id="8-委托构造和继承构造"><a href="#8-委托构造和继承构造" class="headerlink" title="8.委托构造和继承构造"></a>8.委托构造和继承构造</h2><h3 id="8-1-委托构造函数"><a href="#8-1-委托构造函数" class="headerlink" title="8.1 委托构造函数"></a>8.1 委托构造函数</h3><p>在一个类中，常常会<code>重载多个构造函数</code>以适应不同的需求，<strong>在C++11之前</strong>，即便是同一个类的构造函数之间也不能互相调用，而<strong>在C++11之后</strong>，提出了<code>委托构造函数的概念</code>: 委托构造函数允许使用同一个类中的一个构造函数调用其它的构造函数，从而简化相关变量的初始化。下面举例说明:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">enum</span> <span class="token class-name">Gender</span>
<span class="token punctuation">&#123;</span>
    Male<span class="token punctuation">,</span>
    Female
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Person</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> i_age<span class="token punctuation">;</span>
    string s_name<span class="token punctuation">;</span>
    Gender s_gender<span class="token punctuation">;</span>
    
    <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        i_age <span class="token operator">=</span> age<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">,</span> string name<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        i_age <span class="token operator">=</span> age<span class="token punctuation">;</span> <span class="token comment">// 冗余代码</span>
        s_name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">,</span> string name<span class="token punctuation">,</span> Gender gender<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        i_age <span class="token operator">=</span> age<span class="token punctuation">;</span>   <span class="token comment">// 冗余代码</span>
        s_name <span class="token operator">=</span> name<span class="token punctuation">;</span> <span class="token comment">// 冗余代码</span>
        s_gender <span class="token operator">=</span> gender<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上面的程序中有三个构造函数，但是这三个函数中都有重复的代码，在C++11之前构造函数是不能调用构造函数的，加入了委托构造之后，我们就可以轻松地完成代码的优化了：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">enum</span> <span class="token class-name">Gender</span>
<span class="token punctuation">&#123;</span>
    Male<span class="token punctuation">,</span>
    Female
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Person</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> i_age<span class="token punctuation">;</span>
    string s_name<span class="token punctuation">;</span>
    Gender s_gender <span class="token operator">=</span> Gender<span class="token double-colon punctuation">::</span>Male<span class="token punctuation">;</span>
    <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        i_age <span class="token operator">=</span> age<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">,</span> string name<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">Person</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>

        s_name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">,</span> string name<span class="token punctuation">,</span> Gender gender<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">Person</span><span class="token punctuation">(</span>age<span class="token punctuation">,</span> name<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>

        s_gender <span class="token operator">=</span> gender<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        string genderStr <span class="token operator">=</span> <span class="token punctuation">(</span>s_gender <span class="token operator">==</span> Male<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token string">"Male"</span> <span class="token operator">:</span> <span class="token string">"Female"</span><span class="token punctuation">;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"age: "</span> <span class="token operator">&lt;&lt;</span> i_age <span class="token operator">&lt;&lt;</span> <span class="token string">" name: "</span> <span class="token operator">&lt;&lt;</span> s_name <span class="token operator">&lt;&lt;</span> <span class="token string">" gender: "</span> <span class="token operator">&lt;&lt;</span> genderStr <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Person <span class="token function">p1</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token string">"luffy"</span><span class="token punctuation">,</span> Male<span class="token punctuation">)</span><span class="token punctuation">;</span>
    Person <span class="token function">p2</span><span class="token punctuation">(</span><span class="token number">25</span><span class="token punctuation">,</span> <span class="token string">"zoro1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Person <span class="token function">p3</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">,</span> <span class="token string">"sanji"</span><span class="token punctuation">,</span> Female<span class="token punctuation">)</span><span class="token punctuation">;</span>

    p1<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    p2<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    p3<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>注意事项：</code></p>
<ol>
<li><code>这种链式的构造函数调用不能形成一个闭环（死循环），否则会在运行期抛异常。</code></li>
<li><code>如果要进行多层构造函数的链式调用，建议将构造函数的调用的写在初始列表中而不是函数体内部，否则编译器会提示形参的重复定义。</code></li>
<li><code>在初始化列表中调用了代理构造函数初始化某个类成员变量之后，就不能在初始化列表中再次初始化这个变量了。</code></li>
</ol>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 错误, 使用了委托构造函数就不能再次m_max初始化了</span>
<span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">int</span> age_<span class="token punctuation">,</span> string name<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">Person</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">age</span><span class="token punctuation">(</span>age_<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">this</span><span class="token operator">-></span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="8-2-继承构造函数"><a href="#8-2-继承构造函数" class="headerlink" title="8.2 继承构造函数"></a>8.2 继承构造函数</h3><p><code>C++11中提供的继承构造函数</code>可以让<code>派生类直接使用基类的构造函数</code>，而无需自己再写构造函数，尤其是在基类有很多构造函数的情况下，可以极大地简化派生类构造函数的编写。先来看没有继承构造函数之前的处理方式：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Base</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">m_i</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">double</span> j<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">m_i</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_j</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">double</span> j<span class="token punctuation">,</span> string k<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">m_i</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_j</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_k</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

    <span class="token keyword">int</span> m_i<span class="token punctuation">;</span>
    <span class="token keyword">double</span> m_j<span class="token punctuation">;</span>
    string m_k<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Child</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">Base</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    <span class="token function">Child</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">double</span> j<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">Base</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    <span class="token function">Child</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">double</span> j<span class="token punctuation">,</span> string k<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">Base</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Child <span class="token function">c</span><span class="token punctuation">(</span><span class="token number">520</span><span class="token punctuation">,</span> <span class="token number">13.14</span><span class="token punctuation">,</span> <span class="token string">"i love you"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"int: "</span> <span class="token operator">&lt;&lt;</span> c<span class="token punctuation">.</span>m_i <span class="token operator">&lt;&lt;</span> <span class="token string">", double: "</span> 
         <span class="token operator">&lt;&lt;</span> c<span class="token punctuation">.</span>m_j <span class="token operator">&lt;&lt;</span> <span class="token string">", string: "</span> <span class="token operator">&lt;&lt;</span> c<span class="token punctuation">.</span>m_k <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>可以看出，<code>即便是子类中只需要使用和基类一样的函数体也需要重新声明一遍子类的构造函数</code>,这是非常繁琐的，C++11中通过添加继承构造函数这个新特性完美的解决了这个问题，使得代码更加精简。</p>
<p>继承构造函数的使用方法是这样的：通过使用<code>using 类名::构造函数名</code>（其实类名和构造函数名是一样的）来<code>声明使用基类的构造函数</code>，这样子类中就可以不定义相同的构造函数了，直接使用基类的构造函数来构造派生类对象。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Base</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">m_i</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">double</span> j<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">m_i</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_j</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">double</span> j<span class="token punctuation">,</span> string k<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">m_i</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_j</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_k</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

    <span class="token keyword">int</span> m_i<span class="token punctuation">;</span>
    <span class="token keyword">double</span> m_j<span class="token punctuation">;</span>
    string m_k<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">using</span> Base<span class="token double-colon punctuation">::</span>Base<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Child <span class="token function">c</span><span class="token punctuation">(</span><span class="token number">520</span><span class="token punctuation">,</span> <span class="token number">13.14</span><span class="token punctuation">,</span> <span class="token string">"i love you"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"int: "</span> <span class="token operator">&lt;&lt;</span> c<span class="token punctuation">.</span>m_i <span class="token operator">&lt;&lt;</span> <span class="token string">", double: "</span>
         <span class="token operator">&lt;&lt;</span> c<span class="token punctuation">.</span>m_j <span class="token operator">&lt;&lt;</span> <span class="token string">", string: "</span> <span class="token operator">&lt;&lt;</span> c<span class="token punctuation">.</span>m_k <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在修改之后的子类中，没有添加任何构造函数，而是添加了<code>using Base::Base;</code>这样就可以在子类中直接继承父类的所有的构造函数，通过他们去构造子类对象了。</p>
<p>另外如果在子类中隐藏了父类中的同名函数，也可以通过<code>using</code>的方式在子类中使用基类中的这些父类函数：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Base</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">m_i</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">double</span> j<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">m_i</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_j</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">double</span> j<span class="token punctuation">,</span> string k<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">m_i</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_j</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_k</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

    <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"base class: i = "</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    
    <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> string str<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"base class: i = "</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">", str = "</span> <span class="token operator">&lt;&lt;</span> str <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">int</span> m_i<span class="token punctuation">;</span>
    <span class="token keyword">double</span> m_j<span class="token punctuation">;</span>
    string m_k<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">using</span> Base<span class="token double-colon punctuation">::</span>Base<span class="token punctuation">;</span>
    <span class="token keyword">using</span> Base<span class="token double-colon punctuation">::</span>func<span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"child class: i'am luffy!!!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Child <span class="token function">c</span><span class="token punctuation">(</span><span class="token number">250</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    c<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    c<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token number">19</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    c<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token number">19</span><span class="token punctuation">,</span> <span class="token string">"luffy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上述示例代码输出的结果为：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">child class: i'am luffy<span class="token operator">!</span><span class="token operator">!</span><span class="token operator">!</span>
base class: i <span class="token operator">=</span> <span class="token number">19</span>
base class: i <span class="token operator">=</span> <span class="token number">19</span>, str <span class="token operator">=</span> luffy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>子类中的<code>func()函数</code>隐藏了<code>基类中的两个func()</code>，因此默认情况下通过子类对象只能调用无参的func()，在上面的子类代码中添加了<code>using Base::func;</code>之后，就可以通过子类对象直接调用父类中被隐藏的带参func()函数了。</p>
<h2 id="9-初始化列表"><a href="#9-初始化列表" class="headerlink" title="9.初始化列表"></a>9.初始化列表</h2><p>关于C++中的<code>变量，数组，对象</code>等都有<code>不同的初始化方法</code>，在这些繁琐的初始化方法中没有任何一种方式适用于所有的情况。为了统一初始化方式，并且让初始化行为具有确定的效果，在C++11中提出了<code>列表初始化</code>的概念。</p>
<h3 id="9-1-统一的初始化方式"><a href="#9-1-统一的初始化方式" class="headerlink" title="9.1 统一的初始化方式"></a>9.1 统一的初始化方式</h3><p>在C++98&#x2F;03中，对应普通数组和可以直接进行<code>内存拷贝（memcpy()）</code>的对象是可以使用列表初始化来初始化数据的</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 数组的初始化</span>
<span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">9</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">double</span> array1<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">1.2</span><span class="token punctuation">,</span> <span class="token number">1.3</span><span class="token punctuation">,</span> <span class="token number">1.4</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token comment">// 对象的初始化</span>
<span class="token keyword">struct</span> <span class="token class-name">Person</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> id<span class="token punctuation">;</span>
    <span class="token keyword">double</span> salary<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>zhang3<span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3000</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在<code>C++11</code>后,变得更加多样和灵活了,看一下下面的例子:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Test</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">const</span> Test <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Test <span class="token function">t1</span><span class="token punctuation">(</span><span class="token number">520</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 调用默认构造函数</span>
    Test t2 <span class="token operator">=</span> <span class="token number">520</span><span class="token punctuation">;</span>   <span class="token comment">// 520会被编译器自动转换为int类型，然后调用默认构造函数构建(临时)匿名对象,然后通过拷贝构造函数赋值给t2</span>
    Test t3 <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">520</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// c++11新特性：列表初始化</span>
    Test t4<span class="token punctuation">&#123;</span><span class="token number">520</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token comment">// c++11新特性：列表初始化</span>
    <span class="token keyword">int</span> a1 <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1314</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> a2<span class="token punctuation">&#123;</span><span class="token number">1314</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> arr1<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> arr2<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>既然<code>列表初始化</code>可以对普通类型和对象进行直接初始化，那么自然也可以对<code>使用new关键字</code>动态分配的对象进行列表初始化：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">&#123;</span><span class="token number">520</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">double</span> b <span class="token operator">=</span> <span class="token keyword">double</span><span class="token punctuation">&#123;</span><span class="token number">52.134</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
Test <span class="token operator">*</span>test <span class="token operator">=</span> <span class="token keyword">new</span> Test<span class="token punctuation">&#123;</span><span class="token number">50</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>不仅如此，还可以用在<code>函数的返回值</code>上，返回一个匿名对象</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Person</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">,</span> string name<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"id: "</span> <span class="token operator">&lt;&lt;</span> id <span class="token operator">&lt;&lt;</span> <span class="token string">", name: "</span> <span class="token operator">&lt;&lt;</span> name <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

Person <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span> <span class="token number">9527</span><span class="token punctuation">,</span> <span class="token string">"华安"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Person p <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>代码中的<code>return &#123; 9527, &quot;华安&quot; &#125;;</code>就相当于<code>return (9527, &quot;华安&quot; );</code>，直接返回了一个<code>匿名对象</code>。通过上面的几个例子可以看出在<strong>C++11使用列表初始化是非常便利的</strong>，它统一了各种对象的初始化方式，而且还让代码的书写更加简单清晰。</p>
<h3 id="9-2-列表初始化细节"><a href="#9-2-列表初始化细节" class="headerlink" title="9.2 列表初始化细节"></a>9.2 列表初始化细节</h3><p>在C++11中，只要是<code>聚合类型都能使用列表初始化</code>进行直接的初始化方式。(例如数组)</p>
<ul>
<li><code>普通数组本身可以看作一个聚合类型</code></li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> x<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">double</span> y<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
    <span class="token punctuation">&#123;</span><span class="token number">1.23</span><span class="token punctuation">,</span> <span class="token number">2.34</span><span class="token punctuation">,</span> <span class="token number">3.45</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
    <span class="token punctuation">&#123;</span><span class="token number">4.56</span><span class="token punctuation">,</span> <span class="token number">5.67</span><span class="token punctuation">,</span> <span class="token number">6.78</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
    <span class="token punctuation">&#123;</span><span class="token number">7.89</span><span class="token punctuation">,</span> <span class="token number">8.91</span><span class="token punctuation">,</span> <span class="token number">9.99</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> carry<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token char">'a'</span><span class="token punctuation">,</span> <span class="token char">'b'</span><span class="token punctuation">,</span> <span class="token char">'c'</span><span class="token punctuation">,</span> <span class="token char">'d'</span><span class="token punctuation">,</span> <span class="token char">'e'</span><span class="token punctuation">,</span> <span class="token char">'f'</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>string sarry<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token string">"world"</span><span class="token punctuation">,</span> <span class="token string">"nihao"</span><span class="token punctuation">,</span> <span class="token string">"shijie"</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="a-聚合体"><a href="#a-聚合体" class="headerlink" title="a. 聚合体"></a>a. 聚合体</h4><p>在C++中，<code>聚合体（Aggregate）</code>是指一种特殊的类类型，它满足以下条件：</p>
<ol>
<li>没有<code>用户定义的构造函数（即没有自定义的构造函数，包括默认构造函数）</code>。</li>
<li>没有<code>私有（private）或保护（protected）的非静态数据成员</code>。</li>
<li>没有<code>基类（即不是派生类）</code>。</li>
<li>没有<code>虚（virtual）函数</code>。</li>
</ol>
<p>聚合体的特点是可以使用列表初始化来初始化其成员，例如：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">Test</span> <span class="token comment">// 聚合体类型</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> x<span class="token punctuation">;</span>
    <span class="token keyword">int</span> y<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">Test2</span> <span class="token comment">// 非聚合体类型</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> x<span class="token punctuation">;</span>
    <span class="token keyword">int</span> y<span class="token punctuation">;</span>
    <span class="token function">Test2</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">x</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">y</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Test t1 <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token comment">// x=1, y=2</span>
    Test2 t2 <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// x=10, y=20</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p><code>Test2类的对象t2</code>使用初始化列表进行初始化，你会发现x，y的值并没有按照初始化列表中的来，这是因为<code>Test2类</code>中定义了一个自定义的构造函数（不在把它当作一个简单的类型的聚合），所以系统在使用初始化列表的时候，将会调用它定义的构造函数</p>
</li>
<li><p><code>对象t1是对一个自定义的聚合类型进行初始化，它将以拷贝的形式使用初始化列表中的数据来初始化T1结构体中的成员。</code></p>
</li>
</ul>
<p>聚合体类型可以使用初始化列表进行初始化，但还有一种情况是不支持的（在c++11）</p>
<ul>
<li>类中不能有使用<code>&#123;&#125;</code>和<code>=</code>直接初始化的<code>非静态数据成员</code>（从c++14开始就支持了）</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">T2</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> x<span class="token punctuation">;</span>
    <span class="token keyword">long</span> y<span class="token punctuation">;</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> z<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>t1<span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">100</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>		<span class="token comment">// ok</span>
<span class="token comment">// 静态成员的初始化</span>
<span class="token keyword">int</span> T2<span class="token double-colon punctuation">::</span>z <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">T3</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> x<span class="token punctuation">;</span>
    <span class="token keyword">double</span> y <span class="token operator">=</span> <span class="token number">1.34</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> z<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    T3 t<span class="token punctuation">&#123;</span><span class="token number">520</span><span class="token punctuation">,</span> <span class="token number">13.14</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>		<span class="token comment">// error, c++11不支持,从c++14开始就支持了</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="b-非聚合体"><a href="#b-非聚合体" class="headerlink" title="b. 非聚合体"></a>b. 非聚合体</h4><p>对于聚合类型的类可以直接使用列表初始化进行对象的初始化，<code>如果不满足聚合条件还想使用列表初始化其实也是可以的，需要在类的内部自定义一个构造函数, 在构造函数中使用初始化列表对类成员变量进行初始化</code>:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">T1</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> x<span class="token punctuation">;</span>
    <span class="token keyword">double</span> y<span class="token punctuation">;</span>
    <span class="token comment">// 在构造函数中使用初始化列表初始化类成员</span>
    <span class="token function">T1</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">double</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">x</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">y</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">z</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"x: "</span> <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> <span class="token string">", y: "</span> <span class="token operator">&lt;&lt;</span> y <span class="token operator">&lt;&lt;</span> <span class="token string">", z: "</span> <span class="token operator">&lt;&lt;</span> z <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> z<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    T1 t<span class="token punctuation">&#123;</span> <span class="token number">520</span><span class="token punctuation">,</span> <span class="token number">13.14</span><span class="token punctuation">,</span> <span class="token number">1314</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>	<span class="token comment">// ok, 基于构造函数使用初始化列表初始化类成员</span>
    t<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>另外，需要额外注意的是<code>聚合类型的定义并非递归的</code>，也就是说<code>当一个类的非静态成员是非聚合类型时，这个类也可能是聚合类型</code>，比如下面的这个例子：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">T1</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> x<span class="token punctuation">;</span>
    <span class="token keyword">double</span> y<span class="token punctuation">;</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> z<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">T2</span>
<span class="token punctuation">&#123;</span>
    T1 t1<span class="token punctuation">;</span>
    <span class="token keyword">long</span> x1<span class="token punctuation">;</span>
    <span class="token keyword">double</span> y1<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    T2 t2<span class="token punctuation">&#123;</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">520</span><span class="token punctuation">,</span> <span class="token number">13.14</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>可以看到，T1并非一个聚合类型，因为它有一个<code>private的非静态成员</code>。但是尽管T2有一个非聚合类型的非静态成员t1，T2依然是一个聚合类型，可以直接使用列表初始化的方式进行初始化。</p>
<p>最后强调一下t2对象的初始化过程，对于非聚合类型的成员t1做初始化的时候，可以直接写一对<code>空的大括号&#123;&#125;</code>，这相当于<code>调用是T1的无参构造函数</code>。</p>
<blockquote>
<p>对于一个聚合类型，使用<code>列表初始化相当于对其中的每个元素分别赋值</code>，而对于非聚合类型，则需要先自定义一个合适的构造函数，此时<code>使用列表初始化将会调用它对应的构造函数</code>。</p>
</blockquote>
<h3 id="9-3-std-initializer-list"><a href="#9-3-std-initializer-list" class="headerlink" title="9.3 std::initializer_list"></a>9.3 std::initializer_list</h3><p>在C++的STL容器中，可以进行<code>任意长度的相同类型数据的初始化</code>，使用初始化列表也只能进行固定参数的初始化，如果想要做到和STL一样有任意长度初始化的能力，可以使用std::initializer_list这个轻量级的类模板来实现。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v1<span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v2<span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>先来介绍一下这个<code>类模板</code>的一些特点：</p>
<ul>
<li>它是一个<code>轻量级的容器类型</code>，内部定义了迭代器iterator等容器必须的概念，遍历时得到的迭代器是<strong>只读的</strong>。</li>
<li>对于<code>std::initializer_list&lt;T&gt;</code>而言，它可以接收任意长度的初始化列表，但是要求元素必须是同种类型T</li>
<li>在<code>std::initializer_list</code>内部有三个成员接口：<code>size()</code>, <code>begin()</code>, <code>end()</code>。</li>
<li><code>std::initializer_list</code>对象只能被整体初始化或者赋值。</li>
</ul>
<blockquote>
<ol>
<li><strong>私有构造函数</strong></li>
</ol>
<ul>
<li><p><code>initializer_list</code> 类有一个<code>私有构造函数</code>，它接受两个参数：一个指向数组的指针和数组的长度。这个构造函数由编译器调用，用于初始化 <code>initializer_list</code> 对象。</p>
</li>
<li><p>这个构造函数的定义如下：</p>
  <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">constexpr</span> <span class="token function">initializer_list</span><span class="token punctuation">(</span>const_iterator __a<span class="token punctuation">,</span> size_type __l<span class="token punctuation">)</span>
<span class="token operator">:</span> <span class="token function">_M_array</span><span class="token punctuation">(</span>__a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_M_len</span><span class="token punctuation">(</span>__l<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>其中，<code>_M_array</code> 是指向列表中第一个元素的指针，<code>_M_len</code> 是列表中元素的数量。</p>
</li>
</ul>
<ol start="2">
<li><strong>编译器的隐式调用</strong></li>
</ol>
<ul>
<li><p>当你使用初始化列表语法 <code>&#123;1, 2, 3&#125;</code> 来创建 <code>initializer_list</code> 对象时，编译器会自动调用这个私有构造函数。编译器会生成一个临时数组，将 <code>&#123;1, 2, 3&#125;</code> 中的元素存储在这个数组中，然后将这个数组的指针和长度传递给私有构造函数。</p>
</li>
<li><p>例如：</p>
  <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">initializer_list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> l <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>编译器会生成类似以下的代码：</p>
  <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> __tmp<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
initializer_list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">l</span><span class="token punctuation">(</span>__tmp<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
</ul>
</blockquote>
<h4 id="a-作为普通函数参数"><a href="#a-作为普通函数参数" class="headerlink" title="a. 作为普通函数参数"></a>a. 作为普通函数参数</h4><p>如果想要自定义一个<code>函数并且接收任意个数的参数（变参函数）</code>，只需要将函数参数指定为<code>std::initializer_list</code>，使用<code>初始化列表&#123; &#125;</code>作为实参进行数据传递即可。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">traversal</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>initializer_list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> a<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>it<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>it <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    initializer_list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> list<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"current list size: "</span> <span class="token operator">&lt;&lt;</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token function">traversal</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>

    list <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">0</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"current list size: "</span> <span class="token operator">&lt;&lt;</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token function">traversal</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    
    list <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">9</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"current list size: "</span> <span class="token operator">&lt;&lt;</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token function">traversal</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token comment">////////////////////////////////////////////////////</span>
    <span class="token comment">////////////// 直接通过初始化列表传递数据 //////////////</span>
    <span class="token comment">////////////////////////////////////////////////////</span>
    <span class="token function">traversal</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token function">traversal</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> <span class="token number">11</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">13</span><span class="token punctuation">,</span><span class="token number">14</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">16</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>


    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>std::initializer_list</code>拥有<code>一个无参构造函数</code>，因此，它可以直接定义实例，此时将得到一个空的<code>std::initializer_list</code>，因为在遍历这种类型的容器的时候得到的是一个<code>只读的迭代器</code>，因此我们不能修改里边的数据。</p>
<p>在效率方面也无需担心，<code>std::initializer_list</code>的效率是非常高的，它的内部并不负责保存初始化列表中元素的拷贝，仅仅存储了初始化列表中元素的引用。</p>
<h4 id="b-作为构造函数参数"><a href="#b-作为构造函数参数" class="headerlink" title="b. 作为构造函数参数"></a>b. 作为构造函数参数</h4><p>自定义的类如果在构造对象的时候想要接收任意个数的实参，可以给构造函数指定为<code>std::initializer_list</code>类型，在自定义类的内部还是使用容器来存储接收的多个实参。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Test</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Test</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>initializer_list<span class="token operator">&lt;</span>string<span class="token operator">></span> list<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> list<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>it<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>it <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
            m_names<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token operator">*</span>it<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    vector<span class="token operator">&lt;</span>string<span class="token operator">></span> m_names<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Test <span class="token function">t</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> <span class="token string">"jack"</span><span class="token punctuation">,</span> <span class="token string">"lucy"</span><span class="token punctuation">,</span> <span class="token string">"tom"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Test <span class="token function">t1</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> <span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token string">"world"</span><span class="token punctuation">,</span> <span class="token string">"nihao"</span><span class="token punctuation">,</span> <span class="token string">"shijie"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="10-基于范围的for循环"><a href="#10-基于范围的for循环" class="headerlink" title="10.基于范围的for循环"></a>10.基于范围的for循环</h2><p>在C++98&#x2F;03之前，<code>不同的数组和容器有不同的遍历方式</code>，写法不统一，也不够简洁，而C++11基于范围的for循环可以以简洁、统一的方式来遍历容器和数组，用起来也更方便了。</p>
<h3 id="10-1-for循环的新语法"><a href="#10-1-for循环的新语法" class="headerlink" title="10.1 for循环的新语法"></a>10.1 for循环的新语法</h3><p>在介绍新的for循环语法之前，我们先来看传统的for循环的语法结构：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span><span class="token punctuation">(</span>表达式 <span class="token number">1</span><span class="token punctuation">;</span> 表达式 <span class="token number">2</span><span class="token punctuation">;</span> 表达式 <span class="token number">3</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 循环体</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>在介绍新语法之前，先来看一个使用迭代器遍历容器的例子：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> t<span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> t<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>it<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>it <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>我们在遍历的过程中需要给出容器的两端：开头（begin）和结尾（end），因为这种遍历方式不是基于范围来设计的。<code>在基于范围的for循环中，不需要再传递容器的两端，循环会自动以容器为范围展开，并且循环中也屏蔽掉了迭代器的遍历细节，直接抽取容器中的元素进行运算，使用这种方式进行循环遍历会让编码和维护变得更加简便。</code></p>
<p>C++11基于范围的for循环，语法格式：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span>declaration <span class="token operator">:</span> expression<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 循环体</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上面的语法格式中<code>declaration</code>表示遍历声明，在遍历过程中，当前被遍历到的元素会被存储到声明的变量中。<code>expression</code>是要遍历的对象，它可以是<code>表达式、容器、数组、初始化列表</code>等。</p>
<p>使用基于范围的for循环遍历容器，示例代码如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">:</span> v<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上面的例子中，<code>是将容器中遍历的当前元素拷贝到了声明的变量value中</code>，因此无法对容器中的元素进行写操作，如果需要在遍历过程中修改元素的值，需要使用引用。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;windows.h></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 设置控制台的输出代码页为 UTF-8</span>
    <span class="token function">SetConsoleOutputCP</span><span class="token punctuation">(</span>CP_UTF8<span class="token punctuation">)</span><span class="token punctuation">;</span>

    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> t<span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"遍历修改之前的容器: "</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>value <span class="token operator">:</span> t<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> value<span class="token operator">++</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    cout <span class="token operator">&lt;&lt;</span> endl
         <span class="token operator">&lt;&lt;</span> <span class="token string">"遍历修改之后的容器: "</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>value <span class="token operator">:</span> t<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> value <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>代码输出的结果：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">遍历修改之前的容器: <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span>
遍历修改之后的容器: <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span> <span class="token number">7</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>对容器的遍历过程中，如果<code>只是读数据</code>，不允许修改元素的值，可以使用<code>const</code>定义保存元素数据的变量，在定义的时候建议使用<code>const auto &amp;</code>，这样相对于<code>const auto</code>效率要更高一些。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> t<span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> value <span class="token operator">:</span> t<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> value <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="10-2-使用细节"><a href="#10-2-使用细节" class="headerlink" title="10.2 使用细节"></a>10.2 使用细节</h3><h4 id="a-关系型容器"><a href="#a-关系型容器" class="headerlink" title="a. 关系型容器"></a>a. 关系型容器</h4><p>使用基于范围的for循环有一些需要注意的细节，先来看一下对<code>关系型容器map</code>的遍历：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;map></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token operator">></span> m<span class="token punctuation">&#123;</span>
        <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"lucy"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"lily"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"tom"</span><span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

    <span class="token comment">// 基于范围的for循环方式</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> it <span class="token operator">:</span> m<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"id: "</span> <span class="token operator">&lt;&lt;</span> it<span class="token punctuation">.</span>first <span class="token operator">&lt;&lt;</span> <span class="token string">", name: "</span> <span class="token operator">&lt;&lt;</span> it<span class="token punctuation">.</span>second <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 普通的for循环方式</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">=</span> m<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> m<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>it<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"id: "</span> <span class="token operator">&lt;&lt;</span> it<span class="token operator">-></span>first <span class="token operator">&lt;&lt;</span> <span class="token string">", name: "</span> <span class="token operator">&lt;&lt;</span> it<span class="token operator">-></span>second <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上面的例子中使用两种方式对map进行了遍历，通过对比有两点需要注意的事项：</p>
<p><code>使用普通的for循环方式（基于迭代器）遍历关联性容器， auto自动推导出的是一个迭代器类型，需要使用迭代器的方式取出元素中的键值对（和指针的操作方法相同）</code>：</p>
<ul>
<li>it-&gt;first</li>
<li>it-&gt;second</li>
</ul>
<p><code>使用基于范围的for循环遍历关联性容器，auto自动推导出的类型是容器中的value_type，相当于一个对组（std::pair）对象，提取键值对的方式如下：</code></p>
<ul>
<li>it.first</li>
<li>it.second</li>
</ul>
<h4 id="b-元素只读"><a href="#b-元素只读" class="headerlink" title="b. 元素只读"></a>b. 元素只读</h4><p>通过对基于范围的for循环语法的介绍可以得知，在for循环内部声明一个变量的引用就可以修改遍历的表达式中的元素的值，但是这并不适用于所有的情况，对应<code>set容器</code>来说，<code>内部元素都是只读的</code>，这是由容器的特性决定的，因此在for循环中<code>auto&amp;</code>会被视为<code>const auto &amp; </code>。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;set></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> st<span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>item <span class="token operator">:</span> st<span class="token punctuation">)</span> 
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> item<span class="token operator">++</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>		<span class="token comment">// error, 不能给常量赋值</span>
        <span class="token comment">// 元素的值用于确定其在集合中的位置，并且集合要求元素是唯一的。如果允许修改元素的值，可能会破坏set的有序性和唯一性。</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>除此之外，在遍历关联型容器时也会出现同样的问题，基于范围的for循环中，虽然可以得到一个<code>std::pair引用</code>，但是我们是不能修改里边的<code>first</code>值的，也就是key值。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;map></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token operator">></span> m<span class="token punctuation">&#123;</span>
        <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"lucy"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"lily"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"tom"</span><span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> item <span class="token operator">:</span> m<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token comment">// item.first 是一个常量</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"id: "</span> <span class="token operator">&lt;&lt;</span> item<span class="token punctuation">.</span>first<span class="token operator">++</span> <span class="token operator">&lt;&lt;</span> <span class="token string">", name: "</span> <span class="token operator">&lt;&lt;</span> item<span class="token punctuation">.</span>second <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  <span class="token comment">// error</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="c-访问次数"><a href="#c-访问次数" class="headerlink" title="c. 访问次数"></a>c. 访问次数</h4><p>基于范围的for循环遍历的对象可以是一个<code>表达式或者容器/数组</code>等。假设我们对一个容器进行遍历，在遍历过程中for循环对这个容器的<code>访问频率</code>是一次还是多次呢？我们通过下面的例子验证一下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v<span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> <span class="token function">getRange</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"get vector range..."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> v<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> val <span class="token operator">:</span> <span class="token function">getRange</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> val <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>输出的结果如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">get vector range<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>从上面的结果中可以看到，不论基于范围的for循环迭代了多少次，<code>函数getRange()</code>只在第一次迭代之前被调用，得到这个容器对象之后就不会再去重新获取这个对象了。</p>
<blockquote>
<p>对应基于范围的for循环来说，冒号后边的表达式只会被执行一次。在得到遍历对象之后会先确定好迭代的范围，基于这个范围直接进行遍历。如果是普通的for循环，在每次迭代的时候都需要判断是否已经到了结束边界。</p>
</blockquote>
<h2 id="11-可调用对象包装器、绑定器"><a href="#11-可调用对象包装器、绑定器" class="headerlink" title="11.可调用对象包装器、绑定器"></a>11.可调用对象包装器、绑定器</h2><h3 id="11-1-可调用对象"><a href="#11-1-可调用对象" class="headerlink" title="11.1 可调用对象"></a>11.1 可调用对象</h3><p><strong>可调用对象（Callable）</strong> 是指可以像函数一样调用某些实体的对象。</p>
<ol>
<li>是一个<code>函数对象</code></li>
</ol>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">Func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"函数被调用"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<ol start="2">
<li><code>函数指针</code>，本质也是函数</li>
</ol>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">double</span> b<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">// 定义函数指针</span>
<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>func<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>print<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ol start="3">
<li><code>仿函数</code> - 重载了<code>()</code>操作符的类的对象</li>
</ol>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Test</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"hello world"</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token comment">// 3. 可调用对象--仿函数</span>
Test t1<span class="token punctuation">;</span>
<span class="token function">t1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ol start="4">
<li><code>是一个可被转换为函数指针的类对象   类型转换运算符</code> - 能够将<code>类对象转换为函数指针类型</code></li>
</ol>
<p><strong>类型转换运算符（Conversion Operator）</strong> 是一种可用于类的特殊成员函数，用于定义类到其他类型的隐式或显式转换。类型转换运算符的语法如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">operator</span> 类型<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li><strong>定义了如何将类对象转换为指定类型。</strong></li>
<li><strong>例如，可以将一个自定义类转换为内置数据类型或其他类类型。</strong></li>
</ul>
<blockquote>
<p><strong>示例：定义类型转换运算符</strong></p>
<p>假设有一个表示货币金额的类 <code>Money</code>，我们希望将其转换为 <code>double</code> 类型：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token operator">></span>#include <span class="token operator">&lt;</span>iostream<span class="token operator">></span>

<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Money</span> <span class="token punctuation">&#123;</span>
<span class="token operator">></span><span class="token keyword">private</span><span class="token operator">:</span>
   <span class="token keyword">double</span> amount<span class="token punctuation">;</span>

<span class="token operator">></span><span class="token keyword">public</span><span class="token operator">:</span>
   <span class="token function">Money</span><span class="token punctuation">(</span><span class="token keyword">double</span> amt<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">amount</span><span class="token punctuation">(</span>amt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

   <span class="token comment">// 定义类型转换运算符，将 Money 转换为 double</span>
   <span class="token keyword">operator</span> <span class="token keyword">double</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span>
       <span class="token keyword">return</span> amount<span class="token punctuation">;</span>
   <span class="token punctuation">&#125;</span>
<span class="token operator">></span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token operator">></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
   Money <span class="token function">m</span><span class="token punctuation">(</span><span class="token number">100.5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

   <span class="token comment">// 使用类型转换运算符</span>
   <span class="token keyword">double</span> amount <span class="token operator">=</span> m<span class="token punctuation">;</span> <span class="token comment">// 调用 operator double()</span>

   std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Amount: "</span> <span class="token operator">&lt;&lt;</span> amount <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token operator">></span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>解释：</strong></p>
<ul>
<li>类 <code>Money</code> 中定义了 <code>operator double()</code>，允许将 <code>Money</code> 对象隐式转换为 <code>double</code>。</li>
<li>在 <code>main</code> 函数中，<code>double amount = m;</code> 触发了类型转换运算符，将 <code>Money</code> 对象 <code>m</code> 转换为 <code>double</code>。</li>
</ul>
<p><strong>隐式与显式转换</strong></p>
<ul>
<li>默认情况下，类型转换运算符允许隐式转换。</li>
<li>如果希望防止隐式转换，可以使用 <code>explicit</code> 关键字：</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token operator">></span><span class="token keyword">explicit</span> <span class="token keyword">operator</span> <span class="token keyword">double</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span>
   <span class="token keyword">return</span> amount<span class="token punctuation">;</span>
<span class="token operator">></span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>这样，需要显式转换（如 <code>double amount = static_cast&lt;double&gt;(m);</code>）才能进行转换。</p>
</blockquote>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">using</span> func_ptr <span class="token operator">=</span> <span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">Test</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> string b<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"name: "</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> <span class="token string">", age: "</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 将类对象转换为函数指针</span>
    <span class="token keyword">operator</span> <span class="token function">func_ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token comment">// 返回的要是 类的静态成员Test::print</span>
        <span class="token keyword">return</span> print<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Test t<span class="token punctuation">;</span>
    <span class="token comment">// 对象转换为函数指针, 并调用</span>
    <span class="token function">t</span><span class="token punctuation">(</span><span class="token number">19</span><span class="token punctuation">,</span> <span class="token string">"Monkey D. Luffy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ol start="5">
<li><code>是一个类成员函数指针或者类成员指针</code></li>
</ol>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">Test</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> string b<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"name: "</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> <span class="token string">", age: "</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">int</span> m_num<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 定义类成员函数指针指向类成员函数</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span>Test<span class="token double-colon punctuation">::</span><span class="token operator">*</span>func_ptr<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>Test<span class="token double-colon punctuation">::</span>print<span class="token punctuation">;</span>
    <span class="token comment">// 类成员指针指向类成员变量</span>
    <span class="token keyword">int</span> Test<span class="token double-colon punctuation">::</span><span class="token operator">*</span>obj_ptr <span class="token operator">=</span> <span class="token operator">&amp;</span>Test<span class="token double-colon punctuation">::</span>m_num<span class="token punctuation">;</span>

    Test t<span class="token punctuation">;</span>
    <span class="token comment">// 通过类成员函数指针调用类成员函数</span>
    <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token operator">*</span>func_ptr<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">19</span><span class="token punctuation">,</span> <span class="token string">"Monkey D. Luffy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 通过类成员指针初始化类成员变量</span>
    t<span class="token punctuation">.</span><span class="token operator">*</span>obj_ptr <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"number is: "</span> <span class="token operator">&lt;&lt;</span> t<span class="token punctuation">.</span>m_num <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上面的例子中满足条件的这些可调用对象对应的类型被统称为<code>可调用类型</code>。</p>
<p>C++中的可调用类型虽然具有比较统一的操作形式，但定义方式五花八门，这样在我们试图使用统一的方式保存，或者传递一个可调用对象时会十分繁琐。现在，<code>C++11通过提供 std::function 和 std::bind 统一了可调用对象的各种操作</code>。</p>
<h3 id="11-2-可调用对象包装器"><a href="#11-2-可调用对象包装器" class="headerlink" title="11.2 可调用对象包装器"></a>11.2 可调用对象包装器</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43798887/article/details/116571325">C++11的std::function源码解析_std::function 源码-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/66301236">libcxx 的 std::function 源码分析 - 知乎</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/560964284">STL源码分析之std::function - 知乎</a></p>
<p><code>std::function</code>是<code>可调用对象的包装器</code>。它是一个<code>类模板</code>，可以容纳<code>除了类(非静态)成员（函数）指针之外</code>的所有可调用对象。通过指定它的模板参数，它可以用统一的方式处理函数、函数对象、函数指针，并允许保存和延迟执行它们。</p>
<p><strong>基本用法</strong></p>
<p>使用<code>std::function</code>需要添加头文件<code>#include &lt;functional&gt;</code>，可调用对象包装器使用语法如下:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;functional></span></span>
std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span>返回值类型<span class="token punctuation">(</span>参数类型列表<span class="token punctuation">)</span><span class="token operator">></span> diy_name <span class="token operator">=</span> 可调用对象<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>下面的实例代码中演示了可调用对象包装器的基本使用方法：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;functional></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">using</span> f_ptr <span class="token operator">=</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">Func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"函数被调用"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">class</span> <span class="token class-name">Test</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> num<span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"hello world"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// 类型转换运算符 -- 返回值必须是 静态成员函数指针 这样才能在没有实例的情况下调用</span>
    <span class="token keyword">operator</span> <span class="token function">f_ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> static_print<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">static_print</span><span class="token punctuation">(</span>string msg<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"我是静态成员函数"</span> <span class="token operator">&lt;&lt;</span> msg <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">void</span> <span class="token function">normal_print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"我是非静态成员函数"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token keyword">const</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"chcp 65001"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 1. 可调用对象--函数</span>
    <span class="token function">Func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 2. 可调用对象--函数指针</span>
    <span class="token keyword">using</span> func_ptr <span class="token operator">=</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    func_ptr ptr1 <span class="token operator">=</span> Func<span class="token punctuation">;</span>
    <span class="token punctuation">(</span>ptr1<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">(</span><span class="token operator">*</span>ptr1<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 3. 可调用对象--仿函数</span>
    Test t1<span class="token punctuation">;</span>
    <span class="token function">t1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 4. 类型转换运算符 -> 能够将`类对象转换为函数指针类型`</span>
    string msg <span class="token operator">=</span> <span class="token string">"hhh"</span><span class="token punctuation">;</span>
    <span class="token function">t1</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 5. 类成员函数指针 / 类成员指针</span>
    <span class="token keyword">using</span> class_func_ptr <span class="token operator">=</span> <span class="token keyword">void</span> <span class="token punctuation">(</span>Test<span class="token double-colon punctuation">::</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    class_func_ptr ptr2 <span class="token operator">=</span> <span class="token operator">&amp;</span>Test<span class="token double-colon punctuation">::</span>normal_print<span class="token punctuation">;</span>

    <span class="token keyword">int</span> Test<span class="token double-colon punctuation">::</span><span class="token operator">*</span>class_member_ptr <span class="token operator">=</span> <span class="token operator">&amp;</span>Test<span class="token double-colon punctuation">::</span>num<span class="token punctuation">;</span>
    Test t2<span class="token punctuation">;</span>
    <span class="token punctuation">(</span>t2<span class="token punctuation">.</span><span class="token operator">*</span>ptr2<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 使用可调用对象包装器</span>
    <span class="token comment">// 1. 函数指针</span>
    function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span> f1 <span class="token operator">=</span> Func<span class="token punctuation">;</span>
    <span class="token comment">// 2. 仿函数</span>
    Test tt<span class="token punctuation">;</span>
    function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span> f2 <span class="token operator">=</span> tt<span class="token punctuation">;</span>
    <span class="token comment">// 3. 类型转换运算符</span>
    function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span><span class="token operator">></span> f3 <span class="token operator">=</span> tt<span class="token punctuation">;</span>
    <span class="token comment">// 4. 类静态函数</span>
    function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span><span class="token operator">></span> f4 <span class="token operator">=</span> <span class="token operator">&amp;</span>Test<span class="token double-colon punctuation">::</span>static_print<span class="token punctuation">;</span>
    <span class="token comment">// 调用</span>
    <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">f3</span><span class="token punctuation">(</span><span class="token string">"hhh"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">f4</span><span class="token punctuation">(</span><span class="token string">"hhh"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>通过测试代码可以得到结论：<code>std::function可以将可调用对象进行包装，得到一个统一的格式，包装完成得到的对象相当于一个函数指针</code>，和函数指针的使用方式相同，通过包装器对象就可以完成对包装的函数的调用了。</p>
<p><strong>作为回调函数使用</strong></p>
<p>因为<code>回调函数本身就是通过函数指针实现的，使用对象包装器可以取代函数指针的作用</code>，来看一下下面的例子：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;functional></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Test</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment">// 构造函数传入一个function包装器对象 并保存到成员变量中</span>
    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">const</span> function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span><span class="token operator">></span> <span class="token operator">&amp;</span>f<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">callback</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 执行回调函数</span>
    <span class="token keyword">void</span> <span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">callback</span><span class="token punctuation">(</span><span class="token string">"Hello World"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span><span class="token operator">></span> callback<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">TestB</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment">// 重载()运算符</span>
    <span class="token keyword">void</span>
    <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>string msg<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> msg <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    TestB testB<span class="token punctuation">;</span>

    <span class="token comment">// 重载了()运算符,所以对象当作函数使用</span>
    <span class="token function">testB</span><span class="token punctuation">(</span><span class="token string">"Hello World"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 仿函数通过包装器对象进行包装</span>

    Test <span class="token function">test</span><span class="token punctuation">(</span>testB<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 隐式转换为function包装器对象</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>通过上面的例子可以看出，使用对象包装器std::function可以非常方便的将仿函数转换为一个函数指针，通过进行函数指针的传递，在其他函数的合适的位置就可以调用这个包装好的仿函数了。</p>
<h3 id="11-3-bind绑定器"><a href="#11-3-bind绑定器" class="headerlink" title="11.3 bind绑定器"></a>11.3 bind绑定器</h3><p><code>std::bind用来将可调用对象与其参数一起进行绑定。绑定后的结果可以使用std::function进行保存，并延迟调用到任何我们需要的时候。</code>通俗来讲，它主要有两大作用：</p>
<ul>
<li>将<code>可调用对象与其参数一起绑定成一个仿函数</code>。</li>
<li><code>将多元（参数个数为n，n&gt;1）可调用对象转换为一元或者（n-1）元可调用对象，即只绑定部分参数</code>。</li>
</ul>
<p>绑定器函数使用语法格式如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 绑定非类成员函数/变量</span>
<span class="token keyword">auto</span> f <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span>可调用对象地址<span class="token punctuation">,</span> 绑定的参数<span class="token operator">/</span>占位符<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 绑定类成员函/变量</span>
<span class="token keyword">auto</span> f <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span>类函数<span class="token operator">/</span>成员地址<span class="token punctuation">,</span> 类实例对象地址<span class="token punctuation">,</span> 绑定的参数<span class="token operator">/</span>占位符<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>下面来看一个关于绑定器的实际使用的例子：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;functional></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">callFunc</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">const</span> function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token operator">&amp;</span> f<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">output</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">output_add</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">+</span> <span class="token number">10</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 使用绑定器绑定可调用对象和参数</span>
    <span class="token keyword">auto</span> f1 <span class="token operator">=</span> <span class="token function">bind</span><span class="token punctuation">(</span>output<span class="token punctuation">,</span> placeholders<span class="token double-colon punctuation">::</span>_1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">callFunc</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> f1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token keyword">auto</span> f2 <span class="token operator">=</span> <span class="token function">bind</span><span class="token punctuation">(</span>output_add<span class="token punctuation">,</span> placeholders<span class="token double-colon punctuation">::</span>_1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">callFunc</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> f2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>测试代码输出的结果:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">0</span> <span class="token number">2</span> <span class="token number">4</span> <span class="token number">6</span> <span class="token number">8</span>
<span class="token number">10</span> <span class="token number">12</span> <span class="token number">14</span> <span class="token number">16</span> <span class="token number">18</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>在上面的程序中，使用了std::bind绑定器，在函数外部通过绑定不同的函数，控制了最后执行的结果。<code>std::bind绑定器返回的是一个仿函数类型，得到的返回值可以直接赋值给一个std::function，在使用的时候我们并不需要关心绑定器的返回值类型，使用auto进行自动类型推导就可以了。</code></p>
<p><code>placeholders::_1</code>是一个占位符，<code>代表这个位置将在bind返回的仿0函数调用时被传入的第一个参数所替代。</code>同样还有其他的占位符<code>placeholders::_2、placeholders::_3、placeholders::_4、placeholders::_5等……</code></p>
<p>有了占位符的概念之后，使得std::bind的使用变得非常灵活:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;functional></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">output</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> y <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 使用绑定器绑定可调用对象和参数, 并调用得到的仿函数</span>
    <span class="token function">bind</span><span class="token punctuation">(</span>output<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">bind</span><span class="token punctuation">(</span>output<span class="token punctuation">,</span> placeholders<span class="token double-colon punctuation">::</span>_1<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">bind</span><span class="token punctuation">(</span>output<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> placeholders<span class="token double-colon punctuation">::</span>_1<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// error, 调用时没有第二个参数</span>
    <span class="token comment">// bind(output, 2, placeholders::_2)(10);</span>
    <span class="token comment">// 调用时第一个参数10被吞掉了，没有被使用</span>
    <span class="token function">bind</span><span class="token punctuation">(</span>output<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> placeholders<span class="token double-colon punctuation">::</span>_2<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">bind</span><span class="token punctuation">(</span>output<span class="token punctuation">,</span> placeholders<span class="token double-colon punctuation">::</span>_1<span class="token punctuation">,</span> placeholders<span class="token double-colon punctuation">::</span>_2<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">bind</span><span class="token punctuation">(</span>output<span class="token punctuation">,</span> placeholders<span class="token double-colon punctuation">::</span>_2<span class="token punctuation">,</span> placeholders<span class="token double-colon punctuation">::</span>_1<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>示例代码执行的结果:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>  <span class="token number">2</span>		// bind<span class="token punctuation">(</span>output, <span class="token number">1</span>, <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">10</span> <span class="token number">2</span>		// bind<span class="token punctuation">(</span>output, placeholders::_1, <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">2</span> <span class="token number">10</span>		// bind<span class="token punctuation">(</span>output, <span class="token number">2</span>, placeholders::_1<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">2</span> <span class="token number">20</span>		// bind<span class="token punctuation">(</span>output, <span class="token number">2</span>, placeholders::_2<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">10</span>, <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">10</span> <span class="token number">20</span>		// bind<span class="token punctuation">(</span>output, placeholders::_1, placeholders::_2<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">10</span>, <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">20</span> <span class="token number">10</span>		// bind<span class="token punctuation">(</span>output, placeholders::_2, placeholders::_1<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">10</span>, <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>通过测试可以看到，<code>std::bind可以直接绑定函数的所有参数，也可以仅绑定部分参数。在绑定部分参数的时候，通过使用std::placeholders来决定空位参数将会属于调用发生时的第几个参数。</code></p>
<p>可调用对象包装器<code>std::function是不能实现对类成员函数指针或者类成员指针的包装的</code>，但是通过<code>绑定器std::bind</code>的配合之后，就可以完美的解决这个问题了，再来看一个例子，然后再解释里边的细节：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;functional></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Test</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">output</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"x: "</span> <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> <span class="token string">", y: "</span> <span class="token operator">&lt;&lt;</span> y <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">int</span> m_number <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Test t<span class="token punctuation">;</span>
    <span class="token comment">// 绑定类成员函数</span>
    function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> f1 <span class="token operator">=</span> 
        <span class="token function">bind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Test<span class="token double-colon punctuation">::</span>output<span class="token punctuation">,</span> <span class="token operator">&amp;</span>t<span class="token punctuation">,</span> placeholders<span class="token double-colon punctuation">::</span>_1<span class="token punctuation">,</span> placeholders<span class="token double-colon punctuation">::</span>_2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 绑定类成员变量(公共)</span>
    function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token operator">></span> f2 <span class="token operator">=</span> <span class="token function">bind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Test<span class="token double-colon punctuation">::</span>m_number<span class="token punctuation">,</span> <span class="token operator">&amp;</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 调用</span>
    <span class="token function">f1</span><span class="token punctuation">(</span><span class="token number">520</span><span class="token punctuation">,</span> <span class="token number">1314</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">2333</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"t.m_number: "</span> <span class="token operator">&lt;&lt;</span> t<span class="token punctuation">.</span>m_number <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>示例代码输出的结果：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">x: <span class="token number">520</span>, y: <span class="token number">1314</span>
t.m_number: <span class="token number">2333</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>在用绑定器绑定类成员函数或者成员变量的时候需要将它们所属的实例对象一并传递到绑定器函数内部。<code>f1的类型是function&lt;void(int, int)&gt;，通过使用std::bind将Test的成员函数output的地址和对象t绑定，并转化为一个仿函数并存储到对象f1中</code>。</p>
<p><code>使用绑定器绑定的类成员变量m_number得到的仿函数被存储到了类型为function&lt;int&amp;(void)&gt;的包装器对象f2中，并且可以在需要的时候修改这个成员。其中int是绑定的类成员的类型，并且允许修改绑定的变量，因此需要指定为变量的引用，由于没有参数因此参数列表指定为void。</code></p>
<p>示例程序中是使用function包装器保存了bind返回的仿函数，如果不知道包装器的模板类型如何指定，可以直接使用auto进行类型的自动推导，这样使用起来会更容易一些。</p>
<h2 id="12-lambda表达式"><a href="#12-lambda表达式" class="headerlink" title="12.lambda表达式"></a>12.lambda表达式</h2><h3 id="12-1-基本用法"><a href="#12-1-基本用法" class="headerlink" title="12.1 基本用法"></a>12.1 基本用法</h3><p><code>lambda表达式</code>是C++11最重要也是最常用的特性之一，这是现代编程语言的一个特点，lambda表达式有如下的一些优点：</p>
<ul>
<li>声明式的编程风格：就地匿名定义目标函数或函数对象，不需要额外写一个命名函数或函数对象。</li>
<li>简洁：避免了代码膨胀和功能分散，让开发更加高效。</li>
<li>在需要的时间和地点实现功能闭包，使程序更加灵活。</li>
</ul>
<p>lambda表达式定义了一个匿名函数，并且可以捕获一定范围内的变量。lambda表达式的语法形式简单归纳如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">[</span>capture<span class="token punctuation">]</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span> opt <span class="token operator">-></span> ret <span class="token punctuation">&#123;</span>body<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>其中<code>capture</code>是捕获列表，<code>params</code>是参数列表，<code>opt</code>是函数选项，<code>ret</code>是返回值类型，<code>body</code>是函数体。</p>
<ol>
<li><code>捕获列表[]:</code> 捕获一定范围内的变量</li>
<li><code>参数列表():</code> 和普通函数的参数列表一样，如果没有参数参数列表可以省略不写。</li>
<li><code>opt 选项</code>， 不需要可以省略<ul>
<li><code>mutable</code>: 可以修改按值传递进来的拷贝（注意是能修改拷贝，而不是值本身）</li>
<li><code>exception</code>: 指定函数抛出的异常，如抛出整数类型的异常，可以使用throw();</li>
</ul>
</li>
<li><code>返回值类型</code>：在C++11中，lambda表达式的返回值是通过返回值后置语法来定义的。</li>
<li><code>函数体</code>：函数的实现，这部分不能省略，但函数体可以为空。</li>
</ol>
<blockquote>
<p>注意匿名函数需要加<code>()</code>才能调用</p>
</blockquote>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 只定义lambda匿名函数</span>
<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"lambda-1"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token comment">// 定义lambda匿名函数并调用</span>
<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token keyword">void</span>
<span class="token punctuation">&#123;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"lambda-2"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="12-2-捕获列表"><a href="#12-2-捕获列表" class="headerlink" title="12.2 捕获列表"></a>12.2 捕获列表</h3><p>lambda表达式的捕获列表可以捕获一定范围内的变量，具体使用方式如下：</p>
<ul>
<li><code>[]</code> - 不捕捉任何变量</li>
<li><code>[&amp;]</code> - 捕获外部作用域中所有变量, 并作为<code>引用</code>在函数体内使用 (<code>按引用捕获</code>)</li>
<li><code>[=]</code> - 捕获外部作用域中所有变量, 并作为<code>副本</code>在函数体内使用 (<code>按值捕获</code>)<ul>
<li><code>拷贝的副本在匿名函数体内部是只读的</code></li>
</ul>
</li>
<li><code>[=, &amp;foo]</code> - 按值捕获外部作用域中所有变量, 并按照引用捕获外部变量 foo</li>
<li><code>[bar]</code> - 按值捕获 bar 变量, 同时不捕获其他变量</li>
<li><code>[&amp;bar]</code> - 按引用捕获 bar 变量, 同时不捕获其他变量</li>
<li><code>[this]</code> - 捕获当前<code>类中的this指针</code><ul>
<li><code>让lambda表达式拥有和当前类成员函数同样的访问权限</code></li>
<li><code>如果已经使用了 &amp; 或者 =, 默认添加此选项</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>使用<code>= 值捕获的</code>变量是在函数体中创建了一个<code>只读的同名副本</code>（不同内存空间），添加<code>mutable</code>选项也只是让这个<code>副本</code>可写，想要修改外部作用域的变量，需要使用<code>引用捕获</code></p>
</blockquote>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">cout_line</span> <span class="token expression">cout <span class="token operator">&lt;&lt;</span> </span><span class="token string">"--------------------"</span> <span class="token expression"><span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></span></span>
<span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">&#123;</span>

<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> i_member <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>

        <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
        <span class="token comment">// 只定义lambda匿名函数</span>
        <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            cout <span class="token operator">&lt;&lt;</span> <span class="token string">"lambda-1"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
        cout_line<span class="token punctuation">;</span>
        <span class="token comment">// 定义lambda匿名函数并调用</span>
        <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token keyword">void</span>
        <span class="token punctuation">&#123;</span>
            cout <span class="token operator">&lt;&lt;</span> <span class="token string">"lambda-2"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        cout_line<span class="token punctuation">;</span>
        <span class="token comment">// 捕获方式 --> = 值捕获</span>
        <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token keyword">void</span>
        <span class="token punctuation">&#123;</span>
            <span class="token keyword">int</span> c <span class="token operator">=</span> a<span class="token punctuation">;</span>
            <span class="token keyword">int</span> d <span class="token operator">=</span> x<span class="token punctuation">;</span>
            <span class="token comment">// a++;     // error 捕获值捕获的变量不能被修改</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
        <span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token keyword">void</span>
        <span class="token punctuation">&#123;</span>
            <span class="token keyword">int</span> c <span class="token operator">=</span> a<span class="token punctuation">;</span>
            <span class="token comment">// int d = x; // error 只值捕获了外部作用域的a</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
        <span class="token comment">// 捕获方式 --> &amp; 引用捕获</span>
        <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token keyword">void</span>
        <span class="token punctuation">&#123;</span>
            <span class="token keyword">int</span> c <span class="token operator">=</span> a<span class="token punctuation">;</span>
            <span class="token keyword">int</span> d <span class="token operator">=</span> x<span class="token punctuation">;</span>
            a<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// ok 引用捕获的变量可以修改</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"修改后的a="</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
        cout_line<span class="token punctuation">;</span>
        <span class="token comment">// 捕获方式 --> this 捕获当前类this指针</span>
        <span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token keyword">void</span>
        <span class="token punctuation">&#123;</span>
            cout <span class="token operator">&lt;&lt;</span> <span class="token string">"this->i_member="</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">this</span><span class="token operator">-></span>i_member <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
            <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-></span>i_member<span class="token punctuation">;</span>
            i_member<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"修改后的i_member="</span> <span class="token operator">&lt;&lt;</span> i_member <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
        cout_line<span class="token punctuation">;</span>

        <span class="token comment">// 选项 --> mutable</span>
        <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">mutable</span> <span class="token operator">-></span> <span class="token keyword">void</span>
        <span class="token punctuation">&#123;</span>
            <span class="token keyword">int</span> c <span class="token operator">=</span> a<span class="token punctuation">;</span>
            <span class="token keyword">int</span> d <span class="token operator">=</span> x<span class="token punctuation">;</span>
            a<span class="token operator">++</span><span class="token punctuation">;</span>                                           <span class="token comment">// ok 添加mutable后，捕获值捕获的变量可以修改，但是也还是副本</span>
            cout <span class="token operator">&lt;&lt;</span> <span class="token string">"lambda函数内 a++ 后 a="</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 12</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"外部变量 a="</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 11</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"chcp 65001"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    A a<span class="token punctuation">;</span>
    a<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="12-3-返回值"><a href="#12-3-返回值" class="headerlink" title="12.3 返回值"></a>12.3 返回值</h3><p>很多时候，lambda表达式的返回值是非常明显的，因此在C++11中<code>允许省略lambda表达式的返回值</code>。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 完整的lambda表达式定义</span>
<span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token keyword">int</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> a<span class="token operator">+</span><span class="token number">10</span><span class="token punctuation">;</span>  
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token comment">// 忽略返回值的lambda表达式定义</span>
<span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> a<span class="token operator">+</span><span class="token number">10</span><span class="token punctuation">;</span>  
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>一般情况下，不指定lambda表达式的返回值，编译器会根据return语句自动推导返回值的类型，但需要注意的是<code>labmda表达式不能通过列表初始化自动推导出返回值类型。</code></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// ok，可以自动推导出返回值类型</span>
<span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> i<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// error，不能推导出返回值类型</span>
<span class="token keyword">auto</span> f1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>	<span class="token comment">// 基于列表初始化推导返回值，错误</span>
<span class="token punctuation">&#125;</span>	<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="12-4-函数本质"><a href="#12-4-函数本质" class="headerlink" title="12.4 函数本质"></a>12.4 函数本质</h3><p>使用lambda表达式捕获列表捕获外部变量，如果希望去修改按值捕获的外部变量，那么应该如何处理呢？这就需要使用mutable选项，<code>被mutable修改是lambda表达式就算没有参数也要写明参数列表，并且可以去掉按值捕获的外部变量的只读（const）属性。</code></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> f1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> a<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>              <span class="token comment">// error, 按值捕获外部变量, a是只读的</span>
<span class="token keyword">auto</span> f2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">mutable</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> a<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>     <span class="token comment">// ok</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>最后再剖析一下为什么通过值拷贝的方式捕获的外部变量是只读的:</p>
<ul>
<li><code>lambda表达式的类型在C++11中会被看做是一个带operator()的类，即仿函数。</code></li>
<li><code>按照C++标准，lambda表达式的operator()默认是const的，一个const成员函数是无法修改成员变量值的。</code></li>
</ul>
<p><code>mutable选项的作用就在于取消operator()的const属性</code></p>
<p>因为lambda表达式在C++中会被看做是一个仿函数，因此可以使用<code>std::function和std::bind来存储和操作lambda表达式</code>：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;functional></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 包装可调用函数</span>
    std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> f1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> a<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token comment">// 绑定可调用函数</span>
    std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> f2 <span class="token operator">=</span> <span class="token function">bind</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> a<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> placeholders<span class="token double-colon punctuation">::</span>_1<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 函数调用</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>对于没有捕获任何变量的lambda表达式，还可以转换成一个普通的函数指针：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">using</span> func_ptr <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 没有捕获任何外部变量的匿名函数</span>
func_ptr f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> a<span class="token punctuation">;</span>  
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token comment">// 函数调用</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1314</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="13-左值引用和右值引用"><a href="#13-左值引用和右值引用" class="headerlink" title="13.左值引用和右值引用"></a>13.左值引用和右值引用</h2><h3 id="13-1-右值引用"><a href="#13-1-右值引用" class="headerlink" title="13.1 右值引用"></a>13.1 右值引用</h3><h4 id="右值"><a href="#右值" class="headerlink" title="右值"></a><strong>右值</strong></h4><p>C++11 增加了一个新的类型，称为右值引用（ <code>R-value reference</code>），标记为 <code>&amp;&amp;</code>。在介绍右值引用类型之前先要了解什么是左值和右值：</p>
<ul>
<li><p><code>lvalue</code> 是<code>loactor value</code>的缩写，<code>rvalue</code> 是 <code>read value</code>的缩写</p>
</li>
<li><p>左值是指<code>存储在内存中、有明确存储地址（可取地址）的数据；</code></p>
</li>
<li><p>右值是指<code>可以提供数据值的数据（不可取地址）；</code></p>
</li>
</ul>
<p>通过描述可以看出，区分左值与右值的便捷方法是：<code>可以对表达式取地址（&amp;）就是左值，否则为右值 。所有有名字的变量或对象都是左值，而右值是匿名的。</code></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">520</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">1314</span><span class="token punctuation">;</span>
a <span class="token operator">=</span> b<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>一般情况下，位于<code>=</code>前的表达式为左值，位于<code>=</code>后边的表达式为右值。也就是说例子中的<code>a, b</code>为左值，<code>520,1314</code>为右值。</p>
<p><code>a=b</code>是一种特殊情况，在这个表达式中<code>a, b都是左值，因为变量b是可以被取地址的，不能视为右值。</code></p>
<p>C++11 中右值可以分为两种：一个是将亡值（ xvalue, expiring value），另一个则是纯右值（ prvalue, PureRvalue）：</p>
<ul>
<li><code>纯右值</code>：<code>非引用返回的临时变量、运算表达式产生的临时变量、原始字面量和 lambda 表达式等</code></li>
<li><code>将亡值</code>：即将被移动&#x2F;资源被转移的对象，<code>与右值引用相关的表达式，比如，T&amp;&amp;类型函数的返回值、 std::move 的返回值等。</code></li>
</ul>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">纯右值 (prvalue)</th>
<th>将亡值 (xvalue)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>资源状态</strong></td>
<td align="left">新创建的临时对象</td>
<td>已有对象但即将消亡</td>
</tr>
<tr>
<td align="left"><strong>典型操作</strong></td>
<td align="left">初始化&#x2F;拷贝（可优化）</td>
<td>移动语义（资源转移）</td>
</tr>
<tr>
<td align="left"><strong>内存地址</strong></td>
<td align="left">通常无</td>
<td>有（但即将失效）</td>
</tr>
</tbody></table>
<h4 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h4><p>右值引用就是对一个右值进行引用的类型。因为右值是匿名的，所以我们只能通过引用的方式找到它。<code>无论声明左值引用还是右值引用都必须立即进行初始 化，因为引用类型本身并不拥有所绑定对象的内存，只是该对象的一个别名。通过右值引用的声明，该右值又“重获新生”，其生命周期与右值引用类型变量 的生命周期一样，只要该变量还活着，该右值临时量将会一直存活下去。</code></p>
<blockquote>
<p><code>左值引用的使用场景：</code></p>
<ul>
<li>一个函数传入（指针或者对象）都会创建对应类型的副本，但是假如传递的是一个左值引用（别名），就不会消耗内存空间用于存储副本（能在一定程度上提升效率）</li>
</ul>
<p><code>右值引用的使用场景：</code></p>
<ul>
<li>假设Test是一个非常大的类，一个类实例对象要消耗很大的内存，一个函数返回值为实例对象，那么在接收函数返回值的时候，就会产生临时对象，并调用拷贝构造函数，这对于资源是一个很大的消耗。</li>
<li>直接使用右值引用，将临时对象的生命周期延长，直接使用该临时对象的数据</li>
</ul>
</blockquote>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> value <span class="token operator">=</span> <span class="token number">520</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Test</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"construct: my name is jerry"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">const</span> Test<span class="token operator">&amp;</span> a<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"copy construct: my name is tom"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

Test <span class="token function">getObj</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> a1<span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span>a2 <span class="token operator">=</span> a1<span class="token punctuation">;</span>        <span class="token comment">// error  左值不能赋值给右值引用</span>
    Test<span class="token operator">&amp;</span> t <span class="token operator">=</span> <span class="token function">getObj</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// error  非常量引用的初始值必须为左值 给一个临时对象起别名是不允许的</span>
    Test <span class="token operator">&amp;&amp;</span> t <span class="token operator">=</span> <span class="token function">getObj</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> Test<span class="token operator">&amp;</span> t <span class="token operator">=</span> <span class="token function">getObj</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<ul>
<li><strong>常量左值引用绑定右值</strong>：</li>
<li>安全保证：<code>const</code> 确保不会修改临时对象</li>
<li>生命周期扩展：<code>C++标准规定常量左值引用可将临时对象生命周期延长至引用作用域结束</code></li>
</ul>
</blockquote>
<ul>
<li><p>在上面的例子中<code>int&amp;&amp; value = 520;</code>里面<code>520</code>是<code>纯右值</code>，<code>value是对字面量520这个右值的引用。</code></p>
</li>
<li><p>在<code>int &amp;&amp;a2 = a1;</code>中<code>a1</code>虽然写在了<code>=</code>右边，但是它仍然是一个左值，使用<code>左值初始化一个右值引用类型是不合法</code>的。</p>
</li>
<li><p>在<code>Test&amp; t = getObj()</code>这句代码中语法是错误的，右值不能给普通的左值引用赋值。</p>
</li>
<li><p>在<code>Test &amp;&amp; t = getObj();</code>中<code>getObj()</code>返回的临时对象被称之为<code>将亡值</code>，<code>t是这个将亡值的右值引用。</code></p>
</li>
<li><p><code>const Test&amp; t = getObj()这句代码的语法是正确的，常量左值引用是一个万能引用类型，它可以接受左值、右值、常量左值和常量右值。</code></p>
</li>
</ul>
<blockquote>
<p>在 C++ 中，<code>int&amp;&amp; a = 10; const int&amp; b = a;</code> 的代码是合法的，但涉及<strong>引用类型转换</strong>的核心概念。以下是关键分析：</p>
<hr>
<p><strong><code>int&amp;&amp; a = 10;</code></strong></p>
<ul>
<li><strong>行为</strong>：将右值引用 <code>a</code> 绑定到字面量 <code>10</code>（右值）</li>
<li>生命周期：</li>
<li>字面量 <code>10</code> 会隐式生成临时 <code>int</code> 对象</li>
<li>右值引用 <code>a</code> 会延长该临时对象的生命周期至 <code>a</code> 的作用域结束</li>
</ul>
<p><strong><code>const int&amp; b = a;</code></strong></p>
<ul>
<li><p><strong>行为</strong>：将常量左值引用 <code>b</code> 绑定到 <code>a</code>（此时 <code>a</code> 是左值）</p>
</li>
<li><p>合法性：</p>
</li>
<li><p><code>a</code> 是<code>具名</code>的右值引用变量 → 被编译器视为<strong>左值</strong></p>
</li>
<li><p><code>const</code> 左值引用允许绑定到左值</p>
</li>
<li><p>带名字的变量都是左值</p>
</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token operator">></span><span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span>a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>                 <span class="token comment">// a是别名</span>
<span class="token operator">></span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"a: "</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>   <span class="token comment">// 10</span>
<span class="token operator">></span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"&amp;a: "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 引用的变量地址</span>
<span class="token operator">></span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>b <span class="token operator">=</span> a<span class="token punctuation">;</span>             <span class="token comment">// 别名就相当于是一个变量名, a是int字面量的别名，所以可以被绑定到const int &amp;b</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</blockquote>
<h3 id="13-2-性能优化"><a href="#13-2-性能优化" class="headerlink" title="13.2 性能优化"></a>13.2 性能优化</h3><p>在C++中在进行对象赋值操作的时候，很多情况下会发生对象之间的深拷贝，如果堆内存很大，这个拷贝的代价也就非常大，在某些情况下，如果想要避免对象的深拷贝，就可以使用右值引用进行性能的优化。</p>
<p>再来修改一下上面的实例代码：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Test</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">m_num</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"construct: my name is jerry"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">const</span> Test<span class="token operator">&amp;</span> a<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">m_num</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span>a<span class="token punctuation">.</span>m_num<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"copy construct: my name is tom"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token operator">~</span><span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">delete</span> m_num<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">int</span><span class="token operator">*</span> m_num<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

Test <span class="token function">getObj</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Test t<span class="token punctuation">;</span>
    <span class="token keyword">return</span> t<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Test t <span class="token operator">=</span> <span class="token function">getObj</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"t.m_num: "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>t<span class="token punctuation">.</span>m_num <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>测试代码执行的结果为<code>（当时使用的vs版本为2019，vs2022已无法看到相同的输出，代码被优化了）</code>:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">construct: my name is jerry
copy construct: my name is tom
t.m_num: <span class="token number">100</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>通过输出的结果可以看到调用<code>Test t = getObj();</code>的时候调用拷贝构造函数对返回的临时对象进行了深拷贝得到了对象<code>t</code>，在<code>getObj()函数</code>中创建的对象虽然进行了内存的申请操作，但是没有使用就释放掉了。如果能够使用临时对象已经申请的资源，既能节省资源，还能节省资源申请和释放的时间，如果要执行这样的操作就需要使用右值引用了，<code>右值引用具有移动语义，移动语义可以将资源（堆、系统对象等）通过浅拷贝从一个对象转移到另一个对象这样就能减少不必要的临时对象的创建、拷贝以及销毁，可以大幅提高C++应用程序的性能。</code></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Test</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">m_num</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"construct: my name is jerry"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">const</span> Test<span class="token operator">&amp;</span> a<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">m_num</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span>a<span class="token punctuation">.</span>m_num<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"copy construct: my name is tom"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 添加移动构造函数</span>
    <span class="token function">Test</span><span class="token punctuation">(</span>Test<span class="token operator">&amp;&amp;</span> a<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">m_num</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>m_num<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token comment">// m_num = a.m_num; // 将临时对象的堆内存成员变量的指针赋值给当前对象，提高效率（这样不用创建新指针，赋值，释放临时对象的变量指针)</span>
        a<span class="token punctuation">.</span>m_num <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"move construct: my name is sunny"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token operator">~</span><span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">delete</span> m_num<span class="token punctuation">;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"destruct Test class ..."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">int</span><span class="token operator">*</span> m_num<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

Test <span class="token function">getObj</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Test t<span class="token punctuation">;</span>
    <span class="token keyword">return</span> t<span class="token punctuation">;</span> <span class="token comment">// 返回临时对象</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Test t <span class="token operator">=</span> <span class="token function">getObj</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 此时调用的是移动构造函数  直接接管临时对象的堆内存指针</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"t.m_num: "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>t<span class="token punctuation">.</span>m_num <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>测试代码执行的结果如下<code>（当时使用的vs版本为2019，vs2022已无法看到相同的输出，代码被优化了）</code>:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">construct: my name is jerry
move construct: my name is sunny
destruct Test class <span class="token punctuation">..</span>.
t.m_num: <span class="token number">100</span>
destruct Test class <span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>通过修改，在上面的代码给<code>Test</code>类添加了<code>移动构造函数（参数为右值引用类型）</code>，这样在进行<code>Test t = getObj();</code>操作的时候并没有调用拷贝构造函数进行深拷贝，而是调用了移动构造函数，在这个函数中只是进行了浅拷贝，没有对临时对象进行深拷贝，提高了性能。</p>
<p>在测试程序中<code>getObj()的返回值就是一个将亡值</code>，也就是说是<code>一个右值</code>，在进行赋值操作的时候如果<code>=</code>右边是一个右值，那么<code>移动构造函数就会被调用。</code>移动构造中使用了右值引用，会将<code>临时对象中的堆内存地址的所有权转移给对象t</code>，这块内存被成功续命，因此在t对象中还可以继续使用这块内存。</p>
<blockquote>
<p>对于需要动态申请大量资源的类，<code>应该设计移动构造函数，以提高程序效率</code>。需要注意的是，我们一般在提供移动构造函数的同时，也会提供常量左值引用的拷贝构造函数，<code>以保证移动不成还可以使用拷贝构造函数。</code></p>
</blockquote>
<h3 id="13-3-的特性"><a href="#13-3-的特性" class="headerlink" title="13.3 &amp;&amp; 的特性"></a>13.3 &amp;&amp; 的特性</h3><p>在C++中，并不是所有情况下 <code>&amp;&amp;</code> 都代表是一个右值引用，具体的场景体现在模板和自动类型推导中，如果是模板参数需要指定为<code>T&amp;&amp;</code>，如果是自动类型推导需要指定为<code>auto &amp;&amp;</code>，在这两种场景下<code>&amp;&amp;被称作未定的引用类型</code>。另外还有一点需要额外注意<code>const T&amp;&amp;表示一个右值引用，不是未定引用类型。</code></p>
<p>先来看第一个例子，在函数模板中使用<code>&amp;&amp;:</code></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 	
<span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token function">f1</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// error, x是左值</span>
<span class="token function">f1</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok, 10是右值</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上面的例子中函数模板进行了自动类型推导，需要通过传入的实参来确定参数param的实际类型。</p>
<ul>
<li>第4行中，对于<code>f(10)</code>来说传入的实参10是右值，因此<code>T&amp;&amp;</code>表示右值引用</li>
<li>第6行中，对于<code>f(x)</code>来说传入的实参是x是左值，因此<code>T&amp;&amp;</code>表示左值引用</li>
<li>第7行中，<code>f1(x)</code>的参数是<code>const T&amp;&amp;</code>不是未定引用类型，不需要推导，本身就表示一个右值引用</li>
</ul>
<p>再来看第二个例子:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">520</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">1314</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> v1 <span class="token operator">=</span> x<span class="token punctuation">;</span>
    <span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> v2 <span class="token operator">=</span> <span class="token number">250</span><span class="token punctuation">;</span>
    <span class="token keyword">decltype</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span> v3 <span class="token operator">=</span> y<span class="token punctuation">;</span>   <span class="token comment">// error</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"v1: "</span> <span class="token operator">&lt;&lt;</span> v1 <span class="token operator">&lt;&lt;</span> <span class="token string">", v2: "</span> <span class="token operator">&lt;&lt;</span> v2 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>第4行中 <code>auto&amp;&amp;</code>表示一个整形的左值引用</li>
<li>第5行中 <code>auto&amp;&amp;</code>表示一个整形的右值引用</li>
<li>第6行中<code>decltype(x)&amp;&amp;</code>等价于<code>int&amp;&amp;</code>是一个右值引用不是未定引用类型，y是一个左值，<code>不能使用左值初始化一个右值引用类型。</code></li>
</ul>
<p>由于上述代码中存在<code>T&amp;&amp;</code>或者<code>auto&amp;&amp;</code>这种未定引用类型，当它作为参数时，有可能<code>被一个右值引用初始化，也有可能被一个左值引用初始化</code>，在进行类型推导时右值引用类型（&amp;&amp;）会发生变化，这种变化被称为<code>引用折叠</code>。在C++11中引用折叠的规则如下：</p>
<ul>
<li><code>通过右值推导 T&amp;&amp; 或者 auto&amp;&amp; 得到的是一个右值引用类型</code></li>
<li><code>通过非右值（右值引用、左值、左值引用、常量右值引用、常量左值引用）推导 T&amp;&amp; 或者 auto&amp;&amp; 得到的是一个左值引用类型</code></li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> a1 <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> bb <span class="token operator">=</span> a1<span class="token punctuation">;</span>
<span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> bb1 <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> a2 <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">&amp;</span>a3 <span class="token operator">=</span> a2<span class="token punctuation">;</span>
<span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> cc <span class="token operator">=</span> a3<span class="token punctuation">;</span>
<span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> cc1 <span class="token operator">=</span> a2<span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> s1 <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> s2 <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> dd <span class="token operator">=</span> s1<span class="token punctuation">;</span>
<span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> ee <span class="token operator">=</span> s2<span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>第2行：<code>a1</code>为右值引用，推导出的<code>bb</code>为<code>左值引用</code>类型</li>
<li>第3行：<code>5</code>为右值，推导出的<code>bb1</code>为<code>右值引用</code>类型</li>
<li>第7行：<code>a3</code>为左值引用，推导出的<code>cc</code>为<code>左值引用</code>类型</li>
<li>第8行：<code>a2</code>为左值，推导出的<code>cc1</code>为<code>左值引用</code>类型</li>
<li>第12行：<code>s1</code>为常量左值引用，推导出的<code>dd</code>为<code>常量左值引用</code>类型</li>
<li>第13行：<code>s2</code>为常量右值引用，推导出的<code>ee</code>为<code>常量左值引用</code>类型</li>
<li>第15行：<code>x</code>为右值引用，不需要推导，只能通过右值初始化</li>
</ul>
<p>再看最后一个例子，代码如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">printValue</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>i<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"l-value: "</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">printValue</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span>i<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"r-value: "</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">forward</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span>k<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">printValue</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">520</span><span class="token punctuation">;</span>
    <span class="token function">printValue</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printValue</span><span class="token punctuation">(</span><span class="token number">1314</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">forward</span><span class="token punctuation">(</span><span class="token number">250</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>测试代码输出的结果如下:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">l<span class="token operator">-</span>value<span class="token operator">:</span> <span class="token number">520</span>
r<span class="token operator">-</span>value<span class="token operator">:</span> <span class="token number">1314</span>
l<span class="token operator">-</span>value<span class="token operator">:</span> <span class="token number">250</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>根据测试代码可以得知，编译器会根据传入的参数的类型（左值还是右值）调用对应的重置函数<code>（printValue）</code>，函数<code>forward()</code>接收的是一个右值，但是在这个函数中调用函数<code>printValue()</code>时，参数k变成了一个<code>命名对象，编译器会将其当做左值来处理</code>。</p>
<p>最后总结一下关于<code>&amp;&amp;</code>的使用：</p>
<ul>
<li><code>左值和右值是独立于他们的类型的，右值引用类型可能是左值也可能是右值。</code></li>
<li><code>编译器会将已命名的右值引用视为左值，将未命名的右值引用视为右值。</code></li>
<li><code>auto&amp;&amp;或者函数参数类型自动推导的T&amp;&amp;是一个未定的引用类型，它可能是左值引用也可能是右值引用类型，这取决于初始化的值类型（上面有例子）。</code></li>
<li><code>通过右值推导 T&amp;&amp; 或者 auto&amp;&amp; 得到的是一个右值引用类型，其余都是左值引用类型。</code></li>
</ul>
<h2 id="14-转移和完美转发"><a href="#14-转移和完美转发" class="headerlink" title="14.转移和完美转发"></a>14.转移和完美转发</h2><h3 id="14-1-move转移"><a href="#14-1-move转移" class="headerlink" title="14.1 move转移"></a>14.1 move转移</h3><p>在C++11添加了右值引用，并且不能使用左值初始化右值引用，如果想要使用左值初始化一个右值引用需要借助std::move()函数，<code>使用std::move方法可以将左值转换为右值。使用这个函数并不能移动任何东西，而是和移动构造函数一样都具有移动语义，将对象的状态或者所有权从一个对象转移到另一个对象，只是转移，没有内存拷贝。</code></p>
<p>从实现上讲，<code>std::move</code>基本等同于一个类型转换：<code>static_cast&lt;T&amp;&amp;&gt;(lvalue);</code>，函数原型如下:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">_Ty</span><span class="token operator">></span>
_NODISCARD <span class="token keyword">constexpr</span> remove_reference_t<span class="token operator">&lt;</span>_Ty<span class="token operator">></span><span class="token operator">&amp;&amp;</span> <span class="token function">move</span><span class="token punctuation">(</span>_Ty<span class="token operator">&amp;&amp;</span> _Arg<span class="token punctuation">)</span> _NOEXCEPT
<span class="token punctuation">&#123;</span>	<span class="token comment">// forward _Arg as movable</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>remove_reference_t<span class="token operator">&lt;</span>_Ty<span class="token operator">></span><span class="token operator">&amp;&amp;</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>_Arg<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>使用方法如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Test</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span>：
    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Test t<span class="token punctuation">;</span>
    Test <span class="token operator">&amp;&amp;</span> v1 <span class="token operator">=</span> t<span class="token punctuation">;</span>          <span class="token comment">// error</span>
    Test <span class="token operator">&amp;&amp;</span> v2 <span class="token operator">=</span> <span class="token function">move</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// ok  move()函数本身返回一个右值引用临时表达式（其本身是右值），但是被具名化v2后，v2就变成一个左值</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>在第4行中，使用<code>左值初始化右值引用，因此语法是错误的</code></li>
<li>在第5行中，使用<code>move()函数</code>将左值转换为了右值，这样就可以初始化右值引用了。</li>
</ul>
<p>假设一个临时容器很大，并且需要将这个容器赋值给另一个容器，就可以执行如下操作：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;list></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// l1是左值（list对象），内部指针指向字符串链表</span>
    list<span class="token operator">&lt;</span>string<span class="token operator">></span> l1 <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">"Hello"</span><span class="token punctuation">,</span> <span class="token string">"World"</span><span class="token punctuation">,</span> <span class="token string">"Good"</span><span class="token punctuation">,</span> <span class="token string">"Morning"</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"&amp;l1\t"</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>l1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token comment">// move函数将左值标为右值引用并返回，使用右值引用初始化后 rref指向的还是l1对象</span>
    list<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token operator">&amp;&amp;</span>rref <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>l1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// rref是右值引用类型的变量</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"&amp;rref\t"</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>rref <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  <span class="token comment">// 但此时 rref 是具名变量 → 属于左值（可以取地址）</span>

    <span class="token comment">// 并不会直接执行移动操作，真正的移动发生在构造/赋值时，list的移动构造函数被调用，转移资源所有权，返回一个新的对象（但是新对象内指向的数据还是之前那坨）</span>
    list<span class="token operator">&lt;</span>string<span class="token operator">></span> l2 <span class="token operator">=</span> <span class="token function">move</span><span class="token punctuation">(</span>l1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// move()返回一个右值引用（因为是临时的，使用本身是右值）</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"&amp;l2\t"</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>l2 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>输出如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">&amp;</span>l1     0x7ffc6d3e5d20  // 原始对象的地址
<span class="token operator">&amp;</span>rref   0x7ffc6d3e5d20  // 右值引用与原对象地址相同（引用即别名）
<span class="token operator">&amp;</span>l2     0x7ffc6d3e5d60  // 新对象的地址（通过移动构造创建）

+---------+          heap内存
<span class="token operator">|</span>   l1    <span class="token operator">|</span> ------<span class="token operator">></span> <span class="token punctuation">[</span>原链表数据<span class="token punctuation">]</span> <span class="token punctuation">(</span>移动后变为nullptr<span class="token punctuation">)</span>
<span class="token operator">|</span> <span class="token punctuation">(</span>0x5d20<span class="token punctuation">)</span><span class="token operator">|</span>          
+---------+          
     ↑
     <span class="token operator">|</span>
+---------+
<span class="token operator">|</span>  rref   <span class="token operator">|</span> 
<span class="token operator">|</span> <span class="token punctuation">(</span>0x5d20<span class="token punctuation">)</span><span class="token operator">|</span> --（始终指向l1，但移动后数据已转移）
+---------+

+---------+          heap内存
<span class="token operator">|</span>   l2    <span class="token operator">|</span> ------<span class="token operator">></span> <span class="token punctuation">[</span>原l1的链表数据<span class="token punctuation">]</span>
<span class="token operator">|</span> <span class="token punctuation">(</span>0x5d60<span class="token punctuation">)</span><span class="token operator">|</span>          
+---------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果不使用std::move，拷贝的代价很大，性能较低。使用move几乎没有任何代价，只是转换了资源的所有权。如果一个对象内部有较大的堆内存或者动态数组时，使用move()就可以非常方便的进行数据所有权的转移。另外，我们也可以给类编写相应的移动构造函数（<code>T::T(T&amp;&amp; another)</code>）和和具有移动语义的赋值函数（<code>T&amp;&amp; T::operator=(T&amp;&amp; rhs)</code>），在构造对象和赋值的时候尽可能的进行资源的重复利用，因为它们都是接收一个右值引用参数。</p>
<h3 id="14-2-forward完美转发"><a href="#14-2-forward完美转发" class="headerlink" title="14.2 forward完美转发"></a>14.2 forward完美转发</h3><p>右值引用类型是独立于值的，一个右值引用作为函数参数的形参时，在函数内部转发该参数给内部其他函数时，它就变成一个左值，并不是原来的类型了。如果需要按照参数原来的类型转发到另一个函数，可以使用<code>C++11提供的std::forward()函数</code>，该函数实现的功能称之为完美转发。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 函数原型</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span> T<span class="token operator">&amp;&amp;</span> <span class="token function">forward</span> <span class="token punctuation">(</span><span class="token keyword">typename</span> <span class="token class-name">remove_reference</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token double-colon punctuation">::</span>type<span class="token operator">&amp;</span> t<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span> T<span class="token operator">&amp;&amp;</span> <span class="token function">forward</span> <span class="token punctuation">(</span><span class="token keyword">typename</span> <span class="token class-name">remove_reference</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token double-colon punctuation">::</span>type<span class="token operator">&amp;&amp;</span> t<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>

<span class="token comment">// 精简之后的样子</span>
std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">></span></span></span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><code>当T为左值引用类型时，t将被转换为T类型的左值</code></li>
<li><code>当T不是左值引用类型时，t将被转换为T类型的右值</code></li>
</ul>
<p>下面通过一个例子演示一下关于forward的使用:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">printValue</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> t<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"l-value: "</span> <span class="token operator">&lt;&lt;</span> t <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">printValue</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> t<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"r-value: "</span> <span class="token operator">&lt;&lt;</span> t <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">testForward</span><span class="token punctuation">(</span>T <span class="token operator">&amp;&amp;</span> v<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">printValue</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printValue</span><span class="token punctuation">(</span><span class="token function">move</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printValue</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">></span></span></span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">testForward</span><span class="token punctuation">(</span><span class="token number">520</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">1314</span><span class="token punctuation">;</span>
    <span class="token function">testForward</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">testForward</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">testForward</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&amp;</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">testForward</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&amp;&amp;</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>测试代码打印的结果如下:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">l<span class="token operator">-</span>value<span class="token operator">:</span> <span class="token number">520</span>
r<span class="token operator">-</span>value<span class="token operator">:</span> <span class="token number">520</span>
r<span class="token operator">-</span>value<span class="token operator">:</span> <span class="token number">520</span>

l<span class="token operator">-</span>value<span class="token operator">:</span> <span class="token number">1314</span>
r<span class="token operator">-</span>value<span class="token operator">:</span> <span class="token number">1314</span>
l<span class="token operator">-</span>value<span class="token operator">:</span> <span class="token number">1314</span>

l<span class="token operator">-</span>value<span class="token operator">:</span> <span class="token number">1314</span>
r<span class="token operator">-</span>value<span class="token operator">:</span> <span class="token number">1314</span>
r<span class="token operator">-</span>value<span class="token operator">:</span> <span class="token number">1314</span>

l<span class="token operator">-</span>value<span class="token operator">:</span> <span class="token number">1314</span>
r<span class="token operator">-</span>value<span class="token operator">:</span> <span class="token number">1314</span>
l<span class="token operator">-</span>value<span class="token operator">:</span> <span class="token number">1314</span>

l<span class="token operator">-</span>value<span class="token operator">:</span> <span class="token number">1314</span>
r<span class="token operator">-</span>value<span class="token operator">:</span> <span class="token number">1314</span>
r<span class="token operator">-</span>value<span class="token operator">:</span> <span class="token number">1314</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p><code>testForward(520);</code> 函数的形参为未定引用类型 <code>T&amp;&amp;</code>，实参为右值，初始化后被推导为一个右值引用 </p>
<ul>
<li><code>printValue(v);</code> 已命名的右值 <code>v</code>，编译器会视为左值处理，实参为 <strong>左值</strong> </li>
<li><code>printValue(move(v));</code> 已命名的右值编译器会视为左值处理，通过 <code>move</code> 又将其转换为右值，实参为 <strong>右值</strong> </li>
<li><code>printValue(forward&lt;T&gt;(v));forward</code> 的模板参数为右值引用，最终得到一个右值，实参为 <strong>右值</strong></li>
</ul>
</li>
<li><p><code>testForward(num);</code> 函数的形参为未定引用类型 <code>T&amp;&amp;</code>，实参为左值，初始化后被推导为一个左值引用 </p>
<ul>
<li><code>printValue(v);</code> 实参为 <strong>左值</strong> </li>
<li><code>printValue(move(v));</code> 通过 <code>move</code> 将左值转换为右值，实参为 <strong>右值</strong> </li>
<li><code>printValue(forward&lt;T&gt;(v));</code> <code>forward</code> 的模板参数为左值引用，最终得到一个左值引用，实参为 <strong>左值</strong></li>
</ul>
</li>
<li><p><code>testForward(forward&lt;int&gt;(num));</code>forward的模板类型为int，最终会得到一个右值，函数的形参为未定引用类型<code>T&amp;&amp;</code>被右值初始化后得到一个右值引用类型</p>
<ul>
<li><code>printValue(v);</code>已命名的右值v，编译器会视为左值处理，实参为<strong>左值</strong></li>
<li><code>printValue(move(v));</code>已命名的右值编译器会视为左值处理，通过move又将其转换为右值，实参为<strong>右值</strong></li>
<li><code>printValue(forward&lt;T&gt;(v));</code>forward的模板参数为右值引用，最终得到一个右值，实参为<strong>右值</strong></li>
</ul>
</li>
<li><p><code>testForward(forward&lt;int&amp;&gt;(num));</code>forward的模板类型为int&amp;，最终会得到一个左值，函数的形参为未定引用类型<code>T&amp;&amp;</code>被左值初始化后得到一个左值引用类型</p>
<ul>
<li><code>printValue(v);</code>实参为<strong>左值</strong></li>
<li><code>printValue(move(v));</code>通过move将左值转换为右值，实参为<strong>右值</strong></li>
<li><code>printValue(forward&lt;T&gt;(v));</code>forward的模板参数为左值引用，最终得到一个左值，实参为<strong>左值</strong></li>
</ul>
</li>
<li><p><code>testForward(forward&lt;int&amp;&amp;&gt;(num));</code>forward的模板类型为int&amp;&amp;，最终会得到一个右值，函数的形参为未定引用类型<code>T&amp;&amp;</code>被右值初始化后得到一个右值引用类型</p>
<ul>
<li><code>printValue(v);</code>已命名的右值v，编译器会视为左值处理，实参为<strong>左值</strong></li>
<li><code>printValue(move(v));</code>已命名的右值编译器会视为左值处理，通过move又将其转换为右值，实参为<strong>右值</strong></li>
<li><code>printValue(forward&lt;T&gt;(v));</code>forward的模板参数为右值引用，最终得到一个右值，实参为<strong>右值</strong></li>
</ul>
</li>
</ul>
<h2 id="15-共享智能指针"><a href="#15-共享智能指针" class="headerlink" title="15.共享智能指针"></a>15.共享智能指针</h2><p>在C++中没有垃圾回收机制，必须自己释放分配的内存，否则就会造成内存泄露。解决这个问题最有效的方法是使用智能指针（smart pointer）。<code>智能指针是存储指向动态分配（堆）对象指针的类，用于生存期的控制，能够确保在离开指针所在作用域时，自动地销毁动态分配的对象，防止内存泄露。智能指针的核心实现技术是引用计数，每使用它（引用堆对象）一次，（控制块）内部引用计数加1，每析构一次内部的引用计数减1，减为0时，删除所指向的堆内存。</code></p>
<blockquote>
<ol>
<li><strong>存储位置</strong></li>
</ol>
<ul>
<li><strong>控制块（Control Block）</strong>：引用计数与相关元数据（如弱引用计数、删除器等）被封装在动态分配的<strong>控制块</strong>中，该控制块独立于被管理对象。</li>
<li><strong>堆分配</strong>：控制块由智能指针在构造时通过 <code>new</code>（或 <code>std::make_shared</code>）动态分配在堆上，确保其生命周期与所有关联的智能指针实例同步。</li>
</ul>
<hr>
<ol start="2">
<li><strong>共享机制</strong></li>
</ol>
<ul>
<li><strong>共享控制块</strong>：当多个 <code>std::shared_ptr</code> 指向同一对象时，它们通过内部指针共享同一个控制块，引用计数通过原子操作保证线程安全。</li>
<li><strong>隐式关联</strong>：用户不直接操作控制块，智能指针的拷贝构造函数、赋值运算符等自动管理引用计数的增减。</li>
</ul>
</blockquote>
<p>C++11中提供了三种智能指针，使用这些智能指针时需要引用<code>头文件&lt;memory&gt;</code>：</p>
<ul>
<li><code>std::shared_ptr</code>：共享的智能指针</li>
<li><code>std::unique_ptr</code>：独占的智能指针</li>
<li><code>std::weak_ptr</code>：弱引用的智能指针，它不共享指针，不能操作资源，是用来监视shared_ptr的。</li>
</ul>
<h3 id="15-1-shared-ptr的初始化"><a href="#15-1-shared-ptr的初始化" class="headerlink" title="15.1 shared_ptr的初始化"></a>15.1 shared_ptr的初始化</h3><p>共享智能指针是指多个智能指针可以同时管理同一块有效的内存，<code>共享智能指针shared_ptr 是一个模板类</code>，如果要进行初始化有三种方式：<code>通过构造函数</code>、<code>std::make_shared辅助函数</code>以及<code>reset方法</code>。共享智能指针对象初始化完毕之后就指向了要管理的那块堆内存，如果想要查看当前有多少个智能指针同时管理着这块内存可以使用共享智能指针提供的一个<code>成员函数use_count</code>，函数原型如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 管理当前对象的 shared_ptr 实例数量，或若无被管理对象则为 0。</span>
<span class="token keyword">long</span> <span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h4 id="a-通过构造函数初始化"><a href="#a-通过构造函数初始化" class="headerlink" title="a. 通过构造函数初始化"></a><strong>a. 通过构造函数初始化</strong></h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// shared_ptr&lt;T> 类模板中，提供了多种实用的构造函数, 语法格式如下:</span>
std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">></span> 智能指针名字<span class="token punctuation">(</span>创建堆内存<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>测试代码如下:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 使用智能指针管理一块 int 型的堆内存</span>
    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ptr1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">520</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ptr1管理的内存引用计数: "</span> <span class="token operator">&lt;&lt;</span> ptr1<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token comment">// 使用智能指针管理一块字符数组对应的堆内存</span>
    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> <span class="token function">ptr2</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ptr2管理的内存引用计数: "</span> <span class="token operator">&lt;&lt;</span> ptr2<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token comment">// 创建智能指针对象, 不管理任何内存</span>
    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ptr3<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ptr3管理的内存引用计数: "</span> <span class="token operator">&lt;&lt;</span> ptr3<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token comment">// 创建智能指针对象, 初始化为空</span>
    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ptr4</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ptr4管理的内存引用计数: "</span> <span class="token operator">&lt;&lt;</span> ptr4<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>测试代码输出的结果如下:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ptr1管理的内存引用计数: <span class="token number">1</span>
ptr2管理的内存引用计数: <span class="token number">1</span>
ptr3管理的内存引用计数: <span class="token number">0</span>
ptr4管理的内存引用计数: <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p><code>如果智能指针被初始化了一块有效内存，那么这块内存的引用计数+1，如果智能指针没有被初始化或者被初始化为 nullptr空指针，引用计数不会+1。另外，不要使用一个原始指针初始化多个 shared_ptr。</code></p>
<ul>
<li><strong>控制块独立性</strong>：每个 <code>shared_ptr</code> 构造调用会生成新控制块（若参数是裸指针）。</li>
<li><strong>重复释放风险</strong>：多个控制块导致同一内存被多次释放。</li>
<li><strong>安全实践</strong>：优先用 <code>make_shared</code> 或从已有 <code>shared_ptr</code> 拷贝构造。</li>
</ul>
</blockquote>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">;</span>
shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p1</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p2</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// error, 编译不会报错, 运行会出错</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h4 id="b-通过拷贝和移动构造函数初始化"><a href="#b-通过拷贝和移动构造函数初始化" class="headerlink" title="b. 通过拷贝和移动构造函数初始化"></a><strong>b. 通过拷贝和移动构造函数初始化</strong></h4><p>当一个智能指针被初始化之后，就可以通过这个智能指针初始化其他新对象。在创建新对象的时候，对应的拷贝构造函数或者移动构造函数就被自动调用了。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 使用智能指针管理一块 int 型的堆内存, 内部引用计数为 1</span>
    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ptr1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">520</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ptr1管理的内存引用计数: "</span> <span class="token operator">&lt;&lt;</span> ptr1<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token comment">//调用拷贝构造函数</span>
    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ptr2</span><span class="token punctuation">(</span>ptr1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ptr2管理的内存引用计数: "</span> <span class="token operator">&lt;&lt;</span> ptr2<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ptr3 <span class="token operator">=</span> ptr1<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ptr3管理的内存引用计数: "</span> <span class="token operator">&lt;&lt;</span> ptr3<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token comment">//调用移动构造函数</span>
    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ptr4</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>ptr1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ptr4管理的内存引用计数: "</span> <span class="token operator">&lt;&lt;</span> ptr4<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ptr5 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>ptr2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ptr5管理的内存引用计数: "</span> <span class="token operator">&lt;&lt;</span> ptr5<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>测试程序输入的结果：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ptr1管理的内存引用计数<span class="token operator">:</span> <span class="token number">1</span>
ptr2管理的内存引用计数<span class="token operator">:</span> <span class="token number">2</span>
ptr3管理的内存引用计数<span class="token operator">:</span> <span class="token number">3</span>
ptr4管理的内存引用计数<span class="token operator">:</span> <span class="token number">3</span>
ptr5管理的内存引用计数<span class="token operator">:</span> <span class="token number">3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p><code>如果使用拷贝的方式初始化共享智能指针对象，这两个对象会同时管理同一块堆内存，堆内存对应的引用计数也会增加；如果使用移动的方式初始智能指针对象，只是转让了内存的所有权，管理内存的对象并不会增加，因此内存的引用计数不会变化。</code></p>
</blockquote>
<h4 id="c-通过-std-make-shared-初始化"><a href="#c-通过-std-make-shared-初始化" class="headerlink" title="c. 通过 std::make_shared 初始化"></a><strong>c. 通过 std::make_shared 初始化</strong></h4><p>通过C++提供的 <code>std::make_shared()</code> 就可以完成内存对象的创建并将其初始化给智能指针，函数原型如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Args <span class="token operator">></span>
shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">make_shared</span><span class="token punctuation">(</span> Args<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<ul>
<li><code>T：模板参数的数据类型</code></li>
<li><code>Args&amp;&amp;... args ：要初始化的数据，如果是通过make_shared创建对象，需按照构造函数的参数列表指定</code></li>
</ul>
<p>测试代码如下:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Test</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"construct Test..."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> 
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"construct Test, x = "</span> <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">Test</span><span class="token punctuation">(</span>string str<span class="token punctuation">)</span> 
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"construct Test, str = "</span> <span class="token operator">&lt;&lt;</span> str <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token operator">~</span><span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"destruct Test ..."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 使用智能指针管理一块 int 型的堆内存, 内部引用计数为 1</span>
    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ptr1 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">520</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ptr1管理的内存引用计数: "</span> <span class="token operator">&lt;&lt;</span> ptr1<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    shared_ptr<span class="token operator">&lt;</span>Test<span class="token operator">></span> ptr2 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>Test<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ptr2管理的内存引用计数: "</span> <span class="token operator">&lt;&lt;</span> ptr2<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    shared_ptr<span class="token operator">&lt;</span>Test<span class="token operator">></span> ptr3 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>Test<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">520</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ptr3管理的内存引用计数: "</span> <span class="token operator">&lt;&lt;</span> ptr3<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    shared_ptr<span class="token operator">&lt;</span>Test<span class="token operator">></span> ptr4 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>Test<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token string">"我是要成为海贼王的男人!!!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ptr4管理的内存引用计数: "</span> <span class="token operator">&lt;&lt;</span> ptr4<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>使用<code>std::make_shared()模板函数</code>可以完成内存地址的创建，并将最终得到的内存地址传递给共享智能指针对象管理。如果要创建一个类对象，<code>函数的()内部需要指定构造对象需要的参数，也就是类构造函数的参数。</code></p>
</blockquote>
<h4 id="d-通过-reset方法初始化"><a href="#d-通过-reset方法初始化" class="headerlink" title="d. 通过 reset方法初始化"></a><strong>d. 通过 reset方法初始化</strong></h4><p>共享智能指针类提供的std::shared_ptr::reset方法函数原型如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">Y</span> <span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">reset</span><span class="token punctuation">(</span> Y<span class="token operator">*</span> ptr <span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">Y</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Deleter</span> <span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">reset</span><span class="token punctuation">(</span> Y<span class="token operator">*</span> ptr<span class="token punctuation">,</span> Deleter d <span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">Y</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Deleter</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Alloc</span> <span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">reset</span><span class="token punctuation">(</span> Y<span class="token operator">*</span> ptr<span class="token punctuation">,</span> Deleter d<span class="token punctuation">,</span> Alloc alloc <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><code>ptr：指向要取得所有权的对象的指针</code></li>
<li><code>d：指向要取得所有权的对象的指针</code></li>
<li><code>aloc：内部存储所用的分配器</code></li>
</ul>
<p>测试代码如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 使用智能指针管理一块 int 型的堆内存, 内部引用计数为 1</span>
    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ptr1 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">520</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ptr2 <span class="token operator">=</span> ptr1<span class="token punctuation">;</span>
    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ptr3 <span class="token operator">=</span> ptr1<span class="token punctuation">;</span>
    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ptr4 <span class="token operator">=</span> ptr1<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ptr1管理的内存引用计数: "</span> <span class="token operator">&lt;&lt;</span> ptr1<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ptr2管理的内存引用计数: "</span> <span class="token operator">&lt;&lt;</span> ptr2<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ptr3管理的内存引用计数: "</span> <span class="token operator">&lt;&lt;</span> ptr3<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ptr4管理的内存引用计数: "</span> <span class="token operator">&lt;&lt;</span> ptr4<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    ptr4<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ptr1管理的内存引用计数: "</span> <span class="token operator">&lt;&lt;</span> ptr1<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ptr2管理的内存引用计数: "</span> <span class="token operator">&lt;&lt;</span> ptr2<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ptr3管理的内存引用计数: "</span> <span class="token operator">&lt;&lt;</span> ptr3<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ptr4管理的内存引用计数: "</span> <span class="token operator">&lt;&lt;</span> ptr4<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ptr5<span class="token punctuation">;</span>
    ptr5<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">250</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ptr5管理的内存引用计数: "</span> <span class="token operator">&lt;&lt;</span> ptr5<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>测试代码输入的结果:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ptr1管理的内存引用计数: <span class="token number">4</span>
ptr2管理的内存引用计数: <span class="token number">4</span>
ptr3管理的内存引用计数: <span class="token number">4</span>
ptr4管理的内存引用计数: <span class="token number">4</span>
    
ptr1管理的内存引用计数: <span class="token number">3</span>
ptr2管理的内存引用计数: <span class="token number">3</span>
ptr3管理的内存引用计数: <span class="token number">3</span>
ptr4管理的内存引用计数: <span class="token number">0</span>
    
ptr5管理的内存引用计数: <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p><code>对于一个未初始化的共享智能指针，可以通过reset方法来初始化，当智能指针中有值的时候，调用reset会使引用计数减1。</code></p>
</blockquote>
<h4 id="e-获取原始指针"><a href="#e-获取原始指针" class="headerlink" title="e. 获取原始指针"></a><strong>e. 获取原始指针</strong></h4><p>通过智能指针可以管理一个普通变量或者对象的地址，此时原始地址就不可见了。当我们想要修改变量或者对象中的值的时候，就需要从智能指针对象中先取出数据的原始内存的地址再操作，解决方案是调用共享智能指针类提供的<code>get()</code>方法，其函数原型如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">T<span class="token operator">*</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>测试代码如下:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">128</span><span class="token punctuation">;</span>
    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> <span class="token function">ptr</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 得到指针的原始地址</span>
    <span class="token keyword">char</span><span class="token operator">*</span> add <span class="token operator">=</span> ptr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">memset</span><span class="token punctuation">(</span>add<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">strcpy</span><span class="token punctuation">(</span>add<span class="token punctuation">,</span> <span class="token string">"我是要成为海贼王的男人!!!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"string: "</span> <span class="token operator">&lt;&lt;</span> add <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    
    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"  "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>综合案例：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Test</span>
<span class="token punctuation">&#123;</span>

<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"空参构造函数"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"int型构造函数 x = "</span> <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">Test</span><span class="token punctuation">(</span>string str<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"string型构造函数 str = "</span> <span class="token operator">&lt;&lt;</span> str <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token operator">~</span><span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Test 析构函数被调用"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">int</span> nember <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"chcp 65001"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 1. 构造函数初始化</span>
    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ptr1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ptr1 use_count "</span> <span class="token operator">&lt;&lt;</span> ptr1<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    shared_ptr<span class="token operator">&lt;</span>Test<span class="token operator">></span> <span class="token function">ptr2</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    shared_ptr<span class="token operator">&lt;</span>Test<span class="token operator">></span> <span class="token function">ptr3</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token string">"hello world"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 2. 移动构造和拷贝构造函数初始化</span>
    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ptr4</span><span class="token punctuation">(</span><span class="token function">move</span><span class="token punctuation">(</span>ptr1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 移动</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ptr1 use_count "</span> <span class="token operator">&lt;&lt;</span> ptr1<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ptr4 use_count "</span> <span class="token operator">&lt;&lt;</span> ptr4<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    shared_ptr<span class="token operator">&lt;</span>Test<span class="token operator">></span> <span class="token function">ptr5</span><span class="token punctuation">(</span>ptr2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 拷贝</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ptr2 use_count "</span> <span class="token operator">&lt;&lt;</span> ptr2<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ptr5 use_count "</span> <span class="token operator">&lt;&lt;</span> ptr5<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token comment">// 3. 通过工厂函数std::make_shared 初始化</span>

    <span class="token comment">// 假如要创建共享指针的对象是类实例，在make_shared函数参数中填类构造函数参数</span>
    shared_ptr ptr6 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>Test<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    shared_ptr ptr7 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>Test<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token string">"args"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 4. reset函数</span>
    ptr4<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 重置当前共享指针，引用计数-1，若只有该指针引用，则释放内存</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ptr4 use_cout "</span> <span class="token operator">&lt;&lt;</span> ptr4<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token comment">// 5. get函数</span>
    shared_ptr<span class="token operator">&lt;</span>Test<span class="token operator">></span> <span class="token function">ptr8</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ptr8 use_cout "</span> <span class="token operator">&lt;&lt;</span> ptr8<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token comment">// shared_ptr内部重载了 &lt;&lt; 运算符调用get()</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ptr8 = "</span> <span class="token operator">&lt;&lt;</span> ptr8 <span class="token operator">&lt;&lt;</span> <span class="token string">"\nptr8.get() = "</span> <span class="token operator">&lt;&lt;</span> ptr8<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> ptr8<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span>nember <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="15-2-指定删除器"><a href="#15-2-指定删除器" class="headerlink" title="15.2 指定删除器"></a>15.2 指定删除器</h3><p>当智能指针管理的内存对应的引用计数变为0的时候，这块内存就会被智能指针析构掉了。另外，我们在初始化智能指针的时候也可以自己指定删除动作，这个删除操作对应的函数被称之为删除器，这个删除器函数本质是一个回调函数，我们只需要进行实现，其调用是由智能指针完成的。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token comment">// 自定义删除器函数，释放int型内存</span>
<span class="token keyword">void</span> <span class="token function">deleteIntPtr</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> p<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">delete</span> p<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"int 型内存被释放了..."</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ptr</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">250</span><span class="token punctuation">)</span><span class="token punctuation">,</span> deleteIntPtr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>删除器函数也可以是<code>lambda表达式</code>，因此代码也可以写成下面这样：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ptr</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">250</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">delete</span> p<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上面的代码中，<code>lambda表达式的参数就是智能指针管理的内存的地址（智能指针在调用删除器时传入的），有了这个地址之后函数体内部就可以完成删除操作了。</code></p>
<p><code>在C++11</code>中使用<code>shared_ptr</code>管理动态数组时，需要指定删除器，因为<code>std::shared_ptr的默认删除器不支持数组对象</code>(C++11以后支持)，具体的处理代码如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ptr</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span>p<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在删除数组内存时，除了自己编写删除器，也可以使用C++提供的<code>std::default_delete&lt;T&gt;()</code>函数作为删除器，这个函数内部的删除功能也是通过调用delete来实现的，要释放什么类型的内存就将模板类型T指定为什么类型即可。具体处理代码如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ptr</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">default_delete</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>另外，我们还可以自己封装一个make_shared_array方法来让shared_ptr支持数组，代码如下:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">make_share_array</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 返回匿名对象</span>
    <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">shared_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token keyword">new</span> T<span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">default_delete</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ptr1 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">make_share_array</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> ptr1<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> ptr2 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">make_share_array</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> ptr2<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="16-独占的智能指针"><a href="#16-独占的智能指针" class="headerlink" title="16.独占的智能指针"></a>16.独占的智能指针</h2><h3 id="16-1-unique-ptr的初始化"><a href="#16-1-unique-ptr的初始化" class="headerlink" title="16.1 unique_ptr的初始化"></a>16.1 unique_ptr的初始化</h3><p><code>std::unique_ptr是一个独占型的智能指针</code>，它不允许其他的智能指针共享其内部的指针，可以通过它的构造函数初始化一个独占智能指针对象，但是不允许通过赋值将一个unique_ptr赋值给另一个unique_ptr。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 通过构造函数初始化对象</span>
unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ptr1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// error, 不允许将一个unique_ptr赋值给另一个unique_ptr</span>
unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ptr2 <span class="token operator">=</span> ptr1<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>std::unique_ptr不允许复制，但是可以通过函数返回给其他的std::unique_ptr，还可以通过<code>std::move来转移给其他的std::unique_ptr</code>，这样原始指针的所有权就被转移了，这个原始指针还是被独占的。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">unique_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">520</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 通过构造函数初始化</span>
    unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ptr1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 通过转移所有权的方式初始化</span>
    unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ptr2 <span class="token operator">=</span> <span class="token function">move</span><span class="token punctuation">(</span>ptr1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ptr3 <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p><code>unique_ptr</code> 的移动构造函数签名：<code>unique_ptr(unique_ptr&amp;&amp;)</code></p>
</blockquote>
<p>unique_ptr独占智能指针类也有一个reset方法，函数原型如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">reset</span><span class="token punctuation">(</span> pointer ptr <span class="token operator">=</span> <span class="token function">pointer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>使用reset方法可以让unique_ptr解除对原始内存的管理，也可以用来初始化一个独占的智能指针。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span>

<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Test</span>
<span class="token punctuation">&#123;</span>

<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> member <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"constructed"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">member</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"constructed"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token operator">~</span><span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"destroy  member= "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">this</span><span class="token operator">-></span>member <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">unique_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">520</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>

    unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ptr1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// unique_ptr&lt;int> ptr2 = ptr1; // error 独享资源</span>
    unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ptr3</span><span class="token punctuation">(</span><span class="token function">move</span><span class="token punctuation">(</span>ptr1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 转移资源</span>
    unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ptr4 <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 将亡值  移动构造被调用</span>

    unique_ptr<span class="token operator">&lt;</span>Test<span class="token operator">></span> <span class="token function">ptr5</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    unique_ptr<span class="token operator">&lt;</span>Test<span class="token operator">></span> <span class="token function">ptr6</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    ptr5<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    ptr6<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><code>ptr1.reset();解除对原始内存的管理</code></li>
<li><code>ptr2.reset(new int(250));重新指定智能指针管理的原始内存</code></li>
</ul>
<p>输出结果为：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">constructed
constructed
destroy  <span class="token assign-left variable">member</span><span class="token operator">=</span> <span class="token number">0</span>
constructed
destroy  <span class="token assign-left variable">member</span><span class="token operator">=</span> <span class="token number">10</span>
destroy  <span class="token assign-left variable">member</span><span class="token operator">=</span> <span class="token number">20</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果想要获取独占智能指针管理的原始地址，可以调用get()方法，函数原型如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">pointer <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="16-2-删除器"><a href="#16-2-删除器" class="headerlink" title="16.2 删除器"></a>16.2 删除器</h3><p>unique_ptr指定删除器和shared_ptr指定删除器是有区别的，unique_ptr指定删除器的时候需要确定删除器的模板类型，所以不能像shared_ptr那样直接指定删除器，举例说明：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ptr1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">delete</span> p<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// ok</span>
unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ptr1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">delete</span> p<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// error</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">using</span> func_ptr <span class="token operator">=</span> <span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> func_ptr<span class="token operator">></span> <span class="token function">ptr1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">delete</span> p<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上面的代码中第7行，<code>func_ptr</code>的类型和<code>lambda表达式</code>的类型是一致的。在lambda表达式没有捕获任何变量的情况下是正确的，如果捕获了变量，编译时则会报错：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">using</span> func_ptr <span class="token operator">=</span> <span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> func_ptr<span class="token operator">></span> <span class="token function">ptr1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">delete</span> p<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// error</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面的代码中错误原因是这样的，在lambda表达式没有捕获任何外部变量时，可以直接转换为函数指针，一旦捕获了就无法转换了，如果想要让编译器成功通过编译，那么<code>需要使用可调用对象包装器来处理声明的函数指针</code>：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">using</span> func_ptr <span class="token operator">=</span> <span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">>></span> <span class="token function">ptr1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">delete</span> p<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">using</span> func_ptr <span class="token operator">=</span> <span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>Test<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 不捕获时，直接定义函数指针</span>
    unique_ptr<span class="token operator">&lt;</span>Test<span class="token punctuation">,</span> func_ptr<span class="token operator">></span> <span class="token function">ptr7</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>Test <span class="token operator">*</span>t<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> 
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"自定义删除器"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
        <span class="token keyword">delete</span> t<span class="token punctuation">;</span> 
    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 捕获外部变量时 需要使用可调用对象包装器来处理声明的函数指针</span>
    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
    unique_ptr<span class="token operator">&lt;</span>Test<span class="token punctuation">,</span> function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span>Test<span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">>></span> <span class="token function">ptr8</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">(</span>Test <span class="token operator">*</span>t<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> 
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"自定义删除器 x"</span> <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
        <span class="token keyword">delete</span> t<span class="token punctuation">;</span> 
    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// unique_ptr可以使用数组初始化</span>
    unique_ptr<span class="token operator">&lt;</span>Test<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token function">ptr9</span><span class="token punctuation">(</span><span class="token keyword">new</span> Test<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    ptr9<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="17-weak-ptr"><a href="#17-weak-ptr" class="headerlink" title="17.weak_ptr"></a>17.weak_ptr</h2><h3 id="17-1-基本使用方法"><a href="#17-1-基本使用方法" class="headerlink" title="17.1 基本使用方法"></a>17.1 基本使用方法</h3><p>弱引用智能指针<code>std::weak_ptr</code>可以看做是<code>shared_ptr的助手</code>，它不管理<code>shared_ptr</code>内部的指针。<code>std::weak_ptr</code>没有重载操作符<code>*</code>和<code>-&gt;</code>，因为它不共享指针，不能操作资源，所以它的构造不会增加引用计数，析构也不会减少引用计数，它的主要作用就是作为一个旁观者监视<code>shared_ptr</code>中管理的资源是否存在。</p>
<h4 id="a-初始化"><a href="#a-初始化" class="headerlink" title="a. 初始化"></a>a. 初始化</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 默认构造函数</span>
<span class="token keyword">constexpr</span> <span class="token function">weak_ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>
<span class="token comment">// 拷贝构造</span>
<span class="token function">weak_ptr</span> <span class="token punctuation">(</span><span class="token keyword">const</span> weak_ptr<span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">U</span><span class="token operator">></span> <span class="token function">weak_ptr</span> <span class="token punctuation">(</span><span class="token keyword">const</span> weak_ptr<span class="token operator">&lt;</span>U<span class="token operator">></span><span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>
<span class="token comment">// 通过shared_ptr对象构造</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">U</span><span class="token operator">></span> <span class="token function">weak_ptr</span> <span class="token punctuation">(</span><span class="token keyword">const</span> shared_ptr<span class="token operator">&lt;</span>U<span class="token operator">></span><span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在C++11中，<code>weak_ptr</code>的初始化可以通过以上提供的构造函数来完成初始化，具体使用方法如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
<span class="token punctuation">&#123;</span>
    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">sp</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    weak_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> wp1<span class="token punctuation">;</span>
    weak_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">wp2</span><span class="token punctuation">(</span>wp1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    weak_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">wp3</span><span class="token punctuation">(</span>sp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    weak_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> wp4<span class="token punctuation">;</span>
    wp4 <span class="token operator">=</span> sp<span class="token punctuation">;</span>
    weak_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> wp5<span class="token punctuation">;</span>
    wp5 <span class="token operator">=</span> wp3<span class="token punctuation">;</span>
    
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><code>weak_ptr&lt;int&gt; wp1;</code>构造了一个空<code>weak_ptr</code>对象</li>
<li><code>weak_ptr&lt;int&gt; wp2(wp1);</code>通过一个空<code>weak_ptr</code>对象构造了另一个空<code>weak_ptr</code>对象</li>
<li><code>weak_ptr&lt;int&gt; wp3(sp);</code>通过一个shared_ptr对象构造了一个可用的weak_ptr实例对象</li>
<li><code>wp4 = sp;</code>通过一个<code>shared_ptr</code>对象构造了一个可用的<code>weak_ptr</code>实例对象（这是一个隐式类型转换）</li>
<li><code>wp5 = wp3;</code>通过一个<code>weak_ptr</code>对象构造了一个可用的<code>weak_ptr</code>实例对象</li>
</ul>
<h3 id="17-2-其他常用方法"><a href="#17-2-其他常用方法" class="headerlink" title="17.2 其他常用方法"></a>17.2 其他常用方法</h3><h4 id="a-use-count"><a href="#a-use-count" class="headerlink" title="a. use_count()"></a>a. use_count()</h4><p>通过调用<code>std::weak_ptr类提供的use_count()</code>方法可以获得<code>当前所观测资源的引用计数</code>，函数原型如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 函数返回所监测的资源的引用计数</span>
<span class="token keyword">long</span> <span class="token keyword">int</span> <span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>修改一下上面的测试程序，添加打印资源引用计数的代码：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
<span class="token punctuation">&#123;</span>
    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">sp</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    weak_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> wp1<span class="token punctuation">;</span>
    weak_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">wp2</span><span class="token punctuation">(</span>wp1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    weak_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">wp3</span><span class="token punctuation">(</span>sp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    weak_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> wp4<span class="token punctuation">;</span>
    wp4 <span class="token operator">=</span> sp<span class="token punctuation">;</span>
    weak_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> wp5<span class="token punctuation">;</span>
    wp5 <span class="token operator">=</span> wp3<span class="token punctuation">;</span>

    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"use_count: "</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"wp1: "</span> <span class="token operator">&lt;&lt;</span> wp1<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"wp2: "</span> <span class="token operator">&lt;&lt;</span> wp2<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"wp3: "</span> <span class="token operator">&lt;&lt;</span> wp3<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"wp4: "</span> <span class="token operator">&lt;&lt;</span> wp4<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"wp5: "</span> <span class="token operator">&lt;&lt;</span> wp5<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>测试程序输出的结果为:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">use_count:
wp1: <span class="token number">0</span>
wp2: <span class="token number">0</span>
wp3: <span class="token number">1</span>
wp4: <span class="token number">1</span>
wp5: <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>通过打印的结果可以知道，虽然弱引用智能指针<code>wp3</code>、<code>wp4</code>、<code>wp5</code>监测的资源是同一个，但是它的引用计数并没有发生任何的变化，也进一步证明了<code>weak_ptr只是监测资源，并不管理资源。</code></p>
<h4 id="b-expired"><a href="#b-expired" class="headerlink" title="b. expired()"></a>b. expired()</h4><p>通过调用std::weak_ptr类提供的<code>expired()</code>方法来判断观测的资源是否已经被释放，函数原型如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 返回true表示资源已经被释放, 返回false表示资源没有被释放</span>
<span class="token keyword">bool</span> <span class="token function">expired</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>函数的使用方法如下:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
<span class="token punctuation">&#123;</span>
    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">shared</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    weak_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">weak</span><span class="token punctuation">(</span>shared<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"1. weak "</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>weak<span class="token punctuation">.</span><span class="token function">expired</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token string">"is"</span> <span class="token operator">:</span> <span class="token string">"is not"</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" expired"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    shared<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"2. weak "</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>weak<span class="token punctuation">.</span><span class="token function">expired</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token string">"is"</span> <span class="token operator">:</span> <span class="token string">"is not"</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" expired"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>测试代码输出的结果:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token number">1.</span> weak is <span class="token operator">not</span> expired
<span class="token number">2.</span> weak is expired<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><code>weak_ptr</code>监测的就是<code>shared_ptr</code>管理的资源，当共享智能指针调用<code>shared.reset();</code>之后管理的资源被释放，因此<code>weak.expired()</code>函数的结果返回<code>true</code>，表示监测的资源已经不存在了。</p>
<h4 id="c-lock"><a href="#c-lock" class="headerlink" title="c. lock()"></a>c. lock()</h4><p>通过调用<code>std::weak_ptr</code>类提供的<code>lock()</code>方法来获取管理所监测资源的shared_ptr对象，函数原型如下：</p>
<blockquote>
<p>不在于<code>weak_ptr的构造函数</code>的参数<code>shared_ptr</code>实例是否还存在，只要管理的资源的还在，就会创建一个新的<code>shared_ptr实例</code></p>
</blockquote>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">shared_ptr<span class="token operator">&lt;</span>element_type<span class="token operator">></span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>函数的使用方法如下:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> sp1<span class="token punctuation">,</span> sp2<span class="token punctuation">;</span>
    weak_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> wp<span class="token punctuation">;</span>

    sp1 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">520</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    wp <span class="token operator">=</span> sp1<span class="token punctuation">;</span>
    sp2 <span class="token operator">=</span> wp<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"use_count: "</span> <span class="token operator">&lt;&lt;</span> wp<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    sp1<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"use_count: "</span> <span class="token operator">&lt;&lt;</span> wp<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    sp1 <span class="token operator">=</span> wp<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"use_count: "</span> <span class="token operator">&lt;&lt;</span> wp<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"*sp1: "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>sp1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"*sp2: "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>sp2 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>测试代码输出的结果为:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">use_count<span class="token operator">:</span> <span class="token number">2</span>
use_count<span class="token operator">:</span> <span class="token number">1</span>
use_count<span class="token operator">:</span> <span class="token number">2</span>
<span class="token operator">*</span>sp1<span class="token operator">:</span> <span class="token number">520</span>
<span class="token operator">*</span>sp2<span class="token operator">:</span> <span class="token number">520</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><code>sp2 = wp.lock();</code>通过调用<code>lock()</code>方法得到一个用于管理<code>weak_ptr</code>对象所监测的资源的共享智能指针对象，使用这个对象初始化sp2，此时所监测资源的引用计数为2</li>
<li><code>sp1.reset();</code>共享智能指针<code>sp1</code>被重置，<code>weak_ptr</code>对象所监测的资源的引用计数减1</li>
<li><code>sp1 = wp.lock(); sp1</code>重新被初始化，并且管理的还是<code>weak_ptr</code>对象所监测的资源，因此引用计数加1</li>
<li>共享智能指针对象<code>sp1和sp2</code>管理的是同一块内存，因此最终打印的内存中的结果是相同的，都是520</li>
</ul>
<h4 id="d-reset"><a href="#d-reset" class="headerlink" title="d. reset()"></a>d. reset()</h4><p>通过调用<code>std::weak_ptr</code>类提供的<code>reset()</code>方法来清空对象，使其不监测任何资源，函数原型如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>函数的使用是非常简单的，示例代码如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> sp1<span class="token punctuation">,</span> sp2<span class="token punctuation">;</span>
    weak_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> wp<span class="token punctuation">;</span>

    sp1 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">520</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    wp <span class="token operator">=</span> sp1<span class="token punctuation">;</span> <span class="token comment">// weak_ptr内部重载了=运算符，使用wp监视sp1管理的内存</span>
    sp2 <span class="token operator">=</span> wp<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回一个指向管理内存的shraed_ptr </span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"use_count: "</span> <span class="token operator">&lt;&lt;</span> wp<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 所以现在有 sp1, sp2指向同一个内存</span>

    sp1<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 重置sp1</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"use_count: "</span> <span class="token operator">&lt;&lt;</span> wp<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 1 : sp2</span>

    sp1 <span class="token operator">=</span> wp<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"use_count: "</span> <span class="token operator">&lt;&lt;</span> wp<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 获得一个新的指向管理内存的shraed_ptr并赋值</span>

    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"*sp1: "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>sp1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"*sp2: "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>sp2 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>测试代码输出的结果为:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token number">1.</span> wp is <span class="token operator">not</span> expired
<span class="token number">2.</span> wp is expired<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="17-3-返回管理this的shared-ptr"><a href="#17-3-返回管理this的shared-ptr" class="headerlink" title="17.3 返回管理this的shared_ptr"></a>17.3 返回管理this的shared_ptr</h3><p>如果在一个类中编写了一个函数，通过这个得到管理当前对象的共享智能指针，我们可能会写出如下代码：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">Test</span>
<span class="token punctuation">&#123;</span>
    shared_ptr<span class="token operator">&lt;</span>Test<span class="token operator">></span> <span class="token function">getSharedPtr</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">shared_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span>Test<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    
    <span class="token operator">~</span><span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"class Test is disstruct ..."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
<span class="token punctuation">&#123;</span>
    shared_ptr<span class="token operator">&lt;</span>Test<span class="token operator">></span> <span class="token function">sp1</span><span class="token punctuation">(</span><span class="token keyword">new</span> Test<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"use_count: "</span> <span class="token operator">&lt;&lt;</span> sp1<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    shared_ptr<span class="token operator">&lt;</span>Test<span class="token operator">></span> sp2 <span class="token operator">=</span> sp1<span class="token operator">-></span><span class="token function">getSharedPtr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// this指向sp1管理的同一个Test对象</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"use_count: "</span> <span class="token operator">&lt;&lt;</span> sp1<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>执行上面的测试代码，运行中会出现异常，在终端还是能看到对应的日志输出：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">use_count<span class="token operator">:</span> <span class="token number">1</span>
use_count<span class="token operator">:</span> <span class="token number">1</span>
<span class="token keyword">class</span> <span class="token class-name">Test</span> is disstruct <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">class</span> <span class="token class-name">Test</span> is disstruct <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>通过输出的结果可以看到<code>一个对象被析构了两次</code>，其原因是这样的：在这个例子中使用同一个指针<code>this</code>构造了两个智能指针对象<code>sp1</code>和<code>sp2</code>，这二者之间是相互独立的<code>（有各自的控制块）</code>，因为sp2并不是通过sp1初始化得到的实例对象。在离开作用域之后<code>this将被构造的两个智能指针各自析构</code>，导致重复析构的错误。</p>
<blockquote>
<ol>
<li><strong>双重控制块问题</strong></li>
</ol>
<ul>
<li><code>ptr1</code> 通过 <code>new Test</code> 创建，生成第一个控制块，指向new出来的对象。</li>
<li><code>ptr2</code> 通过 <code>ptr1的getSharedPtr()</code> 用 <code>this</code> 创建，因为函数返回的是ptr1所管理的对象的裸指针，生成第二个独立的控制块。</li>
<li>两个 <code>shared_ptr</code> <strong>互相不知道对方的存在</strong></li>
</ul>
<h3 id="enable-shared-from-this-核心实现原理"><a href="#enable-shared-from-this-核心实现原理" class="headerlink" title="enable_shared_from_this 核心实现原理"></a><code>enable_shared_from_this</code> 核心实现原理</h3><h4 id="1-内部结构"><a href="#1-内部结构" class="headerlink" title="1. 内部结构"></a>1. <strong>内部结构</strong></h4><ul>
<li><code>enable_shared_from_this</code> 基类模板中维护一个 <code>weak_ptr</code> 成员：</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token operator">></span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">enable_shared_from_this</span> <span class="token punctuation">&#123;</span>
<span class="token operator">></span><span class="token keyword">private</span><span class="token operator">:</span>
   <span class="token keyword">mutable</span> weak_ptr<span class="token operator">&lt;</span>T<span class="token operator">></span> __weak_this_<span class="token punctuation">;</span> <span class="token comment">// 关键成员</span>
<span class="token operator">></span><span class="token keyword">public</span><span class="token operator">:</span>
   shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">shared_from_this</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
       <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">shared_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">></span></span></span><span class="token punctuation">(</span>__weak_this_<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 通过 weak_ptr 构造</span>
   <span class="token punctuation">&#125;</span>
<span class="token operator">></span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="2-控制块绑定流程"><a href="#2-控制块绑定流程" class="headerlink" title="2. 控制块绑定流程"></a>2. <strong>控制块绑定流程</strong></h4><p>当首次通过 <code>shared_ptr</code> 管理对象时：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token operator">></span>shared_ptr<span class="token operator">&lt;</span>Test<span class="token operator">></span> <span class="token function">ptr1</span><span class="token punctuation">(</span><span class="token keyword">new</span> Test<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Test 继承 enable_shared_f</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li><strong>步骤 1</strong>：创建 <code>shared_ptr</code> 时，构造控制块（包含强&#x2F;弱引用计数）</li>
<li>步骤 2：通过<code>shared_ptr</code>构造函数初始化基类的<code>__weak_this_：</code></li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token operator">></span><span class="token comment">// shared_ptr 构造函数伪代码</span>
<span class="token operator">></span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token operator">></span><span class="token function">shared_ptr</span><span class="token punctuation">(</span>T<span class="token operator">*</span> ptr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
   <span class="token comment">// 创建控制块</span>
   ctrl_block <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ControlBlock</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span> 

   <span class="token comment">// 如果 T 继承 enable_shared_from_this</span>
   <span class="token keyword">if</span> <span class="token keyword">constexpr</span> <span class="token punctuation">(</span>继承自 enable_shared_from_this<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
       ptr<span class="token operator">-></span>__weak_this_ <span class="token operator">=</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token comment">// 将 weak_ptr 绑定到控制块</span>
   <span class="token punctuation">&#125;</span>
<span class="token operator">></span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="3-shared-from-this-的工作机制"><a href="#3-shared-from-this-的工作机制" class="headerlink" title="3. shared_from_this() 的工作机制"></a>3. <strong>shared_from_this() 的工作机制</strong></h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token operator">></span>shared_ptr<span class="token operator">&lt;</span>Test<span class="token operator">></span> <span class="token class-name">Test</span><span class="token double-colon punctuation">::</span><span class="token function">getSharedPtr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
   <span class="token keyword">return</span> <span class="token function">shared_from_this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token operator">></span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<ul>
<li><strong>步骤 1</strong>：通过 <code>__weak_this_.lock()</code> 尝试提升为 <code>shared_ptr</code></li>
<li><strong>步骤 2</strong>：若成功（对象未被释放），返回与原 <code>shared_ptr</code> <strong>共享控制块</strong>的新 <code>shared_ptr</code></li>
<li><strong>步骤 3</strong>：强引用计数 +1，确保对象生命周期正确延长</li>
</ul>
</blockquote>
<p>这个问题可以通过<code>weak_ptr</code>来解决，通过<code>weak_ptr</code>返回管理<code>this资源的共享智能指针对象shared_ptr</code>。C++11中为我们提供了一个模板类叫做<code>std::enable_shared_from_this&lt;T&gt;</code>，这个类中有一个方法叫做<code>shared_from_this()</code>，通过这个方法可以返回一个共享智能指针，在函数的内部就是使用weak_ptr来监测this对象，并通过调用<code>weak_ptr</code>的<code>lock()</code>方法返回一个shared_ptr对象。</p>
<p>修改之后的代码为：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">Test</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">enable_shared_from_this</span><span class="token operator">&lt;</span><span class="token class-name">Test</span><span class="token operator">></span></span>
<span class="token punctuation">&#123;</span>
    shared_ptr<span class="token operator">&lt;</span>Test<span class="token operator">></span> <span class="token function">getSharedPtr</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token function">shared_from_this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token operator">~</span><span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"class Test is disstruct ..."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
<span class="token punctuation">&#123;</span>
    shared_ptr<span class="token operator">&lt;</span>Test<span class="token operator">></span> <span class="token function">sp1</span><span class="token punctuation">(</span><span class="token keyword">new</span> Test<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"use_count: "</span> <span class="token operator">&lt;&lt;</span> sp1<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    shared_ptr<span class="token operator">&lt;</span>Test<span class="token operator">></span> sp2 <span class="token operator">=</span> sp1<span class="token operator">-></span><span class="token function">getSharedPtr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"use_count: "</span> <span class="token operator">&lt;&lt;</span> sp1<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>测试代码输出的结果为:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">use_count<span class="token operator">:</span> <span class="token number">1</span>
use_count<span class="token operator">:</span> <span class="token number">2</span>
<span class="token keyword">class</span> <span class="token class-name">Test</span> is disstruct <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>最后需要强调一个细节：在调用<code>enable_shared_from_this</code>类的<code>shared_from_this()</code>方法之前，必须要先<code>初始化函数内部weak_ptr对象</code>，否则该函数无法返回一个有效的shared_ptr对象（具体处理方法可以参考上面的示例代码第19行）。</p>
</blockquote>
<h3 id="17-4-解决循环引用问题"><a href="#17-4-解决循环引用问题" class="headerlink" title="17.4 解决循环引用问题"></a>17.4 解决循环引用问题</h3><p>智能指针如果循环引用会导致内存泄露，比如下面的例子：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/12/25/cpp11-xin-te-xing/image-20250224205147493.png" alt="image-20250224205147493" style="zoom:67%;">

<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">TA</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">TB</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">TA</span>
<span class="token punctuation">&#123;</span>
    shared_ptr<span class="token operator">&lt;</span>TB<span class="token operator">></span> bptr<span class="token punctuation">;</span>
    <span class="token operator">~</span><span class="token function">TA</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"class TA is disstruct ..."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">TB</span>
<span class="token punctuation">&#123;</span>
    shared_ptr<span class="token operator">&lt;</span>TA<span class="token operator">></span> aptr<span class="token punctuation">;</span>
    <span class="token operator">~</span><span class="token function">TB</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"class TB is disstruct ..."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">testPtr</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    shared_ptr<span class="token operator">&lt;</span>TA<span class="token operator">></span> <span class="token function">ap</span><span class="token punctuation">(</span><span class="token keyword">new</span> TA<span class="token punctuation">)</span><span class="token punctuation">;</span>
    shared_ptr<span class="token operator">&lt;</span>TB<span class="token operator">></span> <span class="token function">bp</span><span class="token punctuation">(</span><span class="token keyword">new</span> TB<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"TA object use_count: "</span> <span class="token operator">&lt;&lt;</span> ap<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 1</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"TB object use_count: "</span> <span class="token operator">&lt;&lt;</span> bp<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 1</span>

    ap<span class="token operator">-></span>bptr <span class="token operator">=</span> bp<span class="token punctuation">;</span> <span class="token comment">// 发生了拷贝</span>
    bp<span class="token operator">-></span>aptr <span class="token operator">=</span> ap<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"TA object use_count: "</span> <span class="token operator">&lt;&lt;</span> ap<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 2</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"TB object use_count: "</span> <span class="token operator">&lt;&lt;</span> bp<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 2 </span>
<span class="token punctuation">&#125;</span>
<span class="token comment">// bp离开作用域后，bp指向的（TB）引用计数-1 = 1</span>
<span class="token comment">// ap离开作用域</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">testPtr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>测试程序输出的结果如下:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">TA object use_count<span class="token operator">:</span> <span class="token number">1</span>
TB object use_count<span class="token operator">:</span> <span class="token number">1</span>
TA object use_count<span class="token operator">:</span> <span class="token number">2</span>
TB object use_count<span class="token operator">:</span> <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>在测试程序中，共享智能指针<code>ap</code>、<code>bp</code>对<code>TA</code>、<code>TB</code>实例对象的引用计数变为2，<code>在共享智能指针离开作用域之后引用计数只能减为1</code>，这种情况下不会去删除智能指针管理的内存，导致类<code>TA</code>、<code>TB</code>的实例对象不能被析构，最终造成内存泄露。通过使用<code>weak_ptr</code>可以解决这个问题，只要将类<code>TA</code>或者<code>TB</code>的任意一个成员改为<code>weak_ptr</code>，修改之后的代码如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">TA</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">TB</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">TA</span>
<span class="token punctuation">&#123;</span>
    weak_ptr<span class="token operator">&lt;</span>TB<span class="token operator">></span> bptr<span class="token punctuation">;</span>
    <span class="token operator">~</span><span class="token function">TA</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"class TA is disstruct ..."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">TB</span>
<span class="token punctuation">&#123;</span>
    shared_ptr<span class="token operator">&lt;</span>TA<span class="token operator">></span> aptr<span class="token punctuation">;</span>
    <span class="token operator">~</span><span class="token function">TB</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"class TB is disstruct ..."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">testPtr</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    shared_ptr<span class="token operator">&lt;</span>TA<span class="token operator">></span> <span class="token function">ap</span><span class="token punctuation">(</span><span class="token keyword">new</span> TA<span class="token punctuation">)</span><span class="token punctuation">;</span>
    shared_ptr<span class="token operator">&lt;</span>TB<span class="token operator">></span> <span class="token function">bp</span><span class="token punctuation">(</span><span class="token keyword">new</span> TB<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"TA object use_count: "</span> <span class="token operator">&lt;&lt;</span> ap<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"TB object use_count: "</span> <span class="token operator">&lt;&lt;</span> bp<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    ap<span class="token operator">-></span>bptr <span class="token operator">=</span> bp<span class="token punctuation">;</span>
    bp<span class="token operator">-></span>aptr <span class="token operator">=</span> ap<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"TA object use_count: "</span> <span class="token operator">&lt;&lt;</span> ap<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"TB object use_count: "</span> <span class="token operator">&lt;&lt;</span> bp<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">testPtr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>程序输出的结果:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">TA object use_count<span class="token operator">:</span> <span class="token number">1</span>
TB object use_count<span class="token operator">:</span> <span class="token number">1</span>
TA object use_count<span class="token operator">:</span> <span class="token number">2</span>
TB object use_count<span class="token operator">:</span> <span class="token number">1</span>
<span class="token keyword">class</span> <span class="token class-name">TB</span> is disstruct <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">class</span> <span class="token class-name">TA</span> is disstruct <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>通过输出的结果可以看到类<code>TA</code>或者<code>TB</code>的对象被成功析构了。</p>
<p>上面程序中，在对类TA成员赋值时<code>ap-&gt;bptr = bp;</code>由于<code>bptr</code>是<code>weak_ptr类型，这个赋值操作并不会增加引用计数，所以bp的引用计数仍然为1，在离开作用域之后bp的引用计数减为0，类TB的实例对象被析构。</code></p>
<p>在类TB的实例对象被析构的时候，内部的<code>aptr</code>也被析构，其对<code>TA</code>对象的管理解除，内存的引用计数减为1，当共享智能指针ap离开作用域之后，对TA对象的管理也解除了，内存的引用计数减为0，类TA的实例对象被析构。</p>
<h2 id="18-final和override"><a href="#18-final和override" class="headerlink" title="18.final和override"></a>18.final和override</h2><h3 id="18-1-final关键字"><a href="#18-1-final关键字" class="headerlink" title="18.1 final关键字"></a>18.1 final关键字</h3><p>C++中增加了<code>final关键字来限制某个类不能被继承，或者某个虚函数不能被重写</code>，和Java的final关键字的功能是类似的。如果使用<code>final修饰函数</code>，只能修饰虚函数，并且要把final关键字放到类或者函数的后面。</p>
<ul>
<li><code>如果使用final修饰函数，只能修饰虚函数，这样就能阻止子类重写父类的这个函数了</code></li>
<li><code>使用final关键字修饰过的类是不允许被继承的，也就是说这个类不能有派生类。</code></li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Father</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">override_import</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Son</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Father</span></span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">final</span> <span class="token comment">// ① 继承抽象类的派生类必须重写方法，否则继承抽象类属性</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Son print"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">void</span> <span class="token function">override_import_worng</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">override</span> 
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"重写了方法"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">void</span> <span class="token function">override_import</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">override</span><span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"重写了方法"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">GrandChild</span> <span class="token keyword">final</span> <span class="token operator">:</span> <span class="token keyword">public</span> Son <span class="token comment">// 类使用final关键字修饰 -> 不允许被继承</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// virtual void Print()&#123;&#125; // 无法重写final函数</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token comment">// class Test : public GrandChild&#123;&#125;; // error</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// Father father; // ② 抽象类（有纯虚函数的类）不允许创建实例</span>
    Son son<span class="token punctuation">;</span>
    son<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/12/25/cpp11-xin-te-xing/image-20250225135412061.png" alt="image-20250225135412061" style="zoom:80%;">

<h3 id="18-2-override关键字"><a href="#18-2-override关键字" class="headerlink" title="18.2 override关键字"></a>18.2 override关键字</h3><p><code>override</code>关键字确保在<code>派生类中声明的重写函数与基类的虚函数有相同的签名</code>，同时也明确表明将会重写基类的虚函数，这样就可以保证重写的虚函数的正确性，也提高了代码的可读性，<code>和final一样这个关键字要写到方法的后面</code>。使用方法如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Base class..."</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">override</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Child class..."</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">GrandChild</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Child</span></span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">override</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Child class..."</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上述代码中第13行和第22行就是显示指定了要重写<code>父类的test()方法</code>，使用了<code>override</code>关键字之后，假设在重写过程中因为误操作，写错了函数名或者函数参数或者返回值编译器都会提示语法错误，提高了程序的正确性，降低了出错的概率。</p>
<h2 id="19-类成员的快速初始化"><a href="#19-类成员的快速初始化" class="headerlink" title="19.类成员的快速初始化"></a>19.类成员的快速初始化</h2><h3 id="19-1-c-98的类成员初始化"><a href="#19-1-c-98的类成员初始化" class="headerlink" title="19.1 c++98的类成员初始化"></a>19.1 c++98的类成员初始化</h3><p>在C++98中，支持了在**<code>类声明中使用等号 = 加初始值</code>** 的方式，来初始化类中**<code>静态成员常量</code>** 。这种声明方式我们也称之为<code>”就地”</code>声明。而非<code>静态成员变量的初始化则必须在构造函数中进行。</code></p>
<p>下面通过一段代码举例说明：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Base</span> 
<span class="token punctuation">&#123;</span>
    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token number">250</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">a</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

    <span class="token keyword">int</span> a<span class="token punctuation">;</span>
    <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>	
    <span class="token keyword">static</span> <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>	
    <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">double</span> d <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span>	
    <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token keyword">const</span> e <span class="token operator">=</span> <span class="token string">"i am luffy"</span><span class="token punctuation">;</span>	
    <span class="token keyword">const</span> <span class="token keyword">static</span> <span class="token keyword">int</span> f <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>	
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>如果按照 c++98 标准来解读上面这段代码</code> ，其中有这么几行语法是错误的：</p>
<ul>
<li><p>第7行：类的<code>非静态成员，必须在构造函数中进行初始化</code></p>
</li>
<li><p>第8行：类的<code>静态成员，必须在类的外部进行初始化</code></p>
</li>
<li><p>第9行：类的静态常量成员，<code>但不是整形或者枚举，无法通过编译</code></p>
</li>
<li><p>第10行：类的静态常量成员，<code>但不是整形或者枚举，无法通过编译</code></p>
</li>
<li><p>第8、9、10行的变量初始化方式是一样的，都是在类的外部</p>
</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> Base<span class="token double-colon punctuation">::</span>c <span class="token operator">=</span> <span class="token number">110</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">double</span> Base<span class="token double-colon punctuation">::</span>d <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token keyword">const</span> Base<span class="token double-colon punctuation">::</span>e <span class="token operator">=</span> <span class="token string">"i am luffy"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h3 id="19-2-c-11标准的类成员快速初始化"><a href="#19-2-c-11标准的类成员快速初始化" class="headerlink" title="19.2 c++11标准的类成员快速初始化"></a>19.2 c++11标准的类成员快速初始化</h3><p><strong>a. 初始化类的非静态成员</strong></p>
<p>在进行类成员变量初始化的时候，C++11标准对于C++98做了补充，允许在定义类的时候在类内部直接对非静态成员变量进行初始化，<code>在初始化的时候可以使用等号 = 也可以使用花括号 &#123;&#125; 。</code></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Test</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">5</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> c<span class="token punctuation">&#123;</span><span class="token number">12</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token keyword">double</span> array<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">3.14</span><span class="token punctuation">,</span> <span class="token number">3.15</span><span class="token punctuation">,</span> <span class="token number">3.16</span><span class="token punctuation">,</span> <span class="token number">3.17</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token keyword">double</span> array1<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span> <span class="token number">3.14</span><span class="token punctuation">,</span> <span class="token number">3.15</span><span class="token punctuation">,</span> <span class="token number">3.16</span><span class="token punctuation">,</span> <span class="token number">3.17</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    string <span class="token function">s1</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// error</span>
    string s2<span class="token punctuation">&#123;</span> <span class="token string">"hello, world"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>可以看到如果使用花括号 {}的方式对类的非静态成员进行初始化，等号是可以省略不写的。</p>
<ul>
<li>第9行：<code>错误，不能使用小括号() 初始化对象，应该使用花括号&#123;&#125;</code></li>
</ul>
<p><strong>b. 构造函数内部初始化和初始化列表</strong></p>
<p>在C++11之前对于非静态的类成员变量我们除了在构造函数内部进行赋值，也可以在类的初始化列表中进行初始化（这种方式比在构造函数内部赋值效率高）。那么，如果同时在类内部对非静态成员变量就地初始化和在初始化列表中进行初始化会怎么样呢？下面来测试一下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">Test</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>

    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">x</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">y</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token keyword">const</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Test t<span class="token punctuation">;</span>

    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"x="</span> <span class="token operator">&lt;&lt;</span> t<span class="token punctuation">.</span>x <span class="token operator">&lt;&lt;</span> <span class="token string">", y="</span> <span class="token operator">&lt;&lt;</span> t<span class="token punctuation">.</span>y <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>最后输出结果：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">x</span><span class="token operator">=</span><span class="token number">3</span>, <span class="token assign-left variable">y</span><span class="token operator">=</span><span class="token number">4</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>我们可以从函数的打印输出中看到，<code>在类内部就地初始化和初始化列表并不冲突（程序可以正常运行）</code>。程序员可以为同一成员变量既在类内部就地初始化，又在初始化列表中进行初始化，只不过初始化列表总是看起来后作用于非静态成员。也就是说，通过初始化列表指定的值会覆盖就地初始化时指定的值。</p>
<p><code>而构造函数体的赋值又会覆盖初始化列表</code></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Test</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>

    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">x</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">y</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">this</span><span class="token operator">-></span>x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token operator">-></span>y <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>最后输出结果是：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">x</span><span class="token operator">=</span><span class="token number">5</span>, <span class="token assign-left variable">y</span><span class="token operator">=</span><span class="token number">6</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="20-超长整形longlong"><a href="#20-超长整形longlong" class="headerlink" title="20.超长整形longlong"></a>20.超长整形longlong</h2><p>相比于C++98标准，C++11整型的最大改变就是多了<code>long long</code>。但事实上，long long 整型本来就离C++标准很近，早在1995年，long long 就被提议写入 C++98标准，却被C++标准委员会拒绝了。而后来，long long类型却进入了C99标准，而且也事实上也被很多编译器支持。于是辗转地，C++标准委员会又掉头决定将 long long纳入 C++11标准。</p>
<h3 id="20-1-longlong类型"><a href="#20-1-longlong类型" class="headerlink" title="20.1 longlong类型"></a>20.1 longlong类型</h3><p>C++11 标准要求 long long 整型可以在不同平台上有不同的长度，但<code>至少有64位</code>。long long 整型有两种∶</p>
<ul>
<li><code>long long</code> - 对应类型的数值可以使用 LL (大写) 或者 ll (小写) 后缀</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">long</span> <span class="token keyword">long</span> num1 <span class="token operator">=</span> <span class="token number">123456789LL</span><span class="token punctuation">;</span>
<span class="token keyword">long</span> <span class="token keyword">long</span> num2 <span class="token operator">=</span> <span class="token number">123456789ll</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul>
<li><code>unsigned long long</code> - 对应类型的数值可以使用 ULL (大写) 或者 ull (小写) 或者 Ull、uLL (等大小写混合)后缀</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> num1 <span class="token operator">=</span> <span class="token number">123456789ULL</span><span class="token punctuation">;</span>
<span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> num2 <span class="token operator">=</span> <span class="token number">123456789ull</span><span class="token punctuation">;</span>
<span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> num3 <span class="token operator">=</span> <span class="token number">123456789uLL</span><span class="token punctuation">;</span>
<span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> num4 <span class="token operator">=</span> <span class="token number">123456789Ull</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>事实上在C++11中还有一些类型与以上两种类型是等价的:</p>
<ul>
<li><p>对于有符号类型的 long long和以下三种类型等价</p>
<ul>
<li><code>long long int</code></li>
<li><code>signed long long</code></li>
<li><code>signed long long int</code></li>
</ul>
</li>
<li><p>对于无符号类型的unsigned long long 和unsigned long long int是等价的</p>
</li>
</ul>
<p>同其他的整型一样，要了解平台上 long long大小的方法就是查看<code>&lt;climits&gt;</code>（或<code>&lt;limits. h&gt;</code> ）中的宏与long long整 型相关的一共有3个：</p>
<ul>
<li><code>LLONG_MIN</code> - 最小的long long值</li>
<li><code>LLONG_MAX</code> - 最大的long long 值</li>
<li><code>ULLONG MAX</code> - 最大的 unsigned long long 值</li>
</ul>
<p>测试代码如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> max <span class="token operator">=</span> LLONG_MAX<span class="token punctuation">;</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> min <span class="token operator">=</span> LLONG_MIN<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> ullMax <span class="token operator">=</span> ULLONG_MAX<span class="token punctuation">;</span>

    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Max Long Long value: "</span> <span class="token operator">&lt;&lt;</span> max <span class="token operator">&lt;&lt;</span> endl
         <span class="token operator">&lt;&lt;</span> <span class="token string">"Min Long Long value: "</span> <span class="token operator">&lt;&lt;</span> min <span class="token operator">&lt;&lt;</span> endl
         <span class="token operator">&lt;&lt;</span> <span class="token string">"Max unsigned Long Long value: "</span> <span class="token operator">&lt;&lt;</span> ullMax <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>程序输出结果：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Max Long Long value<span class="token operator">:</span> <span class="token number">9223372036854775807</span>
Min Long Long value<span class="token operator">:</span> <span class="token operator">-</span><span class="token number">9223372036854775808</span>
Max <span class="token keyword">unsigned</span> Long Long value<span class="token operator">:</span> <span class="token number">18446744073709551615</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h3 id="20-2-扩展的整形"><a href="#20-2-扩展的整形" class="headerlink" title="20.2 扩展的整形"></a>20.2 扩展的整形</h3><p>在C++11中一共只定义了以下5种标准的有符号整型：</p>
<ul>
<li><code>signed char</code></li>
<li><code>short int</code></li>
<li><code>int</code></li>
<li><code>long int</code></li>
<li><code>long long int</code></li>
</ul>
<p>标准同时规定，每一种有符号整型都有一种对应的无符号整数版本，且有符号整型与其对应的无符号整型具有相同的存储空间大小。比如与 signed int对应的无符号版本的整型是 unsigned int。</p>
<p>当我们在C++中处理数据的时候，如果<code>参与运算的数据或者传递的参数类型不匹配，整型间会发生隐式的转换</code>，这种过程通常被称为<code>整型的提升</code>。比如如下表达式∶</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>num1 <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">)</span>num2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>关于这种整形提升的<code>隐式转换遵循如下原则</code>:</p>
<ul>
<li>长度越大的整型等级越高，比如 long long int 的等级会高于int。</li>
<li>长度相同的情况下，标准整型的等级高于扩展类型，比如 long long int 和 int64 如果 都是64 位长度，则long long int类型的等级更高。 </li>
<li>相同大小的有符号类型和无符号类型的等级相同，long long int 和unsigned longlong  int的等级就相同。</li>
<li>转换过程中，低等级整型需要转换为高等级整型，有符号的需要转换为无符号整形。</li>
</ul>
<h2 id="21-数值类型和字符串之间的转换"><a href="#21-数值类型和字符串之间的转换" class="headerlink" title="21.数值类型和字符串之间的转换"></a>21.数值类型和字符串之间的转换</h2><h3 id="21-1-数值转成字符串"><a href="#21-1-数值转成字符串" class="headerlink" title="21.1 数值转成字符串"></a>21.1 数值转成字符串</h3><p>使用<code>to_string()</code>方法可以非常方便地将各种数值类型转换为字符串类型，这是一个重载函，函数声明位于头文件<code>&lt;string&gt;</code>中，函数原型如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 头文件 &lt;string></span>
string <span class="token function">to_string</span> <span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>
string <span class="token function">to_string</span> <span class="token punctuation">(</span><span class="token keyword">long</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>
string <span class="token function">to_string</span> <span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>
string <span class="token function">to_string</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>
string <span class="token function">to_string</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>
string <span class="token function">to_string</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>
string <span class="token function">to_string</span> <span class="token punctuation">(</span><span class="token keyword">float</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>
string <span class="token function">to_string</span> <span class="token punctuation">(</span><span class="token keyword">double</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>
string <span class="token function">to_string</span> <span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">double</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>关于函数的使用是非常简单的，示例代码如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    string pi <span class="token operator">=</span> <span class="token string">"pi is "</span> <span class="token operator">+</span> <span class="token function">to_string</span><span class="token punctuation">(</span><span class="token number">3.1415926</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    string love <span class="token operator">=</span> <span class="token string">"love is "</span> <span class="token operator">+</span> <span class="token function">to_string</span><span class="token punctuation">(</span><span class="token number">5.20</span> <span class="token operator">+</span> <span class="token number">13.14</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> pi <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> love <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="21-2-字符串转换成数值"><a href="#21-2-字符串转换成数值" class="headerlink" title="21.2 字符串转换成数值"></a>21.2 字符串转换成数值</h3><p>由于C++中的数值类型包括<code>整形</code>和<code>浮点型</code>，因此针对于不同的类型提供了不同的函数，通过调用这些函数可以将字符串类型转换为对应的数值类型。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 定义于头文件 &lt;string></span>
<span class="token keyword">int</span>       <span class="token function">stoi</span><span class="token punctuation">(</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> str<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>size_t<span class="token operator">*</span> pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">int</span> base <span class="token operator">=</span> <span class="token number">10</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">long</span>      <span class="token function">stol</span><span class="token punctuation">(</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> str<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>size_t<span class="token operator">*</span> pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">int</span> base <span class="token operator">=</span> <span class="token number">10</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">stoll</span><span class="token punctuation">(</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> str<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>size_t<span class="token operator">*</span> pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">int</span> base <span class="token operator">=</span> <span class="token number">10</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">unsigned</span> <span class="token keyword">long</span>      <span class="token function">stoul</span><span class="token punctuation">(</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> str<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>size_t<span class="token operator">*</span> pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">int</span> base <span class="token operator">=</span> <span class="token number">10</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">stoull</span><span class="token punctuation">(</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> str<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>size_t<span class="token operator">*</span> pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">int</span> base <span class="token operator">=</span> <span class="token number">10</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">float</span>       <span class="token function">stof</span><span class="token punctuation">(</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> str<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>size_t<span class="token operator">*</span> pos <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">double</span>      <span class="token function">stod</span><span class="token punctuation">(</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> str<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>size_t<span class="token operator">*</span> pos <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">long</span> <span class="token keyword">double</span> <span class="token function">stold</span><span class="token punctuation">(</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> str<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>size_t<span class="token operator">*</span> pos <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><code>str</code>：要转换的字符串</li>
<li><code>pos</code>：传出参数, 记录从哪个字符开始无法继续进行解析, 比如: <code>123abc</code>, 传出的位置为<code>3</code></li>
<li><code>base</code>：若 base 为 <code>0</code> ，则自动检测数值进制：若前缀为 <code>0</code> ，则为八进制，若前缀为 <code>0x 或 0X</code>，则为十六进制，否则为十进制。</li>
</ul>
<p>这些函数虽然都有多个参数，但是除去第一个参数外其他都有默认值，一般情况下使用默认值就能满足需求。关于函数的使用也给大家提供了一个例子，示例代码如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    string str1 <span class="token operator">=</span> <span class="token string">"45"</span><span class="token punctuation">;</span>
    string str2 <span class="token operator">=</span> <span class="token string">"3.14159"</span><span class="token punctuation">;</span>
    string str3 <span class="token operator">=</span> <span class="token string">"9527 with words"</span><span class="token punctuation">;</span>
    string str4 <span class="token operator">=</span> <span class="token string">"words and 2"</span><span class="token punctuation">;</span>

    <span class="token keyword">int</span> myint1 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">stoi</span><span class="token punctuation">(</span>str1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">float</span> myint2 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">stof</span><span class="token punctuation">(</span>str2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> myint3 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">stoi</span><span class="token punctuation">(</span>str3<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 错误： 'std::invalid_argument'</span>
    <span class="token comment">// int myint4 = std::stoi(str4);</span>

    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"std::stoi(\""</span> <span class="token operator">&lt;&lt;</span> str1 <span class="token operator">&lt;&lt;</span> <span class="token string">"\") is "</span> <span class="token operator">&lt;&lt;</span> myint1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"std::stof(\""</span> <span class="token operator">&lt;&lt;</span> str2 <span class="token operator">&lt;&lt;</span> <span class="token string">"\") is "</span> <span class="token operator">&lt;&lt;</span> myint2 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"std::stoi(\""</span> <span class="token operator">&lt;&lt;</span> str3 <span class="token operator">&lt;&lt;</span> <span class="token string">"\") is "</span> <span class="token operator">&lt;&lt;</span> myint3 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token comment">// cout &lt;&lt; "std::stoi(\"" &lt;&lt; str4 &lt;&lt; "\") is " &lt;&lt; myint4 &lt;&lt; endl;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>示例代码输入的结果如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span><span class="token function">stoi</span><span class="token punctuation">(</span><span class="token string">"45"</span><span class="token punctuation">)</span> is <span class="token number">45</span>
std<span class="token double-colon punctuation">::</span><span class="token function">stof</span><span class="token punctuation">(</span><span class="token string">"3.14159"</span><span class="token punctuation">)</span> is <span class="token number">3.14159</span>
std<span class="token double-colon punctuation">::</span><span class="token function">stoi</span><span class="token punctuation">(</span><span class="token string">"9527 with words"</span><span class="token punctuation">)</span> is <span class="token number">9527</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>从上述测试程序可以得出这样的结论，在C++11提供的这些转换函数将字符串转换为数值的过程中：</p>
<ul>
<li><code>如果字符串中所有字符都是数值类型，整个字符串会被转换为对应的数值，并通过返回值返回</code></li>
<li><code>如果字符串的前半部分字符是数值类型，后半部不是，那么前半部分会被转换为对应的数值，并通过返回值返回</code></li>
<li><code>如果字符第一个字符不是数值类型转换失败</code></li>
</ul>
<h2 id="22-静态断言"><a href="#22-静态断言" class="headerlink" title="22.静态断言"></a>22.静态断言</h2><h3 id="22-1-断言"><a href="#22-1-断言" class="headerlink" title="22.1 断言"></a>22.1 断言</h3><p><code>断言（assertion）是一种编程中常用的手段。</code>在通常情况下，断言就是将一个返回值总是需要为真的判断表达式放在语句中，用于排除在设计的逻辑上不应该产生的情况。</p>
<p>比如：一个函数总需要输入在一定的范围内的参数，那么程序员就可以对该参数使用断言，以迫使在该参数发生异常的时候程序退出，从而避免程序陷入逻辑的混乱。 </p>
<p>从一些意义上讲，断言并不是正常程序所必需的，不过对于程序调试来说，通常断言能够帮助程序开发者快速定位那些违反了某些前提条件的程序错误。</p>
<p>如果我们要在C++程序中使用断言，需要在程序中包含头文件<code>&lt;cassert&gt;</code>或<code>&lt;assert.h&gt;</code>，头文件中为我们提供了 assert 宏，用于在运行时进行断言。举例说明：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cassert></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token comment">// 创建一个指定大小的 char 类型数组</span>
<span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">createArray</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 通过断言判断数组大小是否大于0</span>
    <span class="token function">assert</span><span class="token punctuation">(</span>size <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 必须大于0, 否则程序中断</span>
    <span class="token keyword">char</span><span class="token operator">*</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> array<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">char</span><span class="token operator">*</span> buf <span class="token operator">=</span> <span class="token function">createArray</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 此处使用的是vs提供的安全函数, 也可以使用 strcpy</span>
    <span class="token function">strcpy_s</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token string">"hello, world!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"buf = "</span> <span class="token operator">&lt;&lt;</span> buf <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span>buf<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在程序的第9行，使用了<code>断言assert(expression)</code>，这是一个宏，它的参数是一个<code>表达式</code>，这个表达式通常返回一个布尔类型的值，并且要求<code>表达式必须为 true 程序才能继续向下执行，否则会直接中断。</code></p>
<ul>
<li>如果 createArray参数大于0，程序在16行正常运行直到结束</li>
<li>如果 createArray参数小于等于0，程序运行到16行直接退出，会看到如下的提示信息：</li>
</ul>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Assertion failed: size <span class="token operator">></span> <span class="token number">0</span>, <span class="token function">file</span> .<span class="token punctuation">\</span>32_断言.cpp, line <span class="token number">7</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="22-2-静态断言"><a href="#22-2-静态断言" class="headerlink" title="22.2 静态断言"></a>22.2 静态断言</h3><p>在上面的例子中我们使用了断言 assert。但<code>assert是一个运行时断言，也就是说它只有在程序运行时才能起作用</code>。这意味着不运行程序我们将无法得知某些条件是否是成立的。 比如：我们想知道当前是32位还是64位平台，对于这个需求我们应该是在程序运行之前就应该得到结果，如果使用断言显然是无法做到的，对于这种情况我们就需要使用C++11提供的静态断言了。</p>
<p>静态断言 <code>static_assert</code>，所谓静态就是在<code>编译时就能够进行检查的断言</code>，使用时不需要引用头文件。静态断言的另一个好处是，可以自定义违反断言时的错误提示信息。静态断言使用起来非常简单，它接收两个参数：</p>
<ul>
<li>参数1：<code>断言表达式，这个表达式通常需要返回一个 bool值</code></li>
<li>参数2：<code>警告信息，它通常就是一段字符串，在违反断言（表达式为false）时提示该信息</code></li>
</ul>
<p>由于基于VS计算的字节大小和理论值有出入，下面程序基于64位Linux进行测试，使用静态断言验证当前操作系统是否是32位：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// assert.cpp</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span>                                         </span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
  
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 字体原因看起来是一个=, 其实这是两个=</span>
    <span class="token keyword">static_assert</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">"错误, 不是32位平台..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"64bit Linux 指针大小: "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"64bit Linux long 大小: "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
  
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>通过g++编译程序：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ g++ assert.cpp <span class="token parameter variable">-std</span><span class="token operator">=</span>c++11
assert.cpp: In <span class="token keyword">function</span> ‘int main<span class="token punctuation">(</span><span class="token punctuation">)</span>’:
assert.cpp:6:5: error: static assertion failed: 错误, 不是32位平台<span class="token punctuation">..</span>.
static_assert<span class="token punctuation">(</span>sizeof<span class="token punctuation">(</span>long<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">4</span>, <span class="token string">"错误, 不是32位平台..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>由于使用的Linux是64位的，因此在编译阶段静态断言检测条件失败，提示的错误信息就是我们给静态断言指定的第二个参数对应的那个字符串。</p>
<blockquote>
<p><strong>注意事项：</strong></p>
<p>由于静态断言的表达式是在编译阶段进行检测，所以在它的表达式中不能出现变量，也就是说这个表达式必须是常量表达式。</p>
</blockquote>
<h3 id="22-3-不同系统间数据类型对比"><a href="#22-3-不同系统间数据类型对比" class="headerlink" title="22.3 不同系统间数据类型对比"></a>22.3 不同系统间数据类型对比</h3><table>
<thead>
<tr>
<th>数据类型</th>
<th>说明</th>
<th>32位字节数</th>
<th>64位字节数</th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td>bool</td>
<td>布尔型</td>
<td>1</td>
<td>1</td>
<td>true, false</td>
</tr>
<tr>
<td>char</td>
<td>字符型</td>
<td>1</td>
<td>1</td>
<td>-128 ~ 127</td>
</tr>
<tr>
<td>unsigned char</td>
<td>无符号字符型</td>
<td>1</td>
<td>1</td>
<td>0 ~ 255</td>
</tr>
<tr>
<td>short</td>
<td>短整型</td>
<td>2</td>
<td>2</td>
<td>-32768 ~ 32767</td>
</tr>
<tr>
<td>unsigned short</td>
<td>无符号短整型</td>
<td>2</td>
<td>2</td>
<td>0 ~ 65535</td>
</tr>
<tr>
<td>int</td>
<td>整型</td>
<td>4</td>
<td>4</td>
<td>-2147483648 ~ 2147483647</td>
</tr>
<tr>
<td>unsigned int</td>
<td>无符号整型</td>
<td>4</td>
<td>4</td>
<td>0 ~ 4294967295</td>
</tr>
<tr>
<td>long</td>
<td>长整型</td>
<td>4</td>
<td>8</td>
<td>-</td>
</tr>
<tr>
<td>unsigned long</td>
<td>无符号长整型</td>
<td>4</td>
<td>8</td>
<td>-</td>
</tr>
<tr>
<td>unsigned long long</td>
<td>无符号超长整型</td>
<td>至少8</td>
<td>至少8</td>
<td>8字节取值范围: 0 ~ 2^64</td>
</tr>
<tr>
<td>float</td>
<td>单精度浮点数</td>
<td>4</td>
<td>4</td>
<td>范围-2^128 ~ 2^128 精度为6~7位有效数字</td>
</tr>
<tr>
<td>double</td>
<td>双精度浮点数</td>
<td>8</td>
<td>8</td>
<td>范围-2^1024 ~ 2^1024 精度为15~16位</td>
</tr>
<tr>
<td>long double</td>
<td>扩展精度浮点数</td>
<td>8</td>
<td>8</td>
<td>范围-2^1024 ~ 2^1024 精度为15~16位</td>
</tr>
<tr>
<td>*</td>
<td>地址（指针）</td>
<td>4</td>
<td>8</td>
<td>-</td>
</tr>
</tbody></table>
<h2 id="23-noexcept"><a href="#23-noexcept" class="headerlink" title="23.noexcept"></a>23.noexcept</h2><h3 id="23-1-异常"><a href="#23-1-异常" class="headerlink" title="23.1 异常"></a>23.1 异常</h3><p>c++和其他很多编程语言一样，都有异常处理设计。<code>异常通常用于处理逻辑上可能发生的错误</code>，在C++98中为我们提供了一套完善的异常处理机制，我们可以直接在<code>程序中将各种类型的异常抛出，从而强制终止程序的运行。</code></p>
<p><strong>基本语法</strong></p>
<p>关于异常的基本语法如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/12/25/cpp11-xin-te-xing/image-20250302205207995.png" alt="image-20250302205207995"></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdexcept></span> <span class="token comment">// 包含标准异常类</span></span>

<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token comment">// 自定义除0异常类</span>
<span class="token keyword">class</span> <span class="token class-name">DivisionByZeroException</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">runtime_error</span></span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">DivisionByZeroException</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">runtime_error</span><span class="token punctuation">(</span><span class="token string">"Division by zero"</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> numerator<span class="token punctuation">,</span> denominator<span class="token punctuation">;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"输入分子: "</span><span class="token punctuation">;</span>
        cin <span class="token operator">>></span> numerator<span class="token punctuation">;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"输入分母: "</span><span class="token punctuation">;</span>
        cin <span class="token operator">>></span> denominator<span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>denominator <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">throw</span> <span class="token function">DivisionByZeroException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 抛出自定义异常</span>
        <span class="token punctuation">&#125;</span>

        <span class="token keyword">double</span> result <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>numerator<span class="token punctuation">)</span> <span class="token operator">/</span> denominator<span class="token punctuation">;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Result: "</span> <span class="token operator">&lt;&lt;</span> result <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token keyword">const</span> DivisionByZeroException<span class="token operator">&amp;</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        cerr <span class="token operator">&lt;&lt;</span> <span class="token string">"Error: "</span> <span class="token operator">&lt;&lt;</span> e<span class="token punctuation">.</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token keyword">const</span> invalid_argument<span class="token operator">&amp;</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        cerr <span class="token operator">&lt;&lt;</span> <span class="token string">"Invalid argument: "</span> <span class="token operator">&lt;&lt;</span> e<span class="token punctuation">.</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token keyword">const</span> exception<span class="token operator">&amp;</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        cerr <span class="token operator">&lt;&lt;</span> <span class="token string">"General error: "</span> <span class="token operator">&lt;&lt;</span> e<span class="token punctuation">.</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>异常被抛出后，从进入try块起，到异常被抛掷前，这期间在栈上构造的所有对象，都会被自动析构。析构的顺序与构造的顺序相反。这一过程称为<code>栈的解旋。</code></p>
</blockquote>
<p><strong>异常接口声明</strong></p>
<p>为了加强程序的可读性，可以在函数声明中列出可能抛出的所有异常类型，常用的有如下三种书写方式：</p>
<ol>
<li><code>显示指定可以抛出的异常类型</code>：在<code>throw()</code>中列举可能抛出的异常类型</li>
</ol>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">MyException</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">MyException</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">msg</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    string msg<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">double</span> <span class="token function">divisionMethod</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token keyword">throw</span><span class="token punctuation">(</span>MyException<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">throw</span> <span class="token function">MyException</span><span class="token punctuation">(</span><span class="token string">"division by zero!!!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// throw 100;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> a <span class="token operator">/</span> b<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">try</span>
    <span class="token punctuation">&#123;</span>	
        <span class="token keyword">double</span> v <span class="token operator">=</span> <span class="token function">divisionMethod</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"value: "</span> <span class="token operator">&lt;&lt;</span> v <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token keyword">int</span> e<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"catch except: "</span>  <span class="token operator">&lt;&lt;</span> e <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">catch</span> <span class="token punctuation">(</span>MyException e<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"catch except: "</span> <span class="token operator">&lt;&lt;</span> e<span class="token punctuation">.</span>msg <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>第7行代码在<code>divisionMethod</code>函数后添加了<code>throw异常接口声明</code>，其参数表示可以抛出的异常类型，分别为 <code>int</code> 和 <code>MyException</code> 类型。</p>
<ol start="2">
<li>抛出任意异常类型</li>
</ol>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">MyException</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">MyException</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">msg</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    string msg<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">double</span> <span class="token function">divisionMethod</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">throw</span> <span class="token function">MyException</span><span class="token punctuation">(</span><span class="token string">"division by zero!!!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// throw 100;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> a <span class="token operator">/</span> b<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>第7行代码在 <code>divisionMethod</code> 没有添加异常接口声明，表示在该函数中可以抛出任意类型的异常</p>
<ol start="3">
<li>不抛出任何异常</li>
</ol>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">MyException</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">MyException</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">msg</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    string msg<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">double</span> <span class="token function">divisionMethod</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token keyword">throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"division by zero!!!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> a <span class="token operator">/</span> b<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>第7行代码在 <code>divisionMethod</code> 函数后添加了<code>throw</code>异常接口声明，<code>其参数列表为空，表示该函数不允许抛出异常。</code></p>
<blockquote>
<p><code>温馨提示：以上程序在VS上的测试结果和在Linux上基于G++的测试结果是不同的，如果违反了规则VS只会给出警告，而G++则会直接终止程序的运行。（PS：VS使用的不是G++编译器）</code></p>
</blockquote>
<h3 id="23-2-noexcept"><a href="#23-2-noexcept" class="headerlink" title="23.2 noexcept"></a>23.2 noexcept</h3><p>上面的例子中，在 <code>divisionMethod</code> 函数声明之后，我们定义了一个动态异常声明 <code>throw(MyException, int)</code>，该声明指出了<code>divisionMethod</code>可能抛出的异常的类型。事实上，该特性很少被使用，因此在C++11中被弃用了 ，而表示函数不会抛出异常的动态异常声明 <code>throw()</code> 也被新的 <code>noexcept</code> 异常声明所取代。 </p>
<p>noexcept 形如其名，表示其修饰的函数不会抛出异常 。不过与 <code>throw()</code> 动态异常声明不同的是，<code>在 C++11 中如果 noexcept 修饰的函数抛出了异常，编译器可以选择直接调用 std::terminate() 函数来终止程序的运行，这比基于异常机制的 throw() 在效率上会高一些</code>。这是因为异常机制会带来一些额外开销，比如函数抛出异常，会导致函数栈被依次地展开（栈解旋），并自动调用析构函数释放栈上的所有对象。</p>
<p>因此对于不会抛出异常的函数我们可以这样写:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">double</span> <span class="token function">divisionMethod</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token keyword">noexcept</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"division by zero!!!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> a <span class="token operator">/</span> b<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>从语法上讲，<code>noexcept</code> 修饰符有两种形式：</p>
<ul>
<li><p>简单地在函数声明后加上 noexcept 关键字</p>
</li>
<li><p>可以接受一个常量表达式作为参数，如下所示∶</p>
</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">double</span> <span class="token function">divisionMethod</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">(</span>常量表达式<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>常量表达式的结果会被转换成一个bool类型的值：<ul>
<li>值为 true，表示函数不会抛出异常</li>
<li>值为 false，表示有可能抛出异常这里</li>
<li>不带常量表达式的noexcept相当于声明了<code>noexcept（true）</code>，即不会抛出异常。</li>
</ul>
</li>
</ul>
<h2 id="24-POD类型"><a href="#24-POD类型" class="headerlink" title="24.POD类型"></a>24.POD类型</h2><p>要理解什么是<code>POD</code>，推荐以下链接</p>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/cpp/trivial-standard-layout-and-pod-types?view=msvc-170">普通、标准布局、POD 和文本类型 | Microsoft Learn</a></p>
<h3 id="24-1-POD类型"><a href="#24-1-POD类型" class="headerlink" title="24.1 POD类型"></a>24.1 POD类型</h3><p>POD是英文中 <code>Plain Old Data</code> 的缩写，翻译过来就是<code>普通的旧数据</code>。POD在C++中是非常重要的一个概念，通常用于说明一个类型的属性，<code>尤其是用户自定义类型的属性。</code></p>
<p>POD属性在 C++11 中往往又是构建其他 C++ 概念的基础，事实上，在 C++11 标准中，POD出现的概率相当高。因此学习C++，尤其是在 C++11中，了解POD的概念是非常必要的。</p>
<ul>
<li>Plain ：表示是个普通的类型</li>
<li>Old ：体现了其与C的兼容性，支持标准C函数</li>
</ul>
<p>在C++11中将POD划分为两个基本概念的合集，即∶<code>平凡的（trivial）</code> 和标准布局的<code>（standard layout）</code>。 </p>
<h3 id="24-2-“平凡”类型"><a href="#24-2-“平凡”类型" class="headerlink" title="24.2 “平凡”类型"></a>24.2 “平凡”类型</h3><p>一个平凡的类或者结构体应该符合以下几点要求：</p>
<ol>
<li>拥有平凡的<code>默认构造函数（trivial constructor）和析构函数（trivial destructor）</code>。</li>
</ol>
<p>通常情况下，<code>不定义类的构造函数</code>，编译器就会为我们生成一个<code>平凡的默认构造函数</code>。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 使用默认的构造函数</span>
<span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><code>一旦定义了构造函数</code>，即使构造函数不包含参数，函数体里也没有任何的代码，<code>那么该构造函数也不再是&quot;平凡&quot;的</code>。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Test1</span> 
<span class="token punctuation">&#123;</span>
    <span class="token function">Test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 自定义的构造函数, 非默认构造</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>关于析构函数也和上面列举的构造函数类似，一旦被定义就不平凡了。但是这也并非无药可救，使用**<code>=default</code>**关键字可以显式地声明默认的构造函数，从而使得类型恢复“平凡化”。</p>
<ol start="2">
<li><p>拥有平凡的<code>拷贝构造函数（trivial copy constructor）</code>和<code>移动构造函数（trivial move constructor）</code>。</p>
<ul>
<li><p>平凡的拷贝构造函数基本上等同于使用 <code>memcpy</code> 进行类型的构造。</p>
</li>
<li><p>同平凡的默认构造函数一样，不声明拷贝构造函数的话，编译器会帮程序员自动地生成。</p>
</li>
<li><p>可以显式地使用 <code>=default</code> 声明默认拷贝构造函数。 </p>
</li>
<li><p>而平凡移动构造函数跟平凡的拷贝构造函数类似，只不过是用于移动语义。</p>
</li>
</ul>
</li>
<li><p>拥有平凡的<code>拷贝赋值运算符（trivial assignment operator）</code>和<code>移动赋值运算符（trivial move operator）</code>。</p>
</li>
<li><p><code>不包含虚函数以及虚基类。</code></p>
</li>
</ol>
<ul>
<li>类中使用 <code>virtual</code> 关键字修饰的函数叫做<strong>虚函数</strong></li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span> 
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>虚基类是在<code>创建子类的时候在继承的基类</code>前加 <code>virtual</code> 关键字修饰</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span> 
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token comment">// 子类Child，虚基类：Base</span>
<span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">virtual</span> <span class="token keyword">public</span> <span class="token class-name">Base</span></span> 
<span class="token punctuation">&#123;</span>
    <span class="token function">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="24-3-标准布局类型"><a href="#24-3-标准布局类型" class="headerlink" title="24.3 标准布局类型"></a>24.3 标准布局类型</h3><p>标准布局类型主要主要指的是<code>类</code>或者<code>结构体</code>的结构或者组合方式。</p>
<p>标准布局类型的类应该符合以下五点定义，<code>最重要的为前两条</code>：</p>
<ol>
<li>所有非静态成员有相同 的访问权限<code>（public，private，protected）</code>。</li>
</ol>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    <span class="token keyword">int</span> a<span class="token punctuation">;</span>
    <span class="token keyword">int</span> b<span class="token punctuation">;</span>
    <span class="token keyword">int</span> c<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ol start="2">
<li>在类或者结构体继承时，满足以下两种情况之一∶ <ul>
<li><code>派生类中有非静态成员，基类中包含静态成员（或基类没有变量）。</code></li>
<li><code>基类有非静态成员，而派生类没有非静态成员。</code></li>
</ul>
</li>
</ol>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Base</span> <span class="token punctuation">&#123;</span> <span class="token keyword">static</span> <span class="token keyword">int</span> a<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">Child</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span><span class="token punctuation">&#123;</span> <span class="token keyword">int</span> b<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>          <span class="token comment">// ok</span>
<span class="token keyword">struct</span> <span class="token class-name">Base1</span> <span class="token punctuation">&#123;</span> <span class="token keyword">int</span> a<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">Child1</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base1</span></span><span class="token punctuation">&#123;</span> <span class="token keyword">static</span> <span class="token keyword">int</span> c<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// ok</span>
<span class="token keyword">struct</span> <span class="token class-name">Child2</span><span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span><span class="token punctuation">,</span> <span class="token keyword">public</span> <span class="token class-name">Base1</span></span> <span class="token punctuation">&#123;</span> <span class="token keyword">static</span> <span class="token keyword">int</span> d<span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok</span>
<span class="token keyword">struct</span> <span class="token class-name">Child3</span><span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base1</span></span><span class="token punctuation">&#123;</span> <span class="token keyword">int</span> d<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>         <span class="token comment">// error</span>
<span class="token keyword">struct</span> <span class="token class-name">Child4</span><span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base1</span><span class="token punctuation">,</span> <span class="token keyword">public</span> <span class="token class-name">Child</span>     <span class="token comment">// error</span></span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> num<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<ol>
<li>非静态成员只要同时出现在派生类和基类间，即不属于标准布局。</li>
<li>对于多重继承，一旦非静态成员出现在多个基类中，即使派生类中没有非静态成员变量，派生类也不属于标准布局。</li>
</ol>
</blockquote>
<ol start="3">
<li><code>子类中第一个非静态成员的类型与其基类不同。 </code></li>
</ol>
<p>此处基于G++编译器讲解，如果使用VS的编译器和G++编译器得到的结果是不一样的。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Parent</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">Child</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Parent</span></span>
<span class="token punctuation">&#123;</span>
    Parent p<span class="token punctuation">;</span>	<span class="token comment">// 子类的第一个非静态成员</span>
    <span class="token keyword">int</span> foo<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面的例子中<code>Child</code>不是一个标准布局类型，因为它的第一个非静态成员变量p和父类的类型相同，改成下面这样子类就变成了一个标准布局类型：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Parent</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">Child1</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Parent</span></span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> foo<span class="token punctuation">;</span>   <span class="token comment">// 子类的第一个非静态成员</span>
    Parent p<span class="token punctuation">;</span>	
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这条规则对于我们来说是比较特别的，这样规定的目的主要是是节约内存，提高数据的读取效率。对于上面的两个子类<code>Child</code>和<code>Child1</code>来说它们的内存结构是不一样的，<code>在基类没有成员的情况下：</code>注意要求</p>
<ul>
<li>C++标准允许<code>标准布局类型（Child1）</code>派生类<code>的第一个成员foo与空基类共享地址</code>，此时基类并没有占据任何的实际空间（可以节省一点数据）</li>
<li>对于<code>子类Child</code>而言，如果子类的第一个成员仍然是基类类型，C++标准要求类型相同的对象它们的地址必须不同（<code>基类地址不能和子类中的变量 p 类型相同</code>）</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/12/25/cpp11-xin-te-xing/image-20211216174452356.png" alt="img"></p>
<ol start="4">
<li><code>没有虚函数和虚基类。 </code></li>
<li><code>所有非静态数据成员均符合标准布局类型，其基类也符合标准布局，这是一个递归的定义。</code></li>
</ol>
<h3 id="24-4-对-POD-类型的判断"><a href="#24-4-对-POD-类型的判断" class="headerlink" title="24.4 对 POD 类型的判断"></a>24.4 对 POD 类型的判断</h3><p>如果我们想要判断某个数据类型是不是属于 POD 类型，可以使用C++11给我们提供的相关函数：</p>
<p><strong>a. 对平凡类型判断</strong></p>
<p>C++11提供的类模板叫做 <code>is_trivial</code>，其定义如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span> <span class="token keyword">struct</span> <span class="token class-name">std</span><span class="token operator">:</span><span class="token base-clause"><span class="token operator">:</span><span class="token class-name">is_trivial</span></span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><code>std::is_trivial</code> 的成员 <code>value</code> 可以用于判断T的类型是否是一个平凡的类型（<code>value 函数返回值为布尔类型</code>）。除了类和结构体外，<code>is_trivial</code>还可以对内置的标准类型数据（比如int、float都属于平凡类型）及数组类型（元素是平凡类型的数组总是平凡的）进行判断。</p>
<p>关于类型的判断，示例程序如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;type_traits></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">&#123;</span> <span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token class-name">B</span></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">D</span> <span class="token punctuation">&#123;</span> <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">E</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">virtual</span> <span class="token keyword">public</span> <span class="token class-name">A</span></span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
<span class="token punctuation">&#123;</span>
    cout <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>boolalpha<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"is_trivial:"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"int: "</span> <span class="token operator">&lt;&lt;</span> is_trivial<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token double-colon punctuation">::</span>value <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"A: "</span> <span class="token operator">&lt;&lt;</span> is_trivial<span class="token operator">&lt;</span>A<span class="token operator">></span><span class="token double-colon punctuation">::</span>value <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"B: "</span> <span class="token operator">&lt;&lt;</span> is_trivial<span class="token operator">&lt;</span>B<span class="token operator">></span><span class="token double-colon punctuation">::</span>value <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"C: "</span> <span class="token operator">&lt;&lt;</span> is_trivial<span class="token operator">&lt;</span>C<span class="token operator">></span><span class="token double-colon punctuation">::</span>value <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"D: "</span> <span class="token operator">&lt;&lt;</span> is_trivial<span class="token operator">&lt;</span>D<span class="token operator">></span><span class="token double-colon punctuation">::</span>value <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"E: "</span> <span class="token operator">&lt;&lt;</span> is_trivial<span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token double-colon punctuation">::</span>value <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>输出的结果：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">is_trivial<span class="token operator">:</span>
<span class="token keyword">int</span><span class="token operator">:</span> <span class="token boolean">true</span>
A<span class="token operator">:</span> <span class="token boolean">true</span>
B<span class="token operator">:</span> <span class="token boolean">false</span>
C<span class="token operator">:</span> <span class="token boolean">false</span>
D<span class="token operator">:</span> <span class="token boolean">false</span>
E<span class="token operator">:</span> <span class="token boolean">false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>int ：内置标准数据类型，属于 trivial 类型</li>
<li>A ：拥有默认的构造和析构函数，属于 trivial 类型</li>
<li>B ：自定义了构造函数，因此不属于 trivial 类型</li>
<li>C ：基类中自定义了构造函数，因此不属于 trivial 类型</li>
<li>D ：类成员函数中有虚函数，因此不属于 trivial 类型</li>
<li>E ：继承关系中有虚基类，因此不属于 trivial 类型</li>
</ul>
<p><strong>b. 对标准布局类型的判断</strong></p>
<p>同样，在C++11中，我们可以使用模板类来帮助判断类型是否是一个标准布局的类型，其定义如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span> <span class="token keyword">struct</span> <span class="token class-name">std</span><span class="token operator">:</span><span class="token base-clause"><span class="token operator">:</span><span class="token class-name">is_standard_layout</span></span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>通过 <code>is_standard_layout</code> 模板类的成员 <code>value（is_standard_layout&lt;T&gt;∶∶value）</code>，我们可以在代码中打印出类型的标准布局属性，函数返回值为布尔类型。</p>
<p>关于类型的判断，示例程序如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// pod.cpp</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;type_traits></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">B</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token class-name">A</span></span> <span class="token punctuation">&#123;</span> <span class="token keyword">int</span> j<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">C</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> a<span class="token punctuation">;</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> c<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">D1</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">static</span> <span class="token keyword">int</span> i<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">D2</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> i<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">E1</span> <span class="token punctuation">&#123;</span> <span class="token keyword">static</span> <span class="token keyword">int</span> i<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">E2</span> <span class="token punctuation">&#123;</span> <span class="token keyword">int</span> i<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">D</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">D1</span><span class="token punctuation">,</span> <span class="token keyword">public</span> <span class="token class-name">E1</span></span> <span class="token punctuation">&#123;</span> <span class="token keyword">int</span> a<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">E</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">D1</span><span class="token punctuation">,</span> <span class="token keyword">public</span> <span class="token class-name">E2</span></span> <span class="token punctuation">&#123;</span> <span class="token keyword">int</span> a<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">F</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">D2</span><span class="token punctuation">,</span> <span class="token keyword">public</span> <span class="token class-name">E2</span></span> <span class="token punctuation">&#123;</span> <span class="token keyword">static</span> <span class="token keyword">int</span> a<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">G</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">A</span></span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> foo<span class="token punctuation">;</span>
    A a<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">H</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">A</span></span>
<span class="token punctuation">&#123;</span>
    A a<span class="token punctuation">;</span>
    <span class="token keyword">int</span> foo<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
<span class="token punctuation">&#123;</span>
    cout <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>boolalpha<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"is_standard_layout:"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"A: "</span> <span class="token operator">&lt;&lt;</span> is_standard_layout<span class="token operator">&lt;</span>A<span class="token operator">></span><span class="token double-colon punctuation">::</span>value <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"B: "</span> <span class="token operator">&lt;&lt;</span> is_standard_layout<span class="token operator">&lt;</span>B<span class="token operator">></span><span class="token double-colon punctuation">::</span>value <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"C: "</span> <span class="token operator">&lt;&lt;</span> is_standard_layout<span class="token operator">&lt;</span>C<span class="token operator">></span><span class="token double-colon punctuation">::</span>value <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"D: "</span> <span class="token operator">&lt;&lt;</span> is_standard_layout<span class="token operator">&lt;</span>D<span class="token operator">></span><span class="token double-colon punctuation">::</span>value <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"D1: "</span> <span class="token operator">&lt;&lt;</span> is_standard_layout<span class="token operator">&lt;</span>D1<span class="token operator">></span><span class="token double-colon punctuation">::</span>value <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"E: "</span> <span class="token operator">&lt;&lt;</span> is_standard_layout<span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token double-colon punctuation">::</span>value <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"F: "</span> <span class="token operator">&lt;&lt;</span> is_standard_layout<span class="token operator">&lt;</span>F<span class="token operator">></span><span class="token double-colon punctuation">::</span>value <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"G: "</span> <span class="token operator">&lt;&lt;</span> is_standard_layout<span class="token operator">&lt;</span>G<span class="token operator">></span><span class="token double-colon punctuation">::</span>value <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"H: "</span> <span class="token operator">&lt;&lt;</span> is_standard_layout<span class="token operator">&lt;</span>H<span class="token operator">></span><span class="token double-colon punctuation">::</span>value <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>VS2019输出的结果：</strong></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">is_standard_layout<span class="token operator">:</span>
A<span class="token operator">:</span> <span class="token boolean">true</span>
B<span class="token operator">:</span> <span class="token boolean">true</span>
C<span class="token operator">:</span> <span class="token boolean">false</span>
D<span class="token operator">:</span> <span class="token boolean">true</span>
D1<span class="token operator">:</span> <span class="token boolean">true</span>
E<span class="token operator">:</span> <span class="token boolean">false</span>
F<span class="token operator">:</span> <span class="token boolean">false</span>
G<span class="token operator">:</span> <span class="token boolean">false</span>
H<span class="token operator">:</span> <span class="token boolean">false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>G++ 编译输出的结果:</strong></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">is_standard_layout<span class="token operator">:</span>
A<span class="token operator">:</span> <span class="token boolean">true</span>
B<span class="token operator">:</span> <span class="token boolean">true</span>
C<span class="token operator">:</span> <span class="token boolean">false</span>
D<span class="token operator">:</span> <span class="token boolean">true</span>
D1<span class="token operator">:</span> <span class="token boolean">true</span>
E<span class="token operator">:</span> <span class="token boolean">false</span>
F<span class="token operator">:</span> <span class="token boolean">false</span>
G<span class="token operator">:</span> <span class="token boolean">true</span>
H<span class="token operator">:</span> <span class="token boolean">false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>关于输出的结果</strong></p>
<ul>
<li>A ：没有虚基类和虚函数，属于 standard_layout 类型</li>
<li>B ：没有虚基类和虚函数，属于 standard_layout 类型</li>
<li>C ：所有非静态成员访问权限不一致，不属于 standard_layout 类型</li>
<li>D ：基类和子类没有同时出现非静态成员变量，属于 standard_layout 类型</li>
<li>D1 ：没有虚基类和虚函数，属于 standard_layout 类型</li>
<li>E ：基类和子类中同时出现了非静态成员变量，不属于 standard_layout 类型</li>
<li>F ：多重继承中在基类里同时出现了非静态成员变量，不属于 standard_layout 类型</li>
<li>G ：使用的编译器不同，得到的结果也不同。</li>
<li>H ：子类中第一个非静态成员的类型与其基类类型不能相同，不属于 standard_layout 类型</li>
</ul>
<h3 id="24-5-总结"><a href="#24-5-总结" class="headerlink" title="24.5 总结"></a>24.5 总结</h3><p><code>POD类型的数据能够预测到其内存布局</code></p>
<p><code>使用POD类型有如下好处：</code></p>
<ul>
<li>字节赋值，代码中我们可以安全地使用 <code>memset()</code> 和 <code>memcpy()</code> 对 POD类型进行初始化和拷贝等操作。 010101直接复制过来就能使用</li>
<li>提供对C内存布局兼容。C++程序可以与 C函数进行相互操作，因为POD类型的数据在C与C++间的操作总是安全的。 </li>
<li>保证了静态初始化的安全有效。静态初始化在很多时候能够提高程序的性能，而POD类型的对象初始化往往更加简单。</li>
</ul>
<h2 id="25-显式默认设置的函数和已删除的函数"><a href="#25-显式默认设置的函数和已删除的函数" class="headerlink" title="25.显式默认设置的函数和已删除的函数"></a>25.显式默认设置的函数和已删除的函数</h2><p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/cpp/explicitly-defaulted-and-deleted-functions?view=msvc-170">显式默认设置的函数和已删除的函数 | Microsoft Learn</a></p>
<h3 id="25-1-类与默认函数"><a href="#25-1-类与默认函数" class="headerlink" title="25.1 类与默认函数"></a>25.1 类与默认函数</h3><p>在C++中声明自定义的类，编译器会默认帮助程序员生成一些他们未自定义的成员函数。这样的函数版本被称为<code>默认函数（特殊成员函数）</code>。这样的函数一共有六个，我们一起来看一下分别的名称和功能：</p>
<ul>
<li><code>无参构造函数</code>：创建类对象</li>
<li><code>拷贝构造函数</code>：拷贝类对象</li>
<li><code>移动构造函数</code>：拷贝类对象（转移资源）</li>
<li><code>拷贝赋值函数</code>：类对象赋值</li>
<li><code>移动赋值函数</code>：类对象赋值</li>
<li><code>析构函数</code> ：销毁类对象</li>
</ul>
<p><code>C++语法规则中，一旦程序员实现了这些函数的自定义版本，则编译器不会再为该类自动生成默认版本。</code></p>
<p>有时程序员会忘记上面提到的规则，最常见的是声明了带参数的构造，如果还需要无参构造函数，这时候必须定义出不带参数的版本。不过通过编译器的提示，这样的问题通常会得到更正。但更为严重的问题是，一旦声明了自定义版本的构造函数，则有可能导致我们定义的类型不再是POD类型，<code>我们便不再能够享受POD类型为我们带来的便利。</code></p>
<p>对于上面提到的这些，我们无需过度担心，因为C++11非常贴心地为我们提供了解决方案，就是使用<code>=default</code> 。</p>
<h3 id="25-2-default"><a href="#25-2-default" class="headerlink" title="25.2 &#x3D;default"></a>25.2 &#x3D;default</h3><p>可以默认设置任何特殊成员函数 — 以显式声明特殊成员函数使用<code>默认实现</code>、定义具有非公共访问限定符的特殊成员函数或恢复其他情况下被阻止其自动生成的特殊成员函数。通俗点来讲就是让编译器将特殊成员函数恢复默认实现。</p>
<p><code>使用 =defaut 指定的默认函数和类提供的默认函数是等价的</code></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">widget</span>
<span class="token punctuation">&#123;</span>
  <span class="token function">widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token keyword">default</span><span class="token punctuation">;</span>

  <span class="token keyword">inline</span> widget<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> widget<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">inline</span> widget<span class="token operator">&amp;</span> widget<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> widget<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token keyword">default</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>既可以在内部使用=default，也可以在外部指定</code></p>
<h3 id="25-3-delete"><a href="#25-3-delete" class="headerlink" title="25.3 &#x3D;delete"></a>25.3 &#x3D;delete</h3><p><code>=delete</code> 表示显示删除，<code>显式删除可以避免用户使用一些不应该使用的类的成员函数</code>，使用这种方式可以有效的防止某些类型之间自动进行隐式类型转换产生的错误。可以删除特殊成员函数和普通成员函数以及非成员函数，以阻止定义或调用它们。 通过删除特殊成员函数，可以更简洁地阻止编译器生成不需要的特殊成员函数。 必须在声明函数时将其删除；</p>
<p><strong>禁止使用默认生成的函数</strong></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">const</span> Base<span class="token operator">&amp;</span> obj<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>
    Base<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Base<span class="token operator">&amp;</span> obj<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Base b<span class="token punctuation">;</span>
    Base <span class="token function">tmp1</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// error 不允许使用默认的拷贝构造</span>
    Base tmp <span class="token operator">=</span> b<span class="token punctuation">;</span>    <span class="token comment">// error 不允许使用默认的拷贝赋值</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>禁止使用自定义函数</strong></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">m_num</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">char</span> c<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">char</span> c<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"num: "</span> <span class="token operator">&lt;&lt;</span> m_num <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"num: "</span> <span class="token operator">&lt;&lt;</span> num <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> m_num<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Base <span class="token function">b</span><span class="token punctuation">(</span><span class="token number">97</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 'a' 对应的 acscii 值为97</span>
    Base <span class="token function">b1</span><span class="token punctuation">(</span><span class="token char">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// error</span>
    b<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    b<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token number">97</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    b<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token char">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// error</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>第5行：禁用带 char类型参数的构造函数，<code>防止隐式类型转换（char转int)</code></li>
<li>第6行：禁止使用带char类型的自定义函数，<code>防止隐式类型转换（char转int)</code></li>
<li>第22行：对应的构造函数被禁用，因此无法使用该构造函数构造对象</li>
<li>第25行：对应的打印函数被禁用，因此无法给函数传递char类型参数</li>
</ul>
<h2 id="26-拓展的friend语法"><a href="#26-拓展的friend语法" class="headerlink" title="26.拓展的friend语法"></a>26.拓展的friend语法</h2><p><code>friend关键字</code>在C++中是一个比较特别的存在。因为在大多数编程语言中是没有提供<code>friend</code>关键字的，比如Java。friend关键字用于声明类的友元，友元可以无视类中成员的属性（ public、protected 或是 private ），友元类或友元函数都可以访问，这就<code>完全破坏了面向对象编程中封装性的概念。</code>但有的时候，friend关键字确实会让程序猿少写很多代码，因此 friend 还是在很多程序中被使用到。</p>
<h3 id="26-1-语法改进"><a href="#26-1-语法改进" class="headerlink" title="26.1 语法改进"></a>26.1 语法改进</h3><p>在 C++11 标准中对 friend关键字进行了一些改进，以保证其更加好用：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token comment">// 类声明</span>
<span class="token keyword">class</span> <span class="token class-name">Tom</span><span class="token punctuation">;</span>
<span class="token comment">// 定义别名</span>
<span class="token keyword">using</span> Honey <span class="token operator">=</span> Tom<span class="token punctuation">;</span>

<span class="token comment">// 定义两个测试类</span>
<span class="token keyword">class</span> <span class="token class-name">Jack</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 声明友元</span>
    <span class="token comment">// friend class Tom;    // C++98 标准语法</span>
    <span class="token keyword">friend</span> Tom<span class="token punctuation">;</span>             <span class="token comment">// C++11 标准语法 </span>
    string name <span class="token operator">=</span> <span class="token string">"jack"</span><span class="token punctuation">;</span>   <span class="token comment">// 默认私有</span>
    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment">// 默认私有</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"my name is "</span> <span class="token operator">&lt;&lt;</span> name <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Lucy</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
    <span class="token comment">// 声明友元</span>
    <span class="token comment">// friend class Tom;    // C++98 标准语法</span>
    <span class="token keyword">friend</span> Honey<span class="token punctuation">;</span>           <span class="token comment">// C++11 标准语法 </span>
    string name <span class="token operator">=</span> <span class="token string">"lucy"</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"my name is "</span> <span class="token operator">&lt;&lt;</span> name <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Tom</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token comment">// 通过类成员对象访问其私有成员</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"invoke Jack private member: "</span> <span class="token operator">&lt;&lt;</span> jObj<span class="token punctuation">.</span>name <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"invoke Jack private function: "</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
        jObj<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"invoke Lucy private member: "</span> <span class="token operator">&lt;&lt;</span> lObj<span class="token punctuation">.</span>name <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"invoke Lucy private function: "</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
        lObj<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    string name <span class="token operator">=</span> <span class="token string">"tom"</span><span class="token punctuation">;</span>
    Jack jObj<span class="token punctuation">;</span>
    Lucy lObj<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Tom t<span class="token punctuation">;</span>
    t<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上面的例子中<code>Tom类</code>分别作为了<code>Jack类和Lucy类的友元类</code>，然后在Tom类中定义了Jack类和Lucy类的对象<code>jObj</code>和<code>lObj</code>，这样我们就可以在Tom类中通过这两个类对象直接访问它们各自的私有或者受保护的成员变量或者成员函数了。</p>
<h3 id="26-2-为类模板声明友元"><a href="#26-2-为类模板声明友元" class="headerlink" title="26.2 为类模板声明友元"></a>26.2 为类模板声明友元</h3><p>虽然在C++11标准中对友元的改进不大，却会带来应用的变化 ——&gt; 程序员可以为<code>类模板声明友元</code>了，这在C++98中是无法做到的。使用方法如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Tom</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>  
<span class="token keyword">class</span> <span class="token class-name">Person</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">friend</span> T<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Person<span class="token operator">&lt;</span>Tom<span class="token operator">></span> p<span class="token punctuation">;</span>
    Person<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> pp<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>第11行：Tom类是Person类的友元</li>
<li>第12行：<code>对于int类型的模板参数，友元声明被忽略（第6行）</code></li>
</ul>
<h2 id="27-枚举类型"><a href="#27-枚举类型" class="headerlink" title="27.枚举类型"></a>27.枚举类型</h2><h3 id="27-1-枚举"><a href="#27-1-枚举" class="headerlink" title="27.1 枚举"></a>27.1 枚举</h3><p><strong>枚举的基本使用</strong></p>
<p>枚举类型是C及C++中一个基本的内置类型，不过也是一个有点<code>奇怪</code>的类型。从枚举的本意上来讲，就是要定义一个类别，并穷举同一类别下的个体以供代码中使用。由于枚举来源于C，所以出于设计上的简单的目的，枚举值常常是对应到整型数值的一些名字，比如：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 匿名枚举</span>
<span class="token keyword">enum</span> <span class="token punctuation">&#123;</span>Red<span class="token punctuation">,</span> Green<span class="token punctuation">,</span> Blue<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token comment">// 有名枚举</span>
<span class="token keyword">enum</span> <span class="token class-name">Colors</span><span class="token punctuation">&#123;</span>Red<span class="token punctuation">,</span> Green<span class="token punctuation">,</span> Blue<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>在枚举类型中的枚举值编译器会默认从0开始赋值，而后依次向下递增，也就是说<code>Red=0，Green=1，Blue=2</code>。</p>
<p><strong>枚举的缺陷</strong></p>
<p>C&#x2F;C++的enum有个很奇怪的设定，就是具名（有名字）的enum类型的名字，以及 enum 的成员的名字都是全局可见的。这与 C++中具名的 namespace、class&#x2F;struct 及 union 必须通过<code>名字::成员名的</code>方式访问相比是格格不入的，编码过程中一不小心程序员就容易遇到问题。比如∶</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">enum</span> <span class="token class-name">China</span> <span class="token punctuation">&#123;</span>Shanghai<span class="token punctuation">,</span> Dongjing<span class="token punctuation">,</span> Beijing<span class="token punctuation">,</span> Nanjing<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">enum</span> <span class="token class-name">Japan</span> <span class="token punctuation">&#123;</span>Dongjing<span class="token punctuation">,</span> Daban<span class="token punctuation">,</span> Hengbin<span class="token punctuation">,</span> Fudao<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>上面定义的两个枚举在编译的时候，编译器会报错，具体信息如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">error C2365<span class="token operator">:</span> “Dongjing”<span class="token operator">:</span> 重定义；以前的定义是“枚举数”<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>错误的原因上面也提到了，在这两个具名的枚举中<code>Dongjing是全局可见的，所有编译器就会提示其重定义了</code>。</p>
<p>另外，由于C中枚举被设计为常量数值的”别名”的本性，所以<code>枚举的成员总是可以被隐式地转换为整型</code>，但是很多时候我们并不想这样。</p>
<h3 id="27-2-强枚举类型"><a href="#27-2-强枚举类型" class="headerlink" title="27.2 强枚举类型"></a>27.2 强枚举类型</h3><p>针对枚举的缺陷，C++11标准引入了一种新的枚举类型，即枚举类，又称<code>强类型枚举（strong-typed enum）</code>。 声明强类型枚举非常简单，只需要在 enum 后加上关键字 class。比如∶</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 定义强类型枚举</span>
<span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">Colors</span><span class="token punctuation">&#123;</span>Red<span class="token punctuation">,</span> Green<span class="token punctuation">,</span> Blue<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>强类型枚举具有以下几点优势∶ </p>
<ul>
<li>强作用域，强类型枚举成员的名称不会被输出到其父作用域空间。<ul>
<li>强类型枚举只能是有名枚举，如果是匿名枚举会导致枚举值无法使用（因为没有作用域名称）。</li>
</ul>
</li>
<li>转换限制，强类型枚举成员的值不可以与整型隐式地相互转换。 </li>
<li>可以指定底层类型。<code>强类型枚举默认的底层类型为 int</code>，但也可以显式地指定底层类型， 具体方法为在枚举名称后面加上<code>∶type</code>，其中 type 可以是除 <code>wchar_t</code> 以外的<code>任何整型</code>。</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">Food</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">char</span></span>
<span class="token punctuation">&#123;</span>
    Apple<span class="token punctuation">,</span>
    Banana<span class="token punctuation">,</span>
    Pear
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p><code>wchar_t 是什么?</code></p>
<p>双字节类型，或宽字符类型，是C&#x2F;C++的一种扩展的存储方式，一般为16位或32位，所能表示的字符数远超char型。<br>主要用在国际化程序的实现中，但它不等同于 unicode 编码。unicode 编码的字符一般以wchar_t类型存储。</p>
</blockquote>
<p>了解了强类型枚举的优势之后，我们再看一段程序：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">China</span> <span class="token punctuation">&#123;</span> Shanghai<span class="token punctuation">,</span> Dongjing<span class="token punctuation">,</span> Beijing<span class="token punctuation">,</span> Nanjing<span class="token punctuation">,</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">Japan</span><span class="token operator">:</span><span class="token base-clause"><span class="token keyword">char</span></span> <span class="token punctuation">&#123;</span> Dongjing<span class="token punctuation">,</span> Daban<span class="token punctuation">,</span> Hengbin<span class="token punctuation">,</span> Fudao <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> m <span class="token operator">=</span> Shanghai<span class="token punctuation">;</span>           <span class="token comment">// error</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> China<span class="token double-colon punctuation">::</span>Shanghai<span class="token punctuation">;</span>    <span class="token comment">// error</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>China<span class="token double-colon punctuation">::</span>Beijing <span class="token operator">>=</span> <span class="token number">2</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
    	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ok!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"size1: "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>China<span class="token double-colon punctuation">::</span>Dongjing<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"size2: "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>Japan<span class="token double-colon punctuation">::</span>Dongjing<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>第5行：该行的代码有两处错误<ul>
<li>强类型枚举属于<code>强作用域类型</code>，不能直接使用，枚举值前必须加枚举类型</li>
<li><code>强类型枚举不会进行隐式类型转换</code>，因此枚举值不能直接给int行变量赋值（虽然强类型枚举的枚举值默认就是整形，但其不能作为整形使用）。</li>
</ul>
</li>
<li>第6行：语法错误，将强类型枚举值作为整形使用，此处不会进行隐式类型转换</li>
<li>第7行：语法正确，<code>强类型枚举值在和整数比较之前做了强制类型转换</code>。</li>
<li>第11行：打印的结果为4，强类型枚举底层类型值默认为<code>int</code>，因此占用的内存是<code>4个字节</code></li>
<li>第12行：打印的结果为1，显示指定了强类型枚举值的类型为<code>char</code>，因此占用的内存大小为<code>1个字节</code>，这样我们就可以节省更多的内存空间了。</li>
</ul>
<p><strong>对原有枚举类型的优化</strong></p>
<p>相比于原来的枚举，强类型枚举更像是一个属于C++的枚举。但为了配合新的枚举类型，C++11还对原有枚举类型进行了扩展：</p>
<ul>
<li>原有枚举类型的底层类型在默认情况下，仍然由编译器来具体指定实现。<code>但也可以跟强类型枚举类一样，显式地由程序员来指定。其指定的方式跟强类型枚举一样，都是枚举名称后面加上∶type，其中type 可以是除 wchar_t 以外的任何整型。</code></li>
<li>关于作用域，在C++11中，枚举成员的名字除了会自动输出到父作用域，也可以在枚举类型定义的作用域内有效。比如：</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">enum</span> <span class="token class-name">Colors</span> <span class="token operator">:</span> <span class="token keyword">char</span> <span class="token punctuation">&#123;</span> Red<span class="token punctuation">,</span> Green<span class="token punctuation">,</span> Blue <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Colors c1 <span class="token operator">=</span> Green<span class="token punctuation">;</span>          <span class="token comment">// C++11以前的用法</span>
    Colors c2 <span class="token operator">=</span> Colors<span class="token double-colon punctuation">::</span>Green<span class="token punctuation">;</span>  <span class="token comment">// C++11的扩展语法</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>C++11中对原有枚举类型的这两个扩展都保留了<code>向后兼容性</code>，也方便了程序员在代码中同时操作两种枚举类型。此外，我们在声明强类型枚举的时候，也可以使用关键字<code>enum struct</code>。实际上 <code>enum struct</code> 和 <code>enum class</code> 在语法上没有任何区别（enum class 的成员没有公有私有之分，也不会使用模板来支持泛化的声明 ）。</p>
<h2 id="28-非受限联合体"><a href="#28-非受限联合体" class="headerlink" title="28.非受限联合体"></a>28.非受限联合体</h2><p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/cpp/unions?view=msvc-170">union | Microsoft Learn</a></p>
<h3 id="28-1-联合体"><a href="#28-1-联合体" class="headerlink" title="28.1 联合体"></a>28.1 联合体</h3><p>联合体又叫共用体，我将其称之为<code>union</code>，它的使用方式和结构体类似，程序猿可以在联合体内部定义多种不同类型的数据成员，但是这些数据会共享同一块内存空间（<code>也就是如果对多个数据成员同时赋值会发生数据的覆盖</code>）。在某些特定的场景下，通过这种特殊的数据结构我们就可以实现内存的复用，从而达到节省内存空间的目的。</p>
<p><code>union 排列在内存中（从概念上讲）</code>，如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/12/25/cpp11-xin-te-xing/vc38ul1.png" alt="显示 NumericType union 中数据的重叠存储的关系图。"></p>
<p>在C++11之前我们使用的联合体是有局限性的，主要有以下三点：</p>
<ul>
<li>不允许联合体拥有<code>非POD类型</code>的成员</li>
<li>不允许联合体拥有静态成员</li>
<li>不允许联合体拥有引用类型的成员</li>
</ul>
<p>在新的C++11标准中，<code>取消了关于联合体对于数据成员类型的限定</code>，规定任何<code>非引用</code>类型都可以成为联合体的数据成员，这样的联合体称之为<code>非受限联合体（Unrestricted Union）</code></p>
<h3 id="28-2-非受限联合体"><a href="#28-2-非受限联合体" class="headerlink" title="28.2 非受限联合体"></a>28.2 非受限联合体</h3><p><strong>静态类型的成员</strong></p>
<p>对于非受限联合体来说，静态成员有两种分别是<code>静态成员变量</code>和<code>静态成员函数</code>，我们来看一下下面的代码：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">union</span> Test
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> age<span class="token punctuation">;</span>
    <span class="token keyword">long</span> id<span class="token punctuation">;</span>
    <span class="token comment">// int&amp; tmp = age; // error</span>
    <span class="token keyword">static</span> <span class="token keyword">char</span> c<span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"c value: "</span> <span class="token operator">&lt;&lt;</span> c <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> Test<span class="token double-colon punctuation">::</span>c<span class="token punctuation">;</span>
<span class="token comment">// char Test::c = 'a';</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Test t<span class="token punctuation">;</span>
    Test t1<span class="token punctuation">;</span>
    t<span class="token punctuation">.</span>c <span class="token operator">=</span> <span class="token char">'b'</span><span class="token punctuation">;</span>
    t1<span class="token punctuation">.</span>c <span class="token operator">=</span> <span class="token char">'c'</span><span class="token punctuation">;</span>
    t1<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">666</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"t.c: "</span> <span class="token operator">&lt;&lt;</span> t<span class="token punctuation">.</span>c <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"t1.c: "</span> <span class="token operator">&lt;&lt;</span> t1<span class="token punctuation">.</span>c <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"t1.age: "</span> <span class="token operator">&lt;&lt;</span> t1<span class="token punctuation">.</span>age <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"t1.id: "</span> <span class="token operator">&lt;&lt;</span> t1<span class="token punctuation">.</span>id <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    t<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Test</span><span class="token double-colon punctuation">::</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>第5行：语法错误，非受限联合体中不允许出现引用类型</li>
<li>第6行：非受限联合体中的静态成员变量<ul>
<li>需要在<code>非受限联合体外部声明（第13行）或者初始化（第14行）之后才能使用</code></li>
<li>通过打印的结果可以发现18、19行的<code>t</code>和<code>t1</code>对象共享这个静态成员变量。</li>
</ul>
</li>
<li>第7行：非受限联合体中的静态成员函数<ul>
<li>在静态函数print()只能<code>访问非受限联合体Test中的静态变量</code>，对于非静态成员变量（age、id）是无法访问的。</li>
<li>调用这个静态方法可以通过对象（第27行）也可以通过类名（第28行）实现。</li>
</ul>
</li>
<li>第24、25、26行：通过打印的结果可以得出结论在<code>非受限联合体中静态成员变量和非静态成员变量使用的不是同一块内存。</code></li>
</ul>
<p><strong>非POD类型成员</strong></p>
<p>在 C++11标准中会默认删除一些非受限联合体的默认函数。比如，非受限联合体有一个非 POD 的成员，而该非 POD成员类型拥有<code>非平凡的构造函数</code>，那么<code>非受限联合体的默认构造函数将被编译器删除</code>。其他的特殊成员函数，例如默认拷贝构造函数、拷贝赋值操作符以及析构函数等，也将遵从此规则。下面来举例说明：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">union</span> Student
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> id<span class="token punctuation">;</span>
    string name<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Student s<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>编译程序会看到如下的错误提示:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">warning C4624<span class="token operator">:</span> “Student”<span class="token operator">:</span> 已将析构函数隐式定义为“已删除”
error C2280<span class="token operator">:</span> “<span class="token class-name">Student</span><span class="token double-colon punctuation">::</span><span class="token function">Student</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>”<span class="token operator">:</span> 尝试引用已删除的函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>上面代码中的非受限联合体<code>Student</code>中拥有一个<code>非PDO类型</code>的成员<code>string name</code>，<code>string 类中有非平凡构造函数</code>，因此Student的构造函数被删除（通过警告信息可以得知它的析构函数也被删除了）导致对象无法被成功创建出来。解决这个问题的办法就是<code>由程序猿自己为非受限联合体定义构造函数</code>，在定义构造函数的时候我们需要用到<code>定位放置new操作</code>。</p>
<h3 id="28-3-placement-new"><a href="#28-3-placement-new" class="headerlink" title="28.3 placement new"></a>28.3 placement new</h3><p>一般情况下，使用new申请空间时，是从系统的<code>堆（heap）中分配空间</code>，申请所得的空间的位置是根据当时的内存的实际使用情况决定的。但是，在某些特殊情况下，可能需要在<code>已分配的特定内存创建对象</code>，这种操作就叫做<code>placement new 即定位放置 new</code>。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ClassName<span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token punctuation">(</span>定位的内存地址<span class="token punctuation">)</span>ClassName<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>我们看下面的示例程序：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Base</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    <span class="token operator">~</span><span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"number value: "</span> <span class="token operator">&lt;&lt;</span> number <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> number<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
    Base<span class="token operator">*</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>n<span class="token punctuation">)</span>Base<span class="token punctuation">;</span>
    b<span class="token operator">-></span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>程序运行输出的结果为:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">number value<span class="token operator">:</span> <span class="token number">100</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>在程序的第20行，<code>使用定位放置的方式为指针b申请了一块内存</code>，也就是说此时<code>指针 b 指向的内存地址和变量 n 对应的内存地址是同一块（栈内存）</code>，而在Base类中<code>成员变量number的起始地址和Base对象的起始地址是相同的</code>，所以打印出 number 的值为100也就是整形变量 n 的值。</p>
<p>最后，给大家总结一下关于placement new的一些细节：</p>
<ul>
<li>使用定位放置new操作，既可以在<code>栈(stack)</code>上生成对象，也可以在<code>堆（heap）</code>上生成对象，这取决于定位时指定的内存地址是在堆还是在栈上。</li>
<li>从表面上看，定位放置new操作是申请空间，其<code>本质是利用已经申请好的空间，真正的申请空间的工作是在此之前完成的</code>。</li>
<li>使用定位放置 new 创建对象时会自动调用对应类的构造函数，但是由于对象的空间不会自动释放，如果需要<code>释放堆内存必须显式调用类的析构函数</code>。</li>
<li>使用定位放置new操作，我们可以反复动态申请到同一块堆内存，这样可以避免内存的重复创建销毁，从而提高程序的执行效率（比如网络通信中数据的接收和发送）。</li>
</ul>
<p><strong>自定义非受限联合体构造函数</strong></p>
<p>掌握了<code>placement new</code>的使用，我们通过一段程序来演示一下如果在非受限联合体中自定义构造函数：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">setText</span><span class="token punctuation">(</span>string str<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        notes <span class="token operator">=</span> str<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Base notes: "</span> <span class="token operator">&lt;&lt;</span> notes <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    string notes<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">union</span> Student
<span class="token punctuation">&#123;</span>
    <span class="token function">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">new</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>name<span class="token punctuation">)</span>string<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token operator">~</span><span class="token function">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

    <span class="token keyword">int</span> id<span class="token punctuation">;</span>
    Base tmp<span class="token punctuation">;</span>
    string name<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Student s<span class="token punctuation">;</span>
    s<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"蒙奇·D·路飞"</span><span class="token punctuation">;</span>
    s<span class="token punctuation">.</span>tmp<span class="token punctuation">.</span><span class="token function">setText</span><span class="token punctuation">(</span><span class="token string">"我是要成为海贼王的男人!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    s<span class="token punctuation">.</span>tmp<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Student name: "</span> <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">.</span>name <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>程序打印的结果如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Base notes<span class="token operator">:</span> 我是要成为海贼王的男人<span class="token operator">!</span>
Student name<span class="token operator">:</span> 我是要成为海贼王的男人<span class="token operator">!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>我们在上面的程序里边给非受限制联合体<code>显示的指定了构造函数和析构函数</code>，在程序的第31行需要创建一个非受限联合体对象，这时便调用了联合体内部的构造函数，在构造函数的第20行通过定位放置new的方式将构造出的对象地址定位到了联合体的成员string name的地址上了<code>（但是构造出的是string对象，没看懂，可能是为了正确初始化非POD类型string？）</code>，这样联合体内部其他非静态成员也就可以访问这块地址了（通过输出的结果可以看到对联合体内的tmp对象赋值，会覆盖name对象中的数据）。</p>
<ul>
<li>由于<code>tmp</code>和<code>name</code>共享同一块内存，<code>tmp</code>的<code>notes</code>值覆盖了<code>name</code>的值。</li>
</ul>
<h3 id="28-4-匿名的非受限联合体"><a href="#28-4-匿名的非受限联合体" class="headerlink" title="28.4 匿名的非受限联合体"></a>28.4 匿名的非受限联合体</h3><p>一般情况下我们使用的非受限联合体都是具名的（有名字），但是我们也可以定义匿名的非受限联合体，一个比较实用的场景就是配合着类的定义使用。我们来设定一个场景：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">木叶村要进行第99次人口普查，人员的登记方式如下：
    - 学生只需要登记所在学校的编号
    - 本村学生以外的人员需要登记其身份证号码
    - 本村外来人员需要登记户口所在地 + 联系方式<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 外来人口信息</span>
<span class="token keyword">struct</span> <span class="token class-name">Foreigner</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">Foreigner</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> string ph<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">addr</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">phone</span><span class="token punctuation">(</span>ph<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    string addr<span class="token punctuation">;</span>
    string phone<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token comment">// 登记人口信息</span>
<span class="token keyword">class</span> <span class="token class-name">Person</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">Category</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">char</span></span> <span class="token punctuation">&#123;</span>Student<span class="token punctuation">,</span> Local<span class="token punctuation">,</span> Foreign<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">number</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">type</span><span class="token punctuation">(</span>Category<span class="token double-colon punctuation">::</span>Student<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    <span class="token function">Person</span><span class="token punctuation">(</span>string id<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">idNum</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">type</span><span class="token punctuation">(</span>Category<span class="token double-colon punctuation">::</span>Local<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    <span class="token function">Person</span><span class="token punctuation">(</span>string addr<span class="token punctuation">,</span> string phone<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">foreign</span><span class="token punctuation">(</span>addr<span class="token punctuation">,</span> phone<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">type</span><span class="token punctuation">(</span>Category<span class="token double-colon punctuation">::</span>Foreign<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    <span class="token operator">~</span><span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Person category: "</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>type <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
        <span class="token keyword">switch</span> <span class="token punctuation">(</span>type<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
        <span class="token keyword">case</span> Category<span class="token double-colon punctuation">::</span>Student<span class="token operator">:</span>
            cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Student school number: "</span> <span class="token operator">&lt;&lt;</span> number <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> Category<span class="token double-colon punctuation">::</span>Local<span class="token operator">:</span>
            cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Local people ID number: "</span> <span class="token operator">&lt;&lt;</span> idNum <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> Category<span class="token double-colon punctuation">::</span>Foreign<span class="token operator">:</span>
            cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Foreigner address: "</span> <span class="token operator">&lt;&lt;</span> foreign<span class="token punctuation">.</span>addr
                <span class="token operator">&lt;&lt;</span> <span class="token string">", phone: "</span> <span class="token operator">&lt;&lt;</span> foreign<span class="token punctuation">.</span>phone <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">default</span><span class="token operator">:</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    Category type<span class="token punctuation">;</span>
    <span class="token keyword">union</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> number<span class="token punctuation">;</span>
        string idNum<span class="token punctuation">;</span>
        Foreigner foreign<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Person <span class="token function">p1</span><span class="token punctuation">(</span><span class="token number">9527</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Person <span class="token function">p2</span><span class="token punctuation">(</span><span class="token string">"1101122022X"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Person <span class="token function">p3</span><span class="token punctuation">(</span><span class="token string">"砂隐村村北"</span><span class="token punctuation">,</span> <span class="token string">"1301810001"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    p1<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    p2<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    p3<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>程序输出的结果：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Person category<span class="token operator">:</span> <span class="token number">0</span>
Student school number<span class="token operator">:</span> <span class="token number">9527</span>
Person category<span class="token operator">:</span> <span class="token number">1</span>
Local people ID number<span class="token operator">:</span> <span class="token number">1101122022</span>X
Person category<span class="token operator">:</span> <span class="token number">2</span>
Foreigner address<span class="token operator">:</span> 砂隐村村北<span class="token punctuation">,</span> phone<span class="token operator">:</span> <span class="token number">1301810001</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>根据需求我们将木叶村的人口分为了三类并通过枚举记录了下来，在<code>Person</code>类中添加了一个匿名的非受限联合体用来存储人口信息，仔细分析之后就会发现这种处理方式的优势非常明显：<code>尽可能地节省了内存空间。</code></p>
<ul>
<li><code>Person类可以直接访问匿名非受限联合体内部的数据成员。</code></li>
<li>不使用匿名非受限联合体申请的内存空间等于 <code>number</code>、<code>idNum </code>、<code>foreign</code> 三者内存之和。</li>
<li>使用匿名非受限联合体之后<code>number</code>、<code>idNum</code>、<code>foreign</code>三者共用同一块内存。</li>
</ul>
<h2 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h2><p>宏（Macro）是 C 和 C++ 等编程语言中预处理器的一种功能，用于在编译之前对代码进行文本替换。宏可以用来定义常量、简化重复代码或者实现一些条件编译功能。宏通常使用 <code>#define</code> 指令来定义。</p>
<p>以下是一些宏的基本特点和使用方式：</p>
<ol>
<li><p><strong>常量宏</strong>：<br>常量宏可以用于定义一些常量值。例如：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PI</span> <span class="token expression"><span class="token number">3.14159</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这种定义可以在代码中随处使用 <code>PI</code>，编译器在编译时会将 <code>PI</code> 替换为 <code>3.14159</code>。</p>
</li>
<li><p><strong>函数宏</strong>：<br>函数宏可以接受参数并进行替换，起到类似函数的效果。例如：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SQUARE</span><span class="token expression"><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>使用时，如果你写 <code>SQUARE(5)</code>，编译器会将其替换为 <code>((5) * (5))</code>。</p>
</li>
<li><p><strong>条件编译</strong>：<br>宏还可以用于条件编译。通过 <code>#ifdef</code>、<code>#ifndef</code>、<code>#if</code> 等指令，可以根据条件编译不同的代码块。例如：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">DEBUG</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">LOG</span><span class="token expression"><span class="token punctuation">(</span>x<span class="token punctuation">)</span> cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">LOG</span><span class="token expression"><span class="token punctuation">(</span>x<span class="token punctuation">)</span> </span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里，只有在定义了 <code>DEBUG</code> 的情况下，<code>LOG(x)</code> 才会输出日志信息。</p>
</li>
<li><p><strong>优势和劣势</strong>：</p>
<ul>
<li>优势：宏可以减少代码重复，提高可维护性，支持条件编译等功能。</li>
<li>劣势：宏在替换时没有类型检查，可能导致代码难以调试。此外，过度使用宏会使代码不易阅读和理解。</li>
</ul>
</li>
</ol>
<h2 id="左值引用和右值引用"><a href="#左值引用和右值引用" class="headerlink" title="左值引用和右值引用"></a>左值引用和右值引用</h2><p>在C++中，<code>左值引用（lvalue reference）</code>和<code>右值引用（rvalue reference）</code>是两种不同的引用类型，用于处理不同类型的数据和场景。</p>
<h3 id="左值引用（lvalue-reference）"><a href="#左值引用（lvalue-reference）" class="headerlink" title="左值引用（lvalue reference）"></a>左值引用（lvalue reference）</h3><p><strong>定义</strong>：<br>左值引用是C++中传统的引用类型，用法是 <code>T&amp;</code>，其中 <code>T</code> 是被引用的类型。</p>
<p><strong>特点</strong>：</p>
<ol>
<li><strong>绑定左值</strong>：左值引用只能绑定到左值。左值是具有持久存储的表达式，可以出现在赋值操作符的左侧(可以取地址的变量)。</li>
<li><strong>修改性</strong>：除非引用本身被声明为 <code>const</code>，否则可以通过左值引用来修改被引用的对象。</li>
<li><strong>语法</strong>：使用 <code>&amp;</code> 符号声明。</li>
</ol>
<p><strong>示例</strong>：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span><span class="token operator">&amp;</span> ref_a <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment">// 左值引用绑定到左值 a</span>

    ref_a <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span> <span class="token comment">// 修改 a 的值</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"a: "</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 输出 20</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="右值引用（rvalue-reference）"><a href="#右值引用（rvalue-reference）" class="headerlink" title="右值引用（rvalue reference）"></a>右值引用（rvalue reference）</h3><p><strong>定义</strong>：<br>右值引用是C++11引入的一种新的引用类型，用法是 <code>T&amp;&amp;</code>，其中 <code>T</code> 是被引用的类型。</p>
<p><strong>特点</strong>：</p>
<ol>
<li><strong>绑定右值</strong>：右值引用可以绑定到右值。右值是<code>临时对象或字面量</code>，不能出现在赋值操作符的左侧。</li>
<li><strong>移动语义</strong>：右值引用的主要目的是实现移动语义，允许资源从一个对象转移到另一个对象，从而提高性能和减少不必要的复制。</li>
<li><strong>语法</strong>：使用 <code>&amp;&amp;</code> 符号声明。</li>
</ol>
<p><strong>示例</strong>：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;utility></span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> ref_a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">// 右值引用绑定到右值 10(字面量)</span>

    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ref_a: "</span> <span class="token operator">&lt;&lt;</span> ref_a <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 输出 10</span>

    <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
    <span class="token comment">// 下面的代码会报错，因为右值引用不能绑定到左值</span>
    <span class="token comment">// int&amp;&amp; ref_b = b;</span>

    <span class="token comment">// 使用 std::move 将左值转换为右值</span>
    <span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> ref_c <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ref_c: "</span> <span class="token operator">&lt;&lt;</span> ref_c <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 输出 20</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"b: "</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>         <span class="token comment">// 输出 20，但 b 的值可能被移动后变为未定义</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="区别总结"><a href="#区别总结" class="headerlink" title="区别总结"></a>区别总结</h3><table>
<thead>
<tr>
<th>特性</th>
<th>左值引用 (<code>T&amp;</code>)</th>
<th>右值引用 (<code>T&amp;&amp;</code>)</th>
</tr>
</thead>
<tbody><tr>
<td>绑定对象</td>
<td>左值（持久存储的表达式）</td>
<td>右值（临时对象或字面量）</td>
</tr>
<tr>
<td>语法</td>
<td><code>T&amp;</code></td>
<td><code>T&amp;&amp;</code></td>
</tr>
<tr>
<td>移动语义</td>
<td>不支持</td>
<td>支持，用于资源转移</td>
</tr>
<tr>
<td>修改性</td>
<td>可以修改（除非是 <code>const</code>）</td>
<td>可以修改（除非是 <code>const</code>）</td>
</tr>
<tr>
<td>示例</td>
<td><code>int&amp; ref_a = a;</code></td>
<td><code>int&amp;&amp; ref_b = 10;</code></td>
</tr>
</tbody></table>
<h3 id="进一步理解"><a href="#进一步理解" class="headerlink" title="进一步理解"></a>进一步理解</h3><ul>
<li><strong>左值</strong>：可以出现在赋值操作符左侧的表达式。例如，变量 <code>a</code> 是左值。</li>
<li><strong>右值</strong>：不能出现在赋值操作符左侧的表达式。例如，字面量 <code>10</code> 是右值。</li>
<li>**<code>std::move</code>**：这是一个标准库函数，用于将左值转换为右值引用，从而允许资源的移动。</li>
</ul>
<p>通过理解左值引用和右值引用，你可以更有效地利用C++11的特性来编写高性能的代码。</p>
<h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><ul>
<li><strong>进程</strong>：是指程序的一次执行过程，是操作系统进行资源分配的基本单位。每个进程都有独立的地址空间、内存、数据栈和其他辅助数据结构等资源</li>
<li><strong>线程</strong>：是进程内的一个执行单元，<code>是 CPU 调度和分派的基本单位</code>。<code>线程是比进程更小的能独立运行的基本单位</code>。一个进程可以包含一个或多个线程，这些线程共享进程的资源</li>
</ul>
<p>进程和线程是操作系统中的两个核心概念，它们的主要区别如下：</p>
<h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. <strong>定义</strong></h3><ul>
<li><strong>进程</strong>：是指程序的一次执行过程，是操作系统进行资源分配的基本单位。每个进程都有独立的地址空间、内存、数据栈和其他辅助数据结构（如进程控制块）来跟踪其执行状态。</li>
<li><strong>线程</strong>：是进程内的一个执行单元，是 CPU 调度和分派的基本单位。线程是比进程更小的能独立运行的基本单位。一个进程可以包含一个或多个线程，这些线程共享进程的资源。</li>
</ul>
<h3 id="2-资源分配"><a href="#2-资源分配" class="headerlink" title="2. 资源分配"></a>2. <strong>资源分配</strong></h3><ul>
<li><strong>进程</strong>：每个进程都有独立的内存空间和系统资源（如文件描述符、信号量、内核对象等）。这种隔离性确保一个进程的崩溃不会直接影响到其他进程，提升了系统的稳定性和安全性。</li>
<li><strong>线程</strong>：线程共享同一进程的内存空间和资源，使得它们能够高效地交换数据和信息。但这也带来了风险：一个线程的错误可能导致整个进程崩溃，影响其他线程的正常运行。</li>
</ul>
<h3 id="3-上下文切换"><a href="#3-上下文切换" class="headerlink" title="3. 上下文切换"></a>3. <strong>上下文切换</strong></h3><ul>
<li><strong>进程上下文切换</strong>：进程切换涉及到保存和恢复大量的上下文信息，包括内存管理信息（如页表）、CPU寄存器和其他资源信息。这种切换开销较大，导致进程间的切换效率较低。</li>
<li><strong>线程上下文切换</strong>：线程切换相对轻便，因为它们共享同一进程的内存空间，只需保存和恢复少量信息（如寄存器状态和栈指针）。这种低开销使得线程在需要频繁切换执行上下文的高并发场景下更加高效。</li>
</ul>
<h3 id="4-通信方式"><a href="#4-通信方式" class="headerlink" title="4. 通信方式"></a>4. <strong>通信方式</strong></h3><ul>
<li><strong>进程间通信（IPC）</strong>：由于进程具有独立的内存空间，进程间的通信需要通过特定的IPC机制，如管道、消息队列、共享内存等。</li>
<li><strong>线程间通信</strong>：由于线程共享同一进程的内存，线程间的通信可以通过共享变量来实现，效率更高。但这也引入了并发访问的问题，需要通过同步机制（如互斥锁、信号量、条件变量等）来保证数据的一致性和正确性。</li>
</ul>
<h3 id="5-应用场景"><a href="#5-应用场景" class="headerlink" title="5. 应用场景"></a>5. <strong>应用场景</strong></h3><ul>
<li><strong>多进程</strong>：适用于需要高可靠性和隔离性的场景。例如，服务器的每个请求可以使用独立的进程，这样一个进程的崩溃不会影响到其他进程，增强了系统的稳定性和安全性。</li>
<li><strong>多线程</strong>：适用于需要快速响应和高效资源利用的场景。例如，图形用户界面应用程序通常使用多线程来处理用户输入、后台任务和界面更新，以提高用户体验和系统响应能力。</li>
</ul>
<h3 id="6-性能考虑"><a href="#6-性能考虑" class="headerlink" title="6. 性能考虑"></a>6. <strong>性能考虑</strong></h3><ul>
<li><strong>进程</strong>：由于进程的隔离性，虽然可以提供更好的安全性和稳定性，但也会引入较大的性能开销，特别是在需要频繁创建和销毁进程的场景。</li>
<li><strong>线程</strong>：线程在性能上更具优势，适合于高并发和高响应要求的应用场景。然而，线程间的共享资源管理和同步问题也可能导致复杂性和性能下降，尤其是在锁争用和上下文切换频繁的情况下。.</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://0zxm.github.io">0zxm</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://0zxm.github.io/2024/12/25/cpp11-xin-te-xing/">https://0zxm.github.io/2024/12/25/cpp11-xin-te-xing/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://0zxm.github.io" target="_blank">0zxm</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/c/">c++</a></div><div class="post-share"><div class="social-share" data-image="/img/default_cover.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/wechat.png" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/01/01/qlabel-tian-jia-dian-ji-chu-li/" title="QLabel添加点击处理"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">QLabel添加点击处理</div></div><div class="info-2"><div class="info-item-1">Qt框架中添加QLabel的点击事件</div></div></div></a><a class="pagination-related" href="/2024/12/12/shu-ju-wa-jue-da-zuo-ye/" title="数据挖掘大作业"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default_cover.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">数据挖掘大作业</div></div><div class="info-2"><div class="info-item-1">数据挖掘课程大作业</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/02/14/cpp-mian-shi-ti/" title="Cpp面试题"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default_cover.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-14</div><div class="info-item-2">Cpp面试题</div></div><div class="info-2"><div class="info-item-1">面试题</div></div></div></a><a class="pagination-related" href="/2024/07/17/c-cheng-xu-she-ji/" title="C++程序设计"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover2.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-17</div><div class="info-item-2">C++程序设计</div></div><div class="info-2"><div class="info-item-1">c++编程</div></div></div></a><a class="pagination-related" href="/2025/01/07/c-wang-luo-tong-xin/" title="C++网络通信"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover2.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-07</div><div class="info-item-2">C++网络通信</div></div><div class="info-2"><div class="info-item-1">c++多种方式实现网络通信</div></div></div></a><a class="pagination-related" href="/2025/01/09/cpp-wang-luo-tong-xin-zhi-feng-zhuang-http-xie-yi/" title="cpp网络通信之封装http协议"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover2.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-09</div><div class="info-item-2">cpp网络通信之封装http协议</div></div><div class="info-2"><div class="info-item-1">使用WinSock2的API封装出http协议便于使用</div></div></div></a><a class="pagination-related" href="/2024/06/21/suan-fa/" title="算法"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover2.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-21</div><div class="info-item-2">算法</div></div><div class="info-2"><div class="info-item-1">算法课笔记</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/favicon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">0zxm</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">57</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">65</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/0zxm"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/0zxm" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:m15813109801@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="http://0zxm.github.io" target="_blank" title="博客"><i class="fab fa-algolia" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-c-%E5%8E%9F%E5%A7%8B%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-text">1.c++原始字面量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-text">1.1 什么是字面量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%8E%9F%E5%A7%8B%E5%AD%97%E9%9D%A2%E9%87%8F%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7"><span class="toc-text">1.2 原始字面量的必要性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%8C%87%E9%92%88%E7%A9%BA%E5%80%BC%E7%B1%BB%E5%9E%8Bnullptr"><span class="toc-text">2.指针空值类型nullptr</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E5%92%8C%E6%98%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2%E7%9A%84%E5%BF%85%E8%A6%81"><span class="toc-text">2.1 隐式转换和显式转换的必要</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-constexpr%E6%96%B0%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">3.constexpr新关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-const%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">3.1 const关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-constexpr%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">3.2 constexpr常量表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%87%BD%E6%95%B0"><span class="toc-text">3.3 常量表达式函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a-%E4%BF%AE%E9%A5%B0%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0"><span class="toc-text">a. 修饰普通函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-text">b. 修饰成员函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c-%E4%BF%AE%E9%A5%B0%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0"><span class="toc-text">c. 修饰模板函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#d-%E4%BF%AE%E9%A5%B0%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">d. 修饰构造函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-auto%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC"><span class="toc-text">4.auto类型推导</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-auto%E7%9A%84%E6%8E%A8%E5%AF%BC%E8%A7%84%E5%88%99"><span class="toc-text">4.1 auto的推导规则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a-%E8%87%AA%E5%8A%A8%E5%AD%98%E5%82%A8%E6%9C%9F"><span class="toc-text">a. 自动存储期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-auto%E7%9A%84%E6%8E%A8%E5%AF%BC%E8%A7%84%E5%88%99"><span class="toc-text">b. auto的推导规则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-auto%E7%9A%84%E9%99%90%E5%88%B6"><span class="toc-text">4.2 auto的限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-auto%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">4.3 auto的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-decltype%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">4.4 decltype关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-decltype%E7%9A%84%E6%8E%A8%E5%AF%BC%E8%A7%84%E5%88%99"><span class="toc-text">4.5 decltype的推导规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-decltype%E5%9C%A8%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">4.6 decltype在泛型编程的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%90%8E%E7%BD%AE-%E5%A3%B0%E6%98%8E%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B"><span class="toc-text">4.7 返回类型的后置(声明返回类型?)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-final%E5%92%8Coverride"><span class="toc-text">5.final和override</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-final-%E4%BF%AE%E9%A5%B0%E5%87%BD%E6%95%B0"><span class="toc-text">5.1 final 修饰函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-final-%E4%BF%AE%E9%A5%B0%E7%B1%BB"><span class="toc-text">5.2 final 修饰类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-overide"><span class="toc-text">5.3 overide</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%A8%A1%E6%9D%BF%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-text">6.模板的优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E6%A8%A1%E6%9D%BF%E5%B5%8C%E5%A5%97%E5%8F%B3%E5%B0%96%E6%8B%AC%E5%8F%B7%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-text">6.1 模板嵌套右尖括号的优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E9%BB%98%E8%AE%A4%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0"><span class="toc-text">6.2 默认模板参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-using%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">7.using关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E7%BB%99%E7%B1%BB%E5%AE%9A%E4%B9%89%E5%88%AB%E5%90%8D"><span class="toc-text">7.1 给类定义别名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E7%BB%99%E6%A8%A1%E6%9D%BF%E5%AE%9A%E4%B9%89%E5%88%AB%E5%90%8D"><span class="toc-text">7.2 给模板定义别名</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%A7%94%E6%89%98%E6%9E%84%E9%80%A0%E5%92%8C%E7%BB%A7%E6%89%BF%E6%9E%84%E9%80%A0"><span class="toc-text">8.委托构造和继承构造</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-%E5%A7%94%E6%89%98%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">8.1 委托构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-%E7%BB%A7%E6%89%BF%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">8.2 继承构造函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="toc-text">9.初始化列表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-%E7%BB%9F%E4%B8%80%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E5%BC%8F"><span class="toc-text">9.1 统一的初始化方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BB%86%E8%8A%82"><span class="toc-text">9.2 列表初始化细节</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a-%E8%81%9A%E5%90%88%E4%BD%93"><span class="toc-text">a. 聚合体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-%E9%9D%9E%E8%81%9A%E5%90%88%E4%BD%93"><span class="toc-text">b. 非聚合体</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-std-initializer-list"><span class="toc-text">9.3 std::initializer_list</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a-%E4%BD%9C%E4%B8%BA%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-text">a. 作为普通函数参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-%E4%BD%9C%E4%B8%BA%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-text">b. 作为构造函数参数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E5%9F%BA%E4%BA%8E%E8%8C%83%E5%9B%B4%E7%9A%84for%E5%BE%AA%E7%8E%AF"><span class="toc-text">10.基于范围的for循环</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-for%E5%BE%AA%E7%8E%AF%E7%9A%84%E6%96%B0%E8%AF%AD%E6%B3%95"><span class="toc-text">10.1 for循环的新语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82"><span class="toc-text">10.2 使用细节</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a-%E5%85%B3%E7%B3%BB%E5%9E%8B%E5%AE%B9%E5%99%A8"><span class="toc-text">a. 关系型容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-%E5%85%83%E7%B4%A0%E5%8F%AA%E8%AF%BB"><span class="toc-text">b. 元素只读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c-%E8%AE%BF%E9%97%AE%E6%AC%A1%E6%95%B0"><span class="toc-text">c. 访问次数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1%E5%8C%85%E8%A3%85%E5%99%A8%E3%80%81%E7%BB%91%E5%AE%9A%E5%99%A8"><span class="toc-text">11.可调用对象包装器、绑定器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1-%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1"><span class="toc-text">11.1 可调用对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1%E5%8C%85%E8%A3%85%E5%99%A8"><span class="toc-text">11.2 可调用对象包装器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-3-bind%E7%BB%91%E5%AE%9A%E5%99%A8"><span class="toc-text">11.3 bind绑定器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">12.lambda表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-1-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-text">12.1 基本用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-2-%E6%8D%95%E8%8E%B7%E5%88%97%E8%A1%A8"><span class="toc-text">12.2 捕获列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-text">12.3 返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-4-%E5%87%BD%E6%95%B0%E6%9C%AC%E8%B4%A8"><span class="toc-text">12.4 函数本质</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E5%92%8C%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-text">13.左值引用和右值引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-1-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-text">13.1 右值引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%B3%E5%80%BC"><span class="toc-text">右值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-text">右值引用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-2-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-text">13.2 性能优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-3-%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-text">13.3 &amp;&amp; 的特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-%E8%BD%AC%E7%A7%BB%E5%92%8C%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91"><span class="toc-text">14.转移和完美转发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14-1-move%E8%BD%AC%E7%A7%BB"><span class="toc-text">14.1 move转移</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-2-forward%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91"><span class="toc-text">14.2 forward完美转发</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-%E5%85%B1%E4%BA%AB%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-text">15.共享智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#15-1-shared-ptr%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">15.1 shared_ptr的初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a-%E9%80%9A%E8%BF%87%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">a. 通过构造函数初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-%E9%80%9A%E8%BF%87%E6%8B%B7%E8%B4%9D%E5%92%8C%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">b. 通过拷贝和移动构造函数初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c-%E9%80%9A%E8%BF%87-std-make-shared-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">c. 通过 std::make_shared 初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#d-%E9%80%9A%E8%BF%87-reset%E6%96%B9%E6%B3%95%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">d. 通过 reset方法初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#e-%E8%8E%B7%E5%8F%96%E5%8E%9F%E5%A7%8B%E6%8C%87%E9%92%88"><span class="toc-text">e. 获取原始指针</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-2-%E6%8C%87%E5%AE%9A%E5%88%A0%E9%99%A4%E5%99%A8"><span class="toc-text">15.2 指定删除器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-%E7%8B%AC%E5%8D%A0%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-text">16.独占的智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#16-1-unique-ptr%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">16.1 unique_ptr的初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-2-%E5%88%A0%E9%99%A4%E5%99%A8"><span class="toc-text">16.2 删除器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-weak-ptr"><span class="toc-text">17.weak_ptr</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#17-1-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">17.1 基本使用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">a. 初始化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-2-%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">17.2 其他常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a-use-count"><span class="toc-text">a. use_count()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-expired"><span class="toc-text">b. expired()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c-lock"><span class="toc-text">c. lock()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#d-reset"><span class="toc-text">d. reset()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-3-%E8%BF%94%E5%9B%9E%E7%AE%A1%E7%90%86this%E7%9A%84shared-ptr"><span class="toc-text">17.3 返回管理this的shared_ptr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#enable-shared-from-this-%E6%A0%B8%E5%BF%83%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">enable_shared_from_this 核心实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-text">1. 内部结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%8E%A7%E5%88%B6%E5%9D%97%E7%BB%91%E5%AE%9A%E6%B5%81%E7%A8%8B"><span class="toc-text">2. 控制块绑定流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-shared-from-this-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6"><span class="toc-text">3. shared_from_this() 的工作机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-4-%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98"><span class="toc-text">17.4 解决循环引用问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-final%E5%92%8Coverride"><span class="toc-text">18.final和override</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#18-1-final%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">18.1 final关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-2-override%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">18.2 override关键字</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-%E7%B1%BB%E6%88%90%E5%91%98%E7%9A%84%E5%BF%AB%E9%80%9F%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">19.类成员的快速初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#19-1-c-98%E7%9A%84%E7%B1%BB%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">19.1 c++98的类成员初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-2-c-11%E6%A0%87%E5%87%86%E7%9A%84%E7%B1%BB%E6%88%90%E5%91%98%E5%BF%AB%E9%80%9F%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">19.2 c++11标准的类成员快速初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-%E8%B6%85%E9%95%BF%E6%95%B4%E5%BD%A2longlong"><span class="toc-text">20.超长整形longlong</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#20-1-longlong%E7%B1%BB%E5%9E%8B"><span class="toc-text">20.1 longlong类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-2-%E6%89%A9%E5%B1%95%E7%9A%84%E6%95%B4%E5%BD%A2"><span class="toc-text">20.2 扩展的整形</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-text">21.数值类型和字符串之间的转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#21-1-%E6%95%B0%E5%80%BC%E8%BD%AC%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">21.1 数值转成字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B0%E5%80%BC"><span class="toc-text">21.2 字符串转换成数值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-%E9%9D%99%E6%80%81%E6%96%AD%E8%A8%80"><span class="toc-text">22.静态断言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#22-1-%E6%96%AD%E8%A8%80"><span class="toc-text">22.1 断言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-2-%E9%9D%99%E6%80%81%E6%96%AD%E8%A8%80"><span class="toc-text">22.2 静态断言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-3-%E4%B8%8D%E5%90%8C%E7%B3%BB%E7%BB%9F%E9%97%B4%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%AF%B9%E6%AF%94"><span class="toc-text">22.3 不同系统间数据类型对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-noexcept"><span class="toc-text">23.noexcept</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#23-1-%E5%BC%82%E5%B8%B8"><span class="toc-text">23.1 异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-2-noexcept"><span class="toc-text">23.2 noexcept</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-POD%E7%B1%BB%E5%9E%8B"><span class="toc-text">24.POD类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#24-1-POD%E7%B1%BB%E5%9E%8B"><span class="toc-text">24.1 POD类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-2-%E2%80%9C%E5%B9%B3%E5%87%A1%E2%80%9D%E7%B1%BB%E5%9E%8B"><span class="toc-text">24.2 “平凡”类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-3-%E6%A0%87%E5%87%86%E5%B8%83%E5%B1%80%E7%B1%BB%E5%9E%8B"><span class="toc-text">24.3 标准布局类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-4-%E5%AF%B9-POD-%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%88%A4%E6%96%AD"><span class="toc-text">24.4 对 POD 类型的判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-5-%E6%80%BB%E7%BB%93"><span class="toc-text">24.5 总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-%E6%98%BE%E5%BC%8F%E9%BB%98%E8%AE%A4%E8%AE%BE%E7%BD%AE%E7%9A%84%E5%87%BD%E6%95%B0%E5%92%8C%E5%B7%B2%E5%88%A0%E9%99%A4%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-text">25.显式默认设置的函数和已删除的函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#25-1-%E7%B1%BB%E4%B8%8E%E9%BB%98%E8%AE%A4%E5%87%BD%E6%95%B0"><span class="toc-text">25.1 类与默认函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-2-default"><span class="toc-text">25.2 &#x3D;default</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-3-delete"><span class="toc-text">25.3 &#x3D;delete</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-%E6%8B%93%E5%B1%95%E7%9A%84friend%E8%AF%AD%E6%B3%95"><span class="toc-text">26.拓展的friend语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#26-1-%E8%AF%AD%E6%B3%95%E6%94%B9%E8%BF%9B"><span class="toc-text">26.1 语法改进</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-2-%E4%B8%BA%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%A3%B0%E6%98%8E%E5%8F%8B%E5%85%83"><span class="toc-text">26.2 为类模板声明友元</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-text">27.枚举类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#27-1-%E6%9E%9A%E4%B8%BE"><span class="toc-text">27.1 枚举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-2-%E5%BC%BA%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-text">27.2 强枚举类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-%E9%9D%9E%E5%8F%97%E9%99%90%E8%81%94%E5%90%88%E4%BD%93"><span class="toc-text">28.非受限联合体</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#28-1-%E8%81%94%E5%90%88%E4%BD%93"><span class="toc-text">28.1 联合体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-2-%E9%9D%9E%E5%8F%97%E9%99%90%E8%81%94%E5%90%88%E4%BD%93"><span class="toc-text">28.2 非受限联合体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-3-placement-new"><span class="toc-text">28.3 placement new</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-4-%E5%8C%BF%E5%90%8D%E7%9A%84%E9%9D%9E%E5%8F%97%E9%99%90%E8%81%94%E5%90%88%E4%BD%93"><span class="toc-text">28.4 匿名的非受限联合体</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8F"><span class="toc-text">宏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E5%92%8C%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-text">左值引用和右值引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%EF%BC%88lvalue-reference%EF%BC%89"><span class="toc-text">左值引用（lvalue reference）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%EF%BC%88rvalue-reference%EF%BC%89"><span class="toc-text">右值引用（rvalue reference）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB%E6%80%BB%E7%BB%93"><span class="toc-text">区别总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E4%B8%80%E6%AD%A5%E7%90%86%E8%A7%A3"><span class="toc-text">进一步理解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">进程和线程的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89"><span class="toc-text">1. 定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D"><span class="toc-text">2. 资源分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-text">3. 上下文切换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-text">4. 通信方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">5. 应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%80%A7%E8%83%BD%E8%80%83%E8%99%91"><span class="toc-text">6. 性能考虑</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/03/08/java-ji-chu-xia/" title="Java基础下"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java基础下"/></a><div class="content"><a class="title" href="/2025/03/08/java-ji-chu-xia/" title="Java基础下">Java基础下</a><time datetime="2025-03-08T03:43:21.000Z" title="发表于 2025-03-08 11:43:21">2025-03-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/07/qian-ru-shi-xi-tong-gai-shu/" title="嵌入式系统概述"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default_cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="嵌入式系统概述"/></a><div class="content"><a class="title" href="/2025/03/07/qian-ru-shi-xi-tong-gai-shu/" title="嵌入式系统概述">嵌入式系统概述</a><time datetime="2025-03-07T06:08:48.000Z" title="发表于 2025-03-07 14:08:48">2025-03-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/05/da-shu-ju-ke-shi-hua/" title="大数据可视化"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default_cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="大数据可视化"/></a><div class="content"><a class="title" href="/2025/03/05/da-shu-ju-ke-shi-hua/" title="大数据可视化">大数据可视化</a><time datetime="2025-03-05T04:51:12.000Z" title="发表于 2025-03-05 12:51:12">2025-03-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/05/shou-ji-ruan-jian-kai-fa/" title="手机软件开发"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="手机软件开发"/></a><div class="content"><a class="title" href="/2025/03/05/shou-ji-ruan-jian-kai-fa/" title="手机软件开发">手机软件开发</a><time datetime="2025-03-05T04:50:56.000Z" title="发表于 2025-03-05 12:50:56">2025-03-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/04/ji-suan-ji-tu-xing-xue-he-xu-ni-xian-shi/" title="计算机图形学和虚拟现实"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机图形学和虚拟现实"/></a><div class="content"><a class="title" href="/2025/03/04/ji-suan-ji-tu-xing-xue-he-xu-ni-xian-shi/" title="计算机图形学和虚拟现实">计算机图形学和虚拟现实</a><time datetime="2025-03-04T15:30:27.000Z" title="发表于 2025-03-04 23:30:27">2025-03-04</time></div></div></div></div></div></div><!-- 登录验证模态框--><div id="login-modal"><div class="modal-overlay"></div><div class="modal-content"><h2>Welcome</h2><p>Please enter the password to access this page.</p><input id="password-input" type="password" placeholder="Enter Password"><button id="submit-btn">Submit</button><p id="error-msg" style="color: red; display: none;">Invalid Password. Please try again.</p></div></div></main><footer id="footer" style="background-image: url(/img/footer.jpg);"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By 0zxm</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }
      
      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- CSS 样式--><style>#login-modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
}

.modal-overlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.8);
  cursor: pointer;
}

.modal-content {
  background-color: white;
  padding: 20px;
  border-radius: 10px;
  text-align: center;
  width: 80%;
  max-width: 400px;
  box-shadow: 0 0 10px rgba(0,0,0,0.3);
  z-index:999;
}

input#password-input {
  width: 100%;
  padding: 10px;
  margin-top: 10px;
  margin-bottom: 20px;
  border: 1px solid #ccc;
  border-radius: 4px;
}

button#submit-btn {
  background-color: #4CAF50;
  color: white;
  padding: 10px 20px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

button#submit-btn:hover {
  background-color: #45a049;
}
</style><!-- JavaScript 验证--><script>document.addEventListener('DOMContentLoaded', function() {

  (function() {
  // 禁用右键菜单
  document.addEventListener('contextmenu', function(e) {
    e.preventDefault();
    return false;
  });

  // 禁用快捷键 (F12/Ctrl+Shift+I/Ctrl+Shift+J/Ctrl+Shift+C)
  document.addEventListener('keydown', function(e) {
    if (e.key === 'F12' || 
        (e.ctrlKey && e.shiftKey && e.key === 'I') || 
        (e.ctrlKey && e.shiftKey && e.key === 'J') ||
        (e.ctrlKey && e.shiftKey && e.key === 'C')) {
      e.preventDefault();
      return false;
    }
  });
  })();
  

  const modal = document.getElementById('login-modal');
  const passwordInput = document.getElementById('password-input');
  const submitBtn = document.getElementById('submit-btn');
  const errorMsg = document.getElementById('error-msg');
  const bodyWrap = document.getElementById('body-wrap');


  // 默认显示模态框
  modal.style.display = 'flex';

  // 自动聚焦到密码输入框
  passwordInput.focus();

  submitBtn.addEventListener('click', function(e) {
    e.preventDefault();
    const password = passwordInput.value;
    const correctPassword = 'D&X'; // 替换为实际密码

    if (password === correctPassword) {
      modal.style.display = 'none';
      bodyWrap.style.opacity = 1; // 显示页面内容
    } else {
      passwordInput.classList.add('error');
      errorMsg.style.display = 'block';
      setTimeout(() => {
        passwordInput.classList.remove('error');
        errorMsg.style.display = 'none';
      }, 2000);
    }
  });
  // 按下 Enter 键提交
  passwordInput.addEventListener('keypress', function(e) {
    if (e.key === 'Enter') {
      submitBtn.click();
    }
  });
});</script></body></html>