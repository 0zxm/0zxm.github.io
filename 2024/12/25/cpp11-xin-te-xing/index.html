<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>cpp11新特性 | 0zxm</title><meta name="author" content="0zxm"><meta name="copyright" content="0zxm"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="c++11版本语法的新特性">
<meta property="og:type" content="article">
<meta property="og:title" content="cpp11新特性">
<meta property="og:url" content="https://0zxm.github.io/2024/12/25/cpp11-xin-te-xing/index.html">
<meta property="og:site_name" content="0zxm">
<meta property="og:description" content="c++11版本语法的新特性">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://0zxm.github.io/img/cover1.jpg">
<meta property="article:published_time" content="2024-12-25T12:52:06.000Z">
<meta property="article:modified_time" content="2025-02-19T15:15:20.309Z">
<meta property="article:author" content="0zxm">
<meta property="article:tag" content="c++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://0zxm.github.io/img/cover1.jpg"><link rel="shortcut icon" href="/favicon.png"><link rel="canonical" href="https://0zxm.github.io/2024/12/25/cpp11-xin-te-xing/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        if (name && globalFn[key][name]) return
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"prismjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: 0zxm","link":"链接: ","source":"来源: 0zxm","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'cpp11新特性',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-02-19 23:15:20'
}</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/favicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">51</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">59</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/src/"><i class="fa-fw fas fa-cloud"></i><span> 资源</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo/"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/cover1.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">0zxm</span></a><a class="nav-page-title" href="/"><span class="site-name">cpp11新特性</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/src/"><i class="fa-fw fas fa-cloud"></i><span> 资源</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo/"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">cpp11新特性</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-12-25T12:52:06.000Z" title="发表于 2024-12-25 20:52:06">2024-12-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-02-19T15:15:20.309Z" title="更新于 2025-02-19 23:15:20">2025-02-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/c/">c++</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">23.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>90分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1bX4y1G7ks/">bilibili教程</a></p>
<p><a target="_blank" rel="noopener" href="https://subingwen.cn/cpp/constexpr/#1-1-const">部分引用自爱编程的大丙</a></p>
<h2 id="1-c-原始字面量"><a href="#1-c-原始字面量" class="headerlink" title="1.c++原始字面量"></a>1.c++原始字面量</h2><h3 id="1-1-什么是字面量"><a href="#1-1-什么是字面量" class="headerlink" title="1.1 什么是字面量"></a>1.1 什么是字面量</h3><p>在编程语言中，“字面量”（Literal）是指在源代码中直接表示某一固定值的符号。字面量是编程语言中最基本的数据表示方式之一，它们是编译时已知的常量值，不需要通过变量或其他表达式计算得到。以下是一些常见的字面量类型：</p>
<ol>
<li><p><strong>数值字面量</strong>：直接表示数字的字面量，如整数、浮点数等。</p>
<ul>
<li>整数：<code>123</code>，<code>0xFF</code>（十六进制），<code>0b1010</code>（二进制）等。</li>
<li>浮点数：<code>3.14</code>，<code>2.5e-3</code>（科学记数法）等。</li>
</ul>
</li>
<li><p><strong>字符字面量</strong>：用单引号括起来的单个字符，如 <code>&#39;A&#39;</code>、<code>&#39;5&#39;</code>、<code>&#39;\n&#39;</code>（换行符）等。</p>
</li>
<li><p><strong>字符串字面量</strong>：用双引号括起来的字符序列，如 <code>&quot;Hello, World!&quot;</code>。</p>
</li>
<li><p><strong>布尔字面量</strong>：表示逻辑值的字面量，如 <code>true</code> 和 <code>false</code>。</p>
</li>
<li><p><strong>空字面量</strong>：表示空值的字面量，如 C++11 中的 <code>nullptr</code>。</p>
</li>
<li><p><strong>复合字面量</strong>：某些语言支持复合字面量，如数组或结构体的初始化。</p>
<ul>
<li>数组：<code>int arr[] = &#123;1, 2, 3&#125;;</code></li>
<li>结构体：<code>Point p = &#123;10, 20&#125;;</code></li>
</ul>
</li>
</ol>
<p>字面量在编程中非常重要，因为它们提供了一种简洁的方式来表示和使用常量值。在编译过程中，字面量会被替换为它们对应的值，这有助于提高代码的可读性和效率。</p>
<h3 id="1-2-原始字面量的必要性"><a href="#1-2-原始字面量的必要性" class="headerlink" title="1.2 原始字面量的必要性"></a>1.2 原始字面量的必要性</h3><p><code>字符串&quot;h\t&quot;</code>会产生歧义,因为<code>\</code>在c++中是转义字符,<code>\t</code>可以表示制表符,所以输出可能不是你想的预期结果</p>
<ul>
<li>反斜杠可以将原始字符转成有特殊含义的字符,<code>\r</code>,<code>\n</code>,<code>\t</code>分别表示回车,换行以及制表符</li>
<li>反斜杠同样可以将有特殊含义的字符转成原始字符,例如<code>\\t</code>在输出的时候将会被看作一个普通的t来输出</li>
</ul>
<p>所以,使用原始字面量就很有必要了,在c++11及以后的版本中,可以使用<code>R&quot;xxx(你想输出的原始字符串的内容)xxx&quot;</code>来输出不会被转义的字符串常量,其中xxx是对原始字面量的描述,在编译时会被省略.</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    string s1 <span class="token operator">=</span> <span class="token string">"hello \
    world"</span><span class="token punctuation">;</span> <span class="token comment">// 使用连接符连接多个字符串</span>

    string s2 <span class="token operator">=</span> <span class="token raw-string string">R"(hello
    world)"</span><span class="token punctuation">;</span> <span class="token comment">// 使用原始字符串字面量的时候可以不用加连接符,语法不会错</span>

    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token raw-string string">R"(h\ello world)"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>           <span class="token comment">// 原始字面量</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token raw-string string">R"hello(h\ello world)hello"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 描述内容必须一样,并且不能为中文</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"h\t"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>                                 <span class="token comment">// 不使用原始字面量</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"h\\t"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>                                <span class="token comment">// 使用两个反斜杠转义</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="2-指针空值类型nullptr"><a href="#2-指针空值类型nullptr" class="headerlink" title="2.指针空值类型nullptr"></a>2.指针空值类型nullptr</h2><p><code>NULL</code> 是一个在 C 和 C++ 编程语言中广泛使用的宏定义，它表示一个空指针常量，即一个不指向任何对象或函数的指针。<code>NULL</code> 的值通常是 <code>0</code>（在大多数平台上），但这个定义允许编译器和运行时系统识别它是一个空指针，而不是一个普通的整数。</p>
<p>在 C 语言中，<code>NULL</code> 被定义在 <code>&lt;stddef.h&gt;</code> 或 <code>&lt;stdlib.h&gt;</code> 头文件中，而在 C++ 中，它被定义在 <code>&lt;cstddef&gt;</code> 或 <code>&lt;cstdlib&gt;</code> 头文件中。<code>NULL</code> 的定义如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NULL</span> <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>或者在 C++ 中：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/* A null pointer constant.  */</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token function">defined</span> <span class="token punctuation">(</span>_STDDEF_H<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">defined</span> <span class="token punctuation">(</span>__need_NULL<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">undef</span> <span class="token expression"><span class="token constant">NULL</span>		</span><span class="token comment">/* in case &lt;stdio.h> has defined it. */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token function">defined</span><span class="token punctuation">(</span>__GNUG__<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> __GNUG__ <span class="token operator">>=</span> <span class="token number">3</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NULL</span> <span class="token expression">__null</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span>   <span class="token comment">/* G++ */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">__cplusplus</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NULL</span> <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span>   <span class="token comment">/* C++ */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">_WIN64</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NULL</span> <span class="token expression"><span class="token number">0</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NULL</span> <span class="token expression"><span class="token number">0LL</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span>  <span class="token comment">/* W64 */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span>  <span class="token comment">/* C++ */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span>  <span class="token comment">/* G++ */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span>	<span class="token comment">/* NULL not defined and &lt;stddef.h> or need NULL.  */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">undef</span>	<span class="token expression">__need_NULL</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在 C++11 及以后的版本中，<code>NULL</code> 被 <code>nullptr</code> 取代，因为 <code>nullptr</code> 是一个类型安全的关键字，它只能被用来表示空指针。<code>nullptr</code> 的类型是 <code>std::nullptr_t</code>，它是一个特殊的指针类型，可以被隐式转换为任何指针类型或引用类型，但不能转换为其他类型。</p>
<p>在给<code>int*</code>变量初始化的时候会被自动转成<code>int*</code>类型</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"func(int p) called"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"func(char* p) called"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token keyword">const</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>ptr1 <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">// 空指针,会被隐式转换</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>ptr1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> ptr1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 输出 0</span>
    <span class="token keyword">double</span> <span class="token operator">*</span>ptr2 <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>ptr3 <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>ptr4 <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token comment">// void * ptr4 = (void *)0;</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>ptr <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span> <span class="token comment">// 自动隐式转换成 "int *" 类型</span>

    <span class="token comment">// int *ptr5 = ptr4;     //"void *" 类型的值不能用于初始化 "int *" 类型的实体C/C++,这在C++11中是不允许的</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>ptr5 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span>ptr4<span class="token punctuation">;</span> <span class="token comment">// 显式类型转换</span>

    <span class="token function">func</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用func(int p)函数</span>
    <span class="token comment">// func(NULL); // 还是使用 func(int p)函数，因为NULL是其实是一个(void *)0</span>

    <span class="token comment">// 所以想调用func(char* p)函数，需要使用nullptr关键字</span>
    <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用func(char* p)函数</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>使用 <code>NULL</code> 或 <code>nullptr</code> 而不是直接使用 <code>0</code> 作为空指针的理由是：</p>
<ol>
<li><strong>类型安全</strong>：<code>NULL</code> 和 <code>nullptr</code> 提供了类型安全的空指针表示，它们明确地告诉编译器这是一个指针值，而不是一个整数。</li>
<li><strong>可移植性</strong>：不同的系统和编译器可能有不同的空指针表示，使用 <code>NULL</code> 或 <code>nullptr</code> 可以确保代码的可移植性。</li>
<li><strong>清晰性</strong>：在代码中使用 <code>NULL</code> 或 <code>nullptr</code> 可以提高代码的可读性，让其他开发者更容易理解代码的意图。</li>
<li><strong>避免歧义</strong>：在某些上下文中，<code>0</code> 可能被解释为整数，而 <code>NULL</code> 或 <code>nullptr</code> 明确表示这是一个空指针。</li>
</ol>
<h3 id="2-1-隐式转换和显式转换的必要"><a href="#2-1-隐式转换和显式转换的必要" class="headerlink" title="2.1 隐式转换和显式转换的必要"></a>2.1 隐式转换和显式转换的必要</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stddef.h></span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression"><span class="token constant">NULL</span></span></span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"NULL is defined as: "</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">NULL</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// NULL is defined as: 0</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>

    <span class="token comment">// void *ptr = NULL;</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>ptr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// ptr就是把0转化为指向void类型的指针,类似于内存0???</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>ptr2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span>ptr<span class="token punctuation">;</span> <span class="token comment">// ptr2就是指向0的int指针</span>
    <span class="token comment">// int *ptr5 = ptr;         // 不合法, 因为ptr5的类型是int*，而ptr的类型是void*,需要进行类型转换</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ptr: "</span> <span class="token operator">&lt;&lt;</span> ptr <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ptr2: "</span> <span class="token operator">&lt;&lt;</span> ptr2 <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token comment">// std::cout &lt;&lt; "ptr5: " &lt;&lt; ptr5 &lt;&lt; std::endl;</span>

    <span class="token keyword">int</span> <span class="token operator">*</span>ptr_i <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">// NULL相当于0</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>ptr_i_ <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression"><span class="token constant">NULL</span></span></span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"NULL is defined as: "</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">NULL</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="3-constexpr新关键字"><a href="#3-constexpr新关键字" class="headerlink" title="3.constexpr新关键字"></a>3.constexpr新关键字</h2><h3 id="3-1-const关键字"><a href="#3-1-const关键字" class="headerlink" title="3.1 const关键字"></a>3.1 const关键字</h3><p>在C++11之前只有<code>const关键字</code>，从功能上来说这个关键字有双重语义：<code>变量只读</code>，<code>修饰常量</code>，举一个简单的例子：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> num<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">const</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">24</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> array<span class="token punctuation">[</span>num<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment">// 报错，num是一个只读变量，不是常量 因为const修饰参数</span>
    <span class="token keyword">int</span> array1<span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token comment">// ok，count是一个常量</span>

    <span class="token keyword">int</span> a1 <span class="token operator">=</span> <span class="token number">520</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> a2 <span class="token operator">=</span> <span class="token number">250</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> array2<span class="token punctuation">[</span>a1<span class="token punctuation">]</span><span class="token punctuation">;</span>				<span class="token comment">// 报错, 定义数组不能使用变量</span>
    
    <span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> b <span class="token operator">=</span> a1<span class="token punctuation">;</span>
    b <span class="token operator">=</span> a2<span class="token punctuation">;</span>                         <span class="token comment">// 报错</span>
    a1 <span class="token operator">=</span> <span class="token number">1314</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"b: "</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>     <span class="token comment">// 输出结果为1314</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>函数 <code>void func(const int num)</code> 的参数 <code>num</code> 表示这个变量是只读的，但不是常量，因此使用 <code>int array[num];</code> 这种方式定义一个数组，编译器是会报错的，提示 <code>num不可用作为常量来使用。</code></li>
<li><code>const int count = 24;</code>中的<code>count</code>却是一个常量，因此可以使用这个常量来定义一个静态数组。</li>
</ul>
<p>另外，<code>变量只读并不等价于常量</code>，二者是两个概念不能混为一谈，分析一下这句测试代码<code>const int&amp; b = a1;</code></p>
<ul>
<li>b是一个常量的引用，所以 <code>b</code> 引用的变量是不能被修改的，也就是说 <code>b = a2; </code> 这句代码语法是错误的。</li>
<li>语句的<code>const</code> 对于 <code>变量a1</code> 是没有任何约束的，a1 的值变了 b 的值也就变了</li>
<li>引用b是<code>只读的</code>，但是并不能保证它的值是不可改变的，也就是说它不是常量。</li>
</ul>
<h3 id="3-2-constexpr常量表达式"><a href="#3-2-constexpr常量表达式" class="headerlink" title="3.2 constexpr常量表达式"></a>3.2 constexpr常量表达式</h3><p>在C++11中添加了一个新的关键字 <code>constexpr</code>，这个关键字是用来修饰 <code>常量表达式</code> 的。所谓常量表达式，指的就是<code>由多个（≥1）常量（值不会改变）组成并且在编译过程中就得到计算结果的表达式</code>。</p>
<p>在介绍<code>gcc/g++工作流程</code>的时候说过，C++ 程序从编写完毕到执行分为四个阶段：<code>预处理</code>、 <code>编译</code>、<code>汇编</code>和<code>链接</code>4个阶段，得到可执行程序之后就可以运行了。需要额外强调的是，<code>常量表达式和非常量表达式的计算时机不同，非常量表达式只能在程序运行阶段计算出结果，但是常量表达式的计算往往发生在程序的编译阶段，这可以极大提高程序的执行效率，因为表达式只需要在编译阶段计算一次，节省了每次程序运行时都需要计算一次的时间。</code></p>
<p>那么问题来了，<code>编译器如何识别</code>表达式是不是常量表达式呢？在C++11中添加了 <code>constexpr</code> 关键字之后就可以在程序中使用它来修饰常量表达式，用来提高程序的执行效率。在使用中建议将 <code>const</code> 和 <code>constexpr</code> 的功能区分开，即凡是表达<code>“只读”语义</code>的场景都使用 <code>const</code>，表达<code>“常量”语义</code>的场景都使用 <code>constexpr</code>。</p>
<p>在定义常量的时候,使用<code>const</code>和<code>constexpr</code>都可以:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>          <span class="token comment">// 常量表达式</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> doubled <span class="token operator">=</span> num <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 常量表达式</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">constexpr</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>     <span class="token comment">// 常量表达式</span>
<span class="token keyword">constexpr</span> <span class="token keyword">int</span> b <span class="token operator">=</span> a <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment">// 常量表达式</span>
<span class="token keyword">constexpr</span> <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 报错 => 不能作为常量表达式,因为func()在运行时才会返回值,所以不能在编译时确定值</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>对于C++内置类型的数据,可以直接使用<code>constexpr</code>修饰,但是对于<code>自定义数据类型</code>,例如 <code>struct</code> 和 <code>class</code> 定义的结构体和类,直接使用 <code>constexpr </code>是不行的</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/* 这样会报错: constexpr无效 */</span>
<span class="token keyword">constexpr</span> <span class="token keyword">struct</span> <span class="token class-name">Person</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> age<span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果要定义一个<code>结构体/类常量对象</code>，可以这样写：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Test</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> id<span class="token punctuation">;</span>
    <span class="token keyword">int</span> num<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">constexpr</span> Test t<span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token keyword">constexpr</span> <span class="token keyword">int</span> id <span class="token operator">=</span> t<span class="token punctuation">.</span>id<span class="token punctuation">;</span>
    <span class="token keyword">constexpr</span> <span class="token keyword">int</span> num <span class="token operator">=</span> t<span class="token punctuation">.</span>num<span class="token punctuation">;</span>
    <span class="token comment">// 报错，不能修改常量</span>
    t<span class="token punctuation">.</span>num <span class="token operator">+=</span> <span class="token number">100</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"id: "</span> <span class="token operator">&lt;&lt;</span> id <span class="token operator">&lt;&lt;</span> <span class="token string">", num: "</span> <span class="token operator">&lt;&lt;</span> num <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在第13行的代码中<code>t.num += 100;</code>的操作是<strong>错误的</strong>，<strong>对象t是一个常量</strong>，因此它的成员也是常量，<code>常量是不能被修改的</code>。</p>
<h3 id="3-3-常量表达式函数"><a href="#3-3-常量表达式函数" class="headerlink" title="3.3 常量表达式函数"></a>3.3 常量表达式函数</h3><p>为了提高C++程序的执行效率，我们可以将程序中值不需要发生变化的变量定义为常量，也可以使用<code>constexpr</code>修饰某些特定函数的返回值，这种函数被称作<code>常量表达式函数</code>，这些函数主要包括以下几种：<code>普通函数/类成员函数</code>、<code>类的构造函数</code>、<code>模板函数</code>。</p>
<h4 id="a-修饰普通函数"><a href="#a-修饰普通函数" class="headerlink" title="a. 修饰普通函数"></a>a. 修饰普通函数</h4><p><code>constexpr</code>并不能任意函数的返回值，使这些函数成为<code>常量表达式函数</code>，必须满足以下条件：</p>
<ol>
<li><code>函数必须要有返回值</code>，并且<strong>return返回的表达式必须是常量表达式</strong></li>
</ol>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// error，不是常量表达式函数</span>
<span class="token keyword">constexpr</span> <span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"a: "</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// error，不是常量表达式函数</span>
<span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> a<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><strong>函数func1()没有返回值</strong>，不满足常量表达式函数要求</li>
<li><strong>函数func2()返回值不是常量表达式</strong>，不满足常量表达式函数要求</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/12/25/cpp11-xin-te-xing/constexpr%E4%B8%8D%E5%90%8C%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC.png" alt="image-20241225232916249"></p>
<p>由此可见在<code>更新的C++标准</code>里边放宽了对 <code>constexpr</code> 的语法限制。</p>
<ol start="2">
<li><code>函数在使用之前,必须有与之相对应的定义</code></li>
</ol>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">constexpr</span> <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// error</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">constexpr</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> a<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在测试程序<code>constexpr int num = func1();</code>中，还没有定义<code>func1()</code>就直接调用了，应该将<code>func1()</code>函数的定义放到<code>main()</code>函数的上边。</p>
<ol start="3">
<li>整个函数的函数体中，<code>不</code>能出现<code>非常量表达式</code>之外的语句（<code>using 指令、typedef 语句以及 static_assert 断言、return语句除外</code>）。</li>
</ol>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// error</span>
<span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">constexpr</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
    <span class="token keyword">constexpr</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> b<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"i: "</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// ok</span>
<span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">using</span> mytype <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">;</span>
    <span class="token keyword">constexpr</span> mytype a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
    <span class="token keyword">constexpr</span> mytype b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token keyword">constexpr</span> mytype c <span class="token operator">=</span> a <span class="token operator">*</span> b<span class="token punctuation">;</span>
    <span class="token keyword">return</span> c <span class="token operator">-</span> <span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在C++中，<code>constexpr</code>函数要求函数体中所有的操作都必须是常量表达式。这意味着函数体中不能包含任何运行时的操作，比如I&#x2F;O操作（如<code>cout</code>），以及任何依赖于非常量值的操作。</p>
<ul>
<li><code>func1()</code>函数中包含了一个<code>for</code>循环，并且在循环体内使用了<code>cout</code>进行输出。<code>cout</code>是一个运行时的I&#x2F;O操作，不是常量表达式，因此会导致<code>constexpr</code>函数的定义失败。即使<code>for</code>循环本身可能是基于常量表达式的，但由于包含了非<code>constexpr</code>的操作（<code>cout</code>），整个函数都不能被标记为<code>constexpr</code>。</li>
<li><code>func2()</code>函数中没有包含任何运行时的操作，所有的计算都是在编译时完成的，因此它可以被标记为<code>constexpr</code>。</li>
</ul>
<blockquote>
<p>以上三条规则不仅对于普通的函数生效，并且对于类的成员函数同样生效</p>
</blockquote>
<h4 id="b-修饰成员函数"><a href="#b-修饰成员函数" class="headerlink" title="b. 修饰成员函数"></a>b. 修饰成员函数</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Test</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">constexpr</span> <span class="token keyword">int</span> var <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">5</span> <span class="token operator">*</span> var<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Test t<span class="token punctuation">;</span>
    <span class="token keyword">constexpr</span> <span class="token keyword">int</span> num <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"num: "</span> <span class="token operator">&lt;&lt;</span> num <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="c-修饰模板函数"><a href="#c-修饰模板函数" class="headerlink" title="c. 修饰模板函数"></a>c. 修饰模板函数</h4><p>在C++中，”模板函数”指的是一种允许函数在编译时根据给定的参数类型生成特定实现的机制。这种机制使得同一个函数可以用于不同的数据类型，而不需要为每种类型编写不同的函数代码。</p>
<p>函数模板的基本语法如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">myFunction</span><span class="token punctuation">(</span>T param<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 函数体，使用T作为参数类型</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>这里的<code>template &lt;typename T&gt;</code>声明了一个模板，其中<code>T</code>是一个类型参数，可以在调用函数时指定。<code>typename</code>关键字用于指定<code>T</code>是一个类型。你也可以使用<code>class</code>关键字代替<code>typename</code>，但在现代C++中，<code>typename</code>是首选。</p>
<p>函数模板的使用示例：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
T <span class="token function">max</span><span class="token punctuation">(</span>T a<span class="token punctuation">,</span> T b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>a <span class="token operator">></span> b<span class="token punctuation">)</span> <span class="token operator">?</span> a <span class="token operator">:</span> b<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 使用int类型调用</span>
<span class="token keyword">int</span> maxInt <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 使用double类型调用</span>
<span class="token keyword">double</span> maxDouble <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token number">3.14</span><span class="token punctuation">,</span> <span class="token number">2.71</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在这个例子中，<code>max</code>函数模板可以根据传入的参数类型自动实例化出<code>int</code>和<code>double</code>版本的<code>max</code>函数。</p>
<p>函数模板也可以接受多个类型参数：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T1</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">T2</span><span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">printPair</span><span class="token punctuation">(</span><span class="token keyword">const</span> T1<span class="token operator">&amp;</span> a<span class="token punctuation">,</span> <span class="token keyword">const</span> T2<span class="token operator">&amp;</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">" and "</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 使用</span>
<span class="token function">printPair</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">3.14</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这里，<code>printPair</code>函数模板接受两个参数，这两个参数可以是不同的类型。</p>
<p>函数模板也可以使用非类型模板参数，这些参数在编译时必须是常量：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">int</span> N<span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">printArray</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">)</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 使用</span>
<span class="token keyword">int</span> myArray<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token function">printArray</span><span class="token punctuation">(</span>myArray<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在这个例子中，<code>printArray</code>函数模板接受一个数组，并使用非类型模板参数<code>N</code>来指定数组的大小。</p>
<blockquote>
<p>C++11 语法中，<code>constexpr</code> 可以修饰函数模板，但由于模板中类型的不确定性，因此函数模板实例化后的模板函数是否符合常量表达式函数的要求也是不确定的。<code>如果 constexpr 修饰的模板函数实例化结果不满足常量表达式函数的要求，则 constexpr 会被自动忽略，即该函数就等同于一个普通函数。</code></p>
</blockquote>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> name<span class="token punctuation">;</span>
    <span class="token keyword">int</span> age<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token comment">// 定义函数模板</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">constexpr</span> T <span class="token function">dispaly</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> t<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">struct</span> <span class="token class-name">Person</span> p <span class="token punctuation">&#123;</span> <span class="token string">"luffy"</span><span class="token punctuation">,</span> <span class="token number">19</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token comment">//普通函数</span>
    <span class="token keyword">struct</span> <span class="token class-name">Person</span> ret <span class="token operator">=</span> <span class="token function">dispaly</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"luffy's name: "</span> <span class="token operator">&lt;&lt;</span> ret<span class="token punctuation">.</span>name <span class="token operator">&lt;&lt;</span> <span class="token string">", age: "</span> <span class="token operator">&lt;&lt;</span> ret<span class="token punctuation">.</span>age <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token comment">//常量表达式函数</span>
    <span class="token keyword">constexpr</span> <span class="token keyword">int</span> ret1 <span class="token operator">=</span> <span class="token function">dispaly</span><span class="token punctuation">(</span><span class="token number">250</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> ret1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token keyword">constexpr</span> <span class="token keyword">struct</span> <span class="token class-name">Person</span> p1 <span class="token punctuation">&#123;</span> <span class="token string">"luffy"</span><span class="token punctuation">,</span> <span class="token number">19</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// 使用constexpr修饰， p1是一个常量表达式</span>
    <span class="token keyword">constexpr</span> <span class="token keyword">struct</span> <span class="token class-name">Person</span> p2 <span class="token operator">=</span> <span class="token function">dispaly</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"luffy's name: "</span> <span class="token operator">&lt;&lt;</span> p2<span class="token punctuation">.</span>name <span class="token operator">&lt;&lt;</span> <span class="token string">", age: "</span> <span class="token operator">&lt;&lt;</span> p2<span class="token punctuation">.</span>age <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上面示例程序中定义了一个函数模板 <code>display()</code>，但由于其返回值类型未定，因此在实例化之前无法判断其是否符合常量表达式函数的要求：</p>
<ul>
<li><code>struct Person ret = dispaly(p);</code> 由于参数<code>p</code>是变量，所以实例化后的函数不是常量表达式函数，此时<code>constexpr</code>是无效的</li>
<li><code>constexpr int ret1 = dispaly(250);</code> 参数是常量，符合常量表达式函数的要求，此时<code>constexpr</code>是有效的</li>
<li><code>constexpr struct Person p2 = dispaly(p1);</code> 参数是常量，符合常量表达式函数的要求，此时<code>constexpr</code>是有效的</li>
</ul>
<h4 id="d-修饰构造函数"><a href="#d-修饰构造函数" class="headerlink" title="d. 修饰构造函数"></a>d. 修饰构造函数</h4><p>在C++中，<code>constexpr</code>构造函数允许在编译时初始化对象，这意味着构造函数创建的对象可以被用作常量表达式的一部分。这对于创建在编译时就需要确定值的<code>常量对象</code>非常有用。</p>
<ol>
<li><strong>构造函数的参数必须是常量表达式</strong>：<ul>
<li><code>constexpr</code> 构造函数的参数应当是可以在编译时求值的常量。例如，基本数据类型的常量、常量变量和字面量等。</li>
</ul>
</li>
<li><strong>函数体必须包含允许的操作</strong>：<ul>
<li><code>constexpr</code> 构造函数的函数体必须仅包含可以在编译时执行的表达式。这意味着不能使用诸如动态内存分配、输入输出等运行时操作。</li>
</ul>
</li>
<li><strong>以常量对象的形式使用</strong>：<ul>
<li>构造函数的结果必须是用于创建一个常量对象，可以是 <code>constexpr</code> 变量或用 <code>constexpr</code> 表达式初始化的对象。</li>
</ul>
</li>
<li><strong>返回类型</strong>：<ul>
<li><code>constexpr</code> 构造函数的返回类型必须是该类类型，即生成的对象类型</li>
</ul>
</li>
</ol>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>

<span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment">// 常量表达式构造函数</span>
    <span class="token keyword">constexpr</span> <span class="token function">Point</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">x_</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">y_</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

    <span class="token comment">// 获取 x 和 y 的常量成员函数</span>
    <span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> x_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>
    <span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">getY</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> y_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> x_<span class="token punctuation">;</span>
    <span class="token keyword">int</span> y_<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 在编译时创建常量对象</span>
    <span class="token keyword">constexpr</span> Point <span class="token function">p</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 输出常量对象的值</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Point: ("</span> <span class="token operator">&lt;&lt;</span> p<span class="token punctuation">.</span><span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span> <span class="token operator">&lt;&lt;</span> p<span class="token punctuation">.</span><span class="token function">getY</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">")"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="4-auto类型推导"><a href="#4-auto类型推导" class="headerlink" title="4.auto类型推导"></a>4.auto类型推导</h2><p>在C++11中，可以使用<code>auto</code>来自动推测变量的类型，还可以结合使用<code>decltype</code>关键字来推测函数或者表达式的返回值。允许程序员编写更灵活和通用的代码，尤其是在模板编程中。通过<code>decltype</code>，我们可以避免显式指定类型，从而减少代码的复杂性，并提高代码的可读性和可维护性。</p>
<h3 id="4-1-auto的推导规则"><a href="#4-1-auto的推导规则" class="headerlink" title="4.1 auto的推导规则"></a>4.1 auto的推导规则</h3><p>在<code>C++11之前</code>，<code>auto</code>关键字用于声明<code>自动存储期</code>的变量，但由于非<code>static</code>的局部变量默认就是自动存储期的，所以这个关键字的使用变得不那么常见。</p>
<p>C++11引入了新的<code>auto</code>关键字用法，它主要用于<code>自动类型推导</code>，使得程序员可以不必显式声明变量的类型，而让编译器根据<code>变量的初始值</code>自动推导出类型。</p>
<h4 id="a-自动存储期"><a href="#a-自动存储期" class="headerlink" title="a. 自动存储期"></a>a. 自动存储期</h4><p>在C++中，<code>自动存储期（Automatic Storage Duration）</code>是指变量的生命周期，它描述了变量在程序执行过程中存在的时间。具有自动存储期的变量通常是在函数或代码块内部定义的局部变量，它们在定义它们的代码块被执行时创建，在代码块执行结束时销毁。</p>
<p>以下是自动存储期的一些特点：</p>
<ol>
<li><p><strong>局部作用域</strong>：</p>
<ul>
<li>自动存储期的变量具有局部作用域，它们只能在定义它们的函数或代码块内部被访问。</li>
</ul>
</li>
<li><p><strong>栈内存分配</strong>：</p>
<ul>
<li>这些变量通常在栈（stack）上分配内存。当函数被调用时，局部变量的内存被分配；当函数返回时，这些内存被释放。</li>
</ul>
</li>
<li><p><strong>生命周期</strong>：</p>
<ul>
<li>自动存储期的变量的生命周期仅限于它们被定义的代码块。一旦代码块执行结束，这些变量就会被销毁，它们的内存空间会被回收。</li>
</ul>
</li>
<li><p><strong>初始化</strong>：</p>
<ul>
<li>在C++中，局部变量（具有自动存储期的变量）不会自动初始化。如果它们没有被显式初始化，它们的值是未定义的。</li>
</ul>
</li>
<li><p><strong>与静态存储期的区别</strong>：</p>
<ul>
<li>与自动存储期相对的是静态存储期（Static Storage Duration），具有静态存储期的变量在程序的整个运行期间都存在，它们通常在全局区域或在函数外部定义。</li>
</ul>
</li>
<li><p><strong>例子</strong>：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> localVariable<span class="token punctuation">;</span> <span class="token comment">// 自动存储期的局部变量，未初始化，其值是未定义的</span>
    localVariable <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">// 初始化后，可以安全使用</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这个例子中，<code>localVariable</code>是一个局部变量，它具有自动存储期。它只在<code>function</code>函数内部有效，并且在函数结束时被销毁。</p>
</li>
</ol>
<h4 id="b-auto的推导规则"><a href="#b-auto的推导规则" class="headerlink" title="b. auto的推导规则"></a>b. auto的推导规则</h4><p>C++11 中 auto 并不代表一种实际的数据类型，只是一个类型声明的 “占位符”，auto并不是万能的在任意场景下都能够推导出变量的实际类型，<code>使用auto声明的变量必须要进行初始化，以让编译器推导出它的实际类型，在编译时将auto占位符替换为真正的类型</code>。使用语法如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> 变量名 <span class="token operator">=</span> 变量值<span class="token punctuation">;</span> 

<span class="token keyword">auto</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token comment">// x会被推导为int类型</span>
<span class="token keyword">auto</span> y <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span>      <span class="token comment">// y会被推导为double类型</span>
<span class="token keyword">auto</span> z <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>   <span class="token comment">// z会被推导为const char[]类型</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>不仅如此，auto还可以和指针、引用结合起来使用也可以带上<code>const</code>、<code>volatile限定符</code>，在不同的场景下有对应的推导规则，规则内容如下：</p>
<ul>
<li>当变量<strong>不是指针或者引用类型</strong>时，推导的结果中不会保留<code>const</code>、<code>volatile</code>关键字</li>
<li>当变量<strong>是指针或者引用类型</strong>时，推导的结果中会保留<code>const</code>、<code>volatile</code>关键字</li>
<li><code>volatile</code>关键字用于告诉编译器该变量可能会被程序之外的因素（如硬件或其他线程）改变，因此编译器需要在每次访问该变量时从内存中重新读取其值，而不是使用寄存器中的值。</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> temp <span class="token operator">=</span> <span class="token number">150</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> <span class="token operator">*</span>a <span class="token operator">=</span> <span class="token operator">&amp;</span>temp<span class="token punctuation">;</span>   <span class="token comment">// 变量a的数据类型为 int*，因此auto关键字被推导为 int类型</span>
<span class="token keyword">auto</span> b <span class="token operator">=</span> <span class="token operator">&amp;</span>temp<span class="token punctuation">;</span>    <span class="token comment">// 变量b的数据类型为 int*，因此auto关键字被推导为 int*类型</span>
<span class="token keyword">auto</span> <span class="token operator">&amp;</span>c <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token comment">// 变量c的数据类型为 int&amp;，因此auto关键字被推导为 int类型</span>
<span class="token keyword">auto</span> d <span class="token operator">=</span> temp<span class="token punctuation">;</span>     <span class="token comment">// 变量d的数据类型为 int，因此auto关键字被推导为 int类型</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> tmp <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">auto</span> a1 <span class="token operator">=</span> tmp<span class="token punctuation">;</span>       
<span class="token keyword">auto</span> a2 <span class="token operator">=</span> a1<span class="token punctuation">;</span>              
<span class="token keyword">const</span> <span class="token keyword">auto</span> <span class="token operator">&amp;</span>a3 <span class="token operator">=</span> tmp<span class="token punctuation">;</span>      
<span class="token keyword">auto</span> <span class="token operator">&amp;</span>a4 <span class="token operator">=</span> a3<span class="token punctuation">;</span>             <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>变量<strong>a1</strong>的数据类型为 <code>const int</code>，因此auto关键字被推导为 <code>int类型</code></li>
<li>变量<strong>a2</strong>的数据类型为 <code>int</code>，但是a2<code>没有声明为指针或引用</code>因此 const属性被去掉, auto被推导为 <code>int</code></li>
<li>变量<strong>a3</strong>的数据类型为 <code>const int&amp;</code>，a3被声明为<code>引用</code>因此 const属性被保留，auto关键字被推导为 <code>int类型</code></li>
<li>变量<strong>a4</strong>的数据类型为 <code>const int&amp;</code>，a4被声明为<code>引用</code>因此 const属性被保留，auto关键字被推导为 <code>const int类型</code></li>
</ul>
<h3 id="4-2-auto的限制"><a href="#4-2-auto的限制" class="headerlink" title="4.2 auto的限制"></a>4.2 auto的限制</h3><p><code>auto</code>的类型推导并不是万能的，对于在<code>编译时无法完成类型推导的情况</code>，不能使用自动推导</p>
<ol>
<li><code>auto</code>不能作为函数的参数使用，因为C++中，函数参数的类型必须在编译时已知。<code>auto</code>是一个类型推导关键字，它依赖于初始化表达式来确定具体的类型，这意味着<code>auto</code>需要在变量声明时立即跟随一个初始化表达式，以便编译器可以推导出类型。</li>
</ol>
<blockquote>
<p>因为只有在函数调用的时候才函数参数传递实参，auto 要求必须要给修饰的变量赋值，因此二者矛盾</p>
</blockquote>
  <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">auto</span> a<span class="token punctuation">,</span> <span class="token keyword">auto</span> b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">// 错误</span>
    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<ol start="2">
<li><code>auto</code>不能用于<code>非静态成员</code>的初始化，这是因为<code>非静态成员</code>是属于类的实例对象的，而对象需要在程序运行时才会被创建，所以不能使用自动类型推导</li>
</ol>
  <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">auto</span> age <span class="token operator">=</span> <span class="token number">18</span><span class="token punctuation">;</span> <span class="token comment">// 错误</span>
    <span class="token keyword">static</span> <span class="token keyword">auto</span> name <span class="token operator">=</span> <span class="token string">"Tom"</span><span class="token punctuation">;</span> <span class="token comment">// 错误，类的静态非常量成员不允许在类内部直接初始化</span>
    <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">auto</span> sex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 正确，</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ol start="3">
<li>不能使用<code>auto</code>关键字<code>定义数组</code></li>
</ol>
  <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// 定义数组</span>
    <span class="token keyword">auto</span> t1 <span class="token operator">=</span> array<span class="token punctuation">;</span>               <span class="token comment">// ok, t1被推导为 int* 类型</span>
    <span class="token keyword">auto</span> t2<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">;</span>             <span class="token comment">// error, auto无法定义数组</span>
    <span class="token keyword">auto</span> t3<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>   <span class="token comment">// error, auto无法定义数组</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ol start="4">
<li>不能用于<code>模板参数的推导</code>，在C++中，<code>auto</code>关键字用于自动类型推导，但它不能用于模板参数的推导。这是因为模板参数需要在编译时就确定，而<code>auto</code>的类型推导依赖于初始化表达式的类型，这通常在模板实例化时已经太晚了。</li>
</ol>
  <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">struct</span> <span class="token class-name">Test</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Test<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span> t<span class="token punctuation">;</span>
    Test<span class="token operator">&lt;</span><span class="token keyword">auto</span><span class="token operator">></span> t1 <span class="token operator">=</span> t<span class="token punctuation">;</span> <span class="token comment">// error, 无法推导出模板类型</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="4-3-auto的应用"><a href="#4-3-auto的应用" class="headerlink" title="4.3 auto的应用"></a>4.3 auto的应用</h3><p><code>auto</code> 关键字在 C++ 中主要用于自动类型推导，它可以在多种场景下简化代码和提高代码的可读性。以下是一些常见的应用场景：</p>
<ol>
<li><code>遍历容器</code></li>
</ol>
<p>当遍历标准库容器（如 <code>std::vector</code>、<code>std::list</code>、<code>std::map</code> 等）时，<code>auto</code> 可以用来简化迭代器的类型。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> vec <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">=</span> vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> vec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>it<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>it <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">// 输出：1 2 3 4 5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ol start="2">
<li><code>简化复杂类型</code></li>
</ol>
<p>对于复杂的类型，如嵌套的模板或自定义类型的嵌套定义，<code>auto</code> 可以减少代码的复杂性。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>map<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> myMap<span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> pair <span class="token operator">:</span> myMap<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> pair<span class="token punctuation">.</span>first <span class="token operator">&lt;&lt;</span> <span class="token string">": "</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> num <span class="token operator">:</span> pair<span class="token punctuation">.</span>second<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> num <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ol start="3">
<li><code>函数返回值</code></li>
</ol>
<p>当函数返回复杂类型时，<code>auto</code> 可以用来简化函数调用。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">getVector</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">auto</span> vec <span class="token operator">=</span> <span class="token function">getVector</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// vec 的类型被推导为 std::vector&lt;int></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ol start="4">
<li><code>Lambda 表达式</code></li>
</ol>
<p>在 Lambda 表达式中，<code>auto</code> 可以用来推导捕获的变量类型。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> lambda <span class="token operator">=</span> <span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> x<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<ol start="5">
<li><code>初始化列表</code></li>
</ol>
<p>使用花括号初始化列表时，<code>auto</code> 可以用来推导数组或 <code>std::vector</code> 的类型。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> arr <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// arr 的类型被推导为 std::initializer_list&lt;int></span>
<span class="token keyword">auto</span> vec <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// vec 的类型被推导为 std::vector&lt;int></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<ol start="6">
<li><code>智能指针</code></li>
</ol>
<p>当使用智能指针如 <code>std::unique_ptr</code> 或 <code>std::shared_ptr</code> 时，<code>auto</code> 可以简化类型声明。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> ptr <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_unique</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ptr 的类型被推导为 std::unique_ptr&lt;int></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ol start="7">
<li><code>泛型编程</code></li>
</ol>
<p>在模板编程中，<code>auto</code> 可以用来推导模板实例化的具体类型。在使用模板的时候，很多情况下我们不知道变量应该定义为什么类型</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">T1</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">T2</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">static</span> string <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token string">"hello, world"</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">auto</span> val <span class="token operator">=</span> <span class="token class-name">A</span><span class="token double-colon punctuation">::</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"val: "</span> <span class="token operator">&lt;&lt;</span> val <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token generic-function"><span class="token function">func</span><span class="token generic class-name"><span class="token operator">&lt;</span>T1<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token generic-function"><span class="token function">func</span><span class="token generic class-name"><span class="token operator">&lt;</span>T2<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ol start="8">
<li><code>错误处理</code></li>
</ol>
<p>在处理异常和错误代码时，<code>auto</code> 可以用来简化错误类型的处理。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> error <span class="token operator">=</span> <span class="token function">someFunctionThatReturnsErrorCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>error <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    std<span class="token double-colon punctuation">::</span>cerr <span class="token operator">&lt;&lt;</span> <span class="token string">"Error occurred: "</span> <span class="token operator">&lt;&lt;</span> error <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="4-4-decltype关键字"><a href="#4-4-decltype关键字" class="headerlink" title="4.4 decltype关键字"></a>4.4 decltype关键字</h3><p><code>decltype</code>的作用是在不需要或者不能进行<code>表达式的计算</code>的时候，希望能够得到表达式的<code>结果类型</code>，这个时候就可以运用到<code>decltype关键字</code>了，语法如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">decltype</span> <span class="token punctuation">(</span>表达式<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><code>decltype</code>是<code>declare type</code>声明类型的缩写，其推导是在<code>编译期</code>完成的，它只用于表达式类型的推导，不会在内部进行计算表达式的值。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">auto</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token keyword">decltype</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> b <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>               <span class="token comment">// int</span>
    <span class="token keyword">decltype</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> c <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>            <span class="token comment">// int</span>
    <span class="token keyword">decltype</span><span class="token punctuation">(</span>b <span class="token operator">*</span> <span class="token number">10.25</span> <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">)</span> d <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token comment">// double</span>

    <span class="token comment">// 输出类型</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Type of a: "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Type of b: "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Type of c: "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Type of d: "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="4-5-decltype的推导规则"><a href="#4-5-decltype的推导规则" class="headerlink" title="4.5 decltype的推导规则"></a>4.5 decltype的推导规则</h3><ol>
<li>表达式为<code>普通变量</code>或者<code>普通表达式</code>或者<code>类表达式(有类的限定的或者对象参与的)</code>，在这种情况下，使用<strong>decltype推导出的类型和表达式的类型是一致的</strong>。</li>
</ol>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Test</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    string text<span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">110</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">99</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>y <span class="token operator">=</span> x<span class="token punctuation">;</span>
    <span class="token keyword">decltype</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> a <span class="token operator">=</span> x<span class="token punctuation">;</span>
    <span class="token keyword">decltype</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> b <span class="token operator">=</span> x<span class="token punctuation">;</span>
    <span class="token keyword">decltype</span><span class="token punctuation">(</span>Test<span class="token double-colon punctuation">::</span>value<span class="token punctuation">)</span> c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    Test t<span class="token punctuation">;</span>
    <span class="token keyword">decltype</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>text<span class="token punctuation">)</span> d <span class="token operator">=</span> <span class="token string">"hello, world"</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>变量<code>a</code>被推导为 <code>int</code>类型</li>
<li>变量<code>b</code>被推导为 <code>const int &amp;</code> 类型</li>
<li>变量<code>c</code>被推导为 <code>const int</code> 类型</li>
<li>变量<code>d</code>被推导为 <code>string</code> 类型</li>
</ul>
<ol start="2">
<li>表达式是<code>函数调用</code>，使用 <strong>decltype 推导出的类型和函数返回值一致。</strong>(有一个特殊,纯右值)</li>
</ol>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token comment">//函数声明</span>
<span class="token keyword">int</span> <span class="token function">func_int</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">// 返回值为 int</span>
<span class="token keyword">int</span><span class="token operator">&amp;</span> <span class="token function">func_int_r</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">// 返回值为 int&amp;</span>
<span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> <span class="token function">func_int_rr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 返回值为 int&amp;&amp;</span>

<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token function">func_cint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 返回值为 const int</span>
<span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> <span class="token function">func_cint_r</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 返回值为 const int&amp;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> <span class="token function">func_cint_rr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 返回值为 const int&amp;&amp;</span>

<span class="token keyword">const</span> Test <span class="token function">func_ctest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 返回值为 const Test</span>

<span class="token comment">//decltype类型推导</span>
<span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">func_int</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>		
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">func_int_r</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> b <span class="token operator">=</span> n<span class="token punctuation">;</span>	
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">func_int_rr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>	
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">func_cint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> d <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>	
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">func_cint_r</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> e <span class="token operator">=</span> n<span class="token punctuation">;</span>	
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">func_cint_rr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> f <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>	
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">func_ctest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> g <span class="token operator">=</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>变量<code>a</code>被推导为 <code>int </code>类型</li>
<li>变量<code>b</code>被推导为 <code>int&amp; </code>类型</li>
<li>变量<code>c</code>被推导为 <code>int&amp;&amp;</code> 类型</li>
<li>变量<code>d</code>被推导为 <code>int</code> 类型</li>
<li>变量<code>e</code>被推导为 <code>const int &amp;</code> 类型</li>
<li>变量<code>f</code>被推导为 <code>const int &amp;&amp;</code> 类型</li>
<li>变量<code>g</code>被推导为 <code>const Test</code> 类型</li>
</ul>
<p>函数 <code>func_cint()</code> 返回的是一个<code>纯右值</code>（<strong>在表达式执行结束后不再存在的数据，也就是临时性的数据，或者例如字面量</strong>），<code>对于纯右值而言，只有类类型可以携带const</code>、<code>volatile限定符</code>，除此之外需要忽略掉这两个限定符，因此推导出的变量 <code>d</code> 的类型为 <code>int</code> 而不是 <code>const int</code>。</p>
<ol start="3">
<li><code>表达式是一个左值，或者被括号( )包围</code>，使用 <code>decltype</code> 推导出的是表达式类型的引用（如果有<code>const、volatile限定符</code>不能忽略）。</li>
</ol>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Test</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> num<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">const</span> Test obj<span class="token punctuation">;</span>
    <span class="token comment">//带有括号的表达式</span>
    <span class="token comment">// a : int</span>
    <span class="token keyword">decltype</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>num<span class="token punctuation">)</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">// b : const int&amp;</span>
    <span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>
    <span class="token comment">//加法表达式</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> m <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">// c : int </span>
    <span class="token keyword">decltype</span><span class="token punctuation">(</span>n <span class="token operator">+</span> m<span class="token punctuation">)</span> c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">// n+m最后保存在n中,n是可以取地址的左值,所以 d : int&amp;</span>
    <span class="token keyword">decltype</span><span class="token punctuation">(</span>n <span class="token operator">=</span> n <span class="token operator">+</span> m<span class="token punctuation">)</span> d <span class="token operator">=</span> n<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="4-6-decltype在泛型编程的应用"><a href="#4-6-decltype在泛型编程的应用" class="headerlink" title="4.6 decltype在泛型编程的应用"></a>4.6 decltype在泛型编程的应用</h3><p>关于decltype的应用多出现在<code>泛型编程</code>中。比如我们编写一个类模板，在里边添加遍历容器的函数，操作如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;list></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">class</span> <span class="token class-name">Container</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> c<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>m_it <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> m_it <span class="token operator">!=</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>m_it<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>m_it <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token operator">?</span><span class="token operator">?</span><span class="token operator">?</span> m_it<span class="token punctuation">;</span>  <span class="token comment">// 这里不能确定迭代器类型</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">const</span> list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> lst<span class="token punctuation">;</span>
    Container<span class="token operator">&lt;</span><span class="token keyword">const</span> list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> obj<span class="token punctuation">;</span>
    obj<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span>lst<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在程序的<strong>第17行</strong>出了问题，关于迭代器变量一共有两种类型：<code>只读（T::const_iterator）</code>和<code>读写（T::iterator）</code>，有了<code>decltype</code>就可以完美的解决这个问题了，当 T 是一个 非 const 容器得到一个 T::iterator，当 T 是一个 const 容器时就会得到一个<code>T::const_iterator</code>。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;list></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">class</span> <span class="token class-name">Container</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> c<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>m_it <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> m_it <span class="token operator">!=</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>m_it<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>m_it <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> m_it<span class="token punctuation">;</span>  <span class="token comment">// 这里不能确定迭代器类型</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">const</span> list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> lst<span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    Container<span class="token operator">&lt;</span><span class="token keyword">const</span> list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> obj<span class="token punctuation">;</span>
    obj<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span>lst<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p><code>decltype(*T*().begin()) iter; // 推导出对应的容器的迭代器类型</code></p>
</blockquote>
<h3 id="4-7-返回类型的后置-声明返回类型"><a href="#4-7-返回类型的后置-声明返回类型" class="headerlink" title="4.7 返回类型的后置(声明返回类型?)"></a>4.7 返回类型的后置(声明返回类型?)</h3><p>在泛型编程中，可能需要通过<code>参数的运算</code>来得到<code>返回值的类型</code>，比如下面这个场景：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token comment">// R->返回值类型, T->参数1类型, U->参数2类型</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">R</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">U</span><span class="token operator">></span>
R <span class="token function">add</span><span class="token punctuation">(</span>T t<span class="token punctuation">,</span> U u<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> t <span class="token operator">+</span> u<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">520</span><span class="token punctuation">;</span>
    <span class="token keyword">double</span> y <span class="token operator">=</span> <span class="token number">13.14</span><span class="token punctuation">;</span>
    <span class="token comment">// auto z = add&lt;decltype(x + y), int, double>(x, y);</span>
    <span class="token keyword">auto</span> z <span class="token operator">=</span> <span class="token generic-function"><span class="token function">add</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>x <span class="token operator">+</span> y<span class="token punctuation">)</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 简化之后的写法</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"z: "</span> <span class="token operator">&lt;&lt;</span> z <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>关于返回值，从上面的代码可以推断出和表达式 <code>t+u</code> 的结果类型是一样的，因此可以通过通过<code>decltype</code>进行推导，关于模板函数的参数<code>t</code>和<code>u</code>可以通过实参自动推导出来，因此在程序中就也可以不写。虽然通过上述方式问题被解决了，但是解决方案有点过于理想化，因为对于调用者来说，是不知道函数内部执行了什么样的处理动作的。(如例子中的 <code>t + u</code>,自然也不能通过<code>decltype</code>来声明表达式类型)</p>
<p>因此如果要想解决这个问题就得直接在 <code>add()</code> 函数身上做文章，自然而然地想到在<code>函数声明</code>的时候使用<strong>decltype来推导返回值类型</strong></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">U</span><span class="token operator">></span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span>t<span class="token operator">+</span>u<span class="token punctuation">)</span> <span class="token function">add</span><span class="token punctuation">(</span>T t<span class="token punctuation">,</span> U u<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> t <span class="token operator">+</span> u<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>但这样显然是错误的,因为decltype中的 t 和 u 都是函数参数，直接这样写相当于变量还没有定义就直接用上了，这时候变量还不存在，有点心急了。</p>
</blockquote>
<p>在C++11中增加了<code>返回类型后置语法</code>，说明白一点就是将<code>decltype和auto结合起来完成返回类型的推导</code>。其语法格式如下:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 符号 -> 后边跟随的是函数返回值的类型</span>
<span class="token keyword">auto</span> <span class="token function">func</span><span class="token punctuation">(</span>参数<span class="token number">1</span><span class="token punctuation">,</span> 参数<span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>参数表达式<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>通过对上述返回类型后置语法代码的分析，得到结论：<code>auto 会追踪 decltype() 推导出的类型</code>，因此上边的<code>add()函数</code>可以做如下的修改：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">U</span><span class="token operator">></span>
<span class="token comment">// 返回类型后置语法</span>
<span class="token keyword">auto</span> <span class="token function">add</span><span class="token punctuation">(</span>T t<span class="token punctuation">,</span> U u<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>t<span class="token operator">+</span>u<span class="token punctuation">)</span>  <span class="token comment">// 声明函数时就设定返回的类型由t+u推导出来</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> t <span class="token operator">+</span> u<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">520</span><span class="token punctuation">;</span>
    <span class="token keyword">double</span> y <span class="token operator">=</span> <span class="token number">13.14</span><span class="token punctuation">;</span>
    <span class="token comment">// auto z = add&lt;int, double>(x, y);</span>
    <span class="token keyword">auto</span> z <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// 简化之后的写法</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"z: "</span> <span class="token operator">&lt;&lt;</span> z <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>为了进一步说明这个语法，我们再看一个例子：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span><span class="token operator">&amp;</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>i<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> i<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">double</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">double</span> <span class="token operator">&amp;</span>d<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    d <span class="token operator">=</span> d <span class="token operator">+</span> <span class="token number">100</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> d<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token comment">// 返回类型后置语法</span>
<span class="token keyword">auto</span> <span class="token function">myFunc</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> t<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">test</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token function">test</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">520</span><span class="token punctuation">;</span>
    <span class="token keyword">double</span> y <span class="token operator">=</span> <span class="token number">13.14</span><span class="token punctuation">;</span>
    <span class="token comment">// auto z = myFunc&lt;int>(x);</span>
    <span class="token keyword">auto</span> z <span class="token operator">=</span> <span class="token function">myFunc</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">// 简化之后的写法</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"z: "</span> <span class="token operator">&lt;&lt;</span> z <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token comment">// auto z = myFunc&lt;double>(y);</span>
    <span class="token keyword">auto</span> z1 <span class="token operator">=</span> <span class="token function">myFunc</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 简化之后的写法</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"z1: "</span> <span class="token operator">&lt;&lt;</span> z1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在这个例子中，通过<code>decltype结合返回值后置</code>语法很容易推导出来, <code>test(t)</code>函数可能出现的返回值类型，并将其作用到了函数<code>myFunc()</code>上。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 输出结果</span>
z<span class="token operator">:</span> <span class="token number">520</span>
z1<span class="token operator">:</span> <span class="token number">113.14</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h2 id="5-final和override"><a href="#5-final和override" class="headerlink" title="5. final和override"></a>5. final和override</h2><p>C++ 中增加了 <code>final 关键字</code>来 <code>限制某个类不能被继承</code>，或者<code>某个虚函数不能被重写</code>，和 <code>Java</code> 的 final 关键字的功能是类似的。<br>如果使用 final 修饰函数，只能<code>修饰虚函数</code>，并且 要把 <code>final关键字放到类或者函数的后面。</code></p>
<h3 id="5-1-final-修饰函数"><a href="#5-1-final-修饰函数" class="headerlink" title="5.1 final 修饰函数"></a>5.1 final 修饰函数</h3><p>如果使用<code>final</code>修饰函数，只能<code>修饰虚函数</code>，这样就能<strong>阻止子类重写父类的这个函数</strong>了：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Base class..."</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">final</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Child class..."</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">GrandChild</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Child</span></span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment">// 语法错误, 不允许重写</span>
    <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"GrandChild class..."</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="5-2-final-修饰类"><a href="#5-2-final-修饰类" class="headerlink" title="5.2 final 修饰类"></a>5.2 final 修饰类</h3><p>使用<code>final关键字</code>修饰过的类是<code>不允许被继承</code>的，也就是说这个类<strong>不能有派生类</strong>。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Person</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                                                 <span class="token comment">// 定义纯虚函数</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">finalRun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">final</span> <span class="token punctuation">&#123;</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Person::finalRun()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">// 定义final修饰的虚函数</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">SportsMan</span> <span class="token keyword">final</span> <span class="token operator">:</span> <span class="token keyword">public</span> Person
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">override</span> <span class="token punctuation">&#123;</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"SportsMan::run()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>
    <span class="token keyword">void</span> <span class="token function">finalRun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">override</span> <span class="token punctuation">&#123;</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"SportsMan::finalRun()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">// 无法重写final修饰的虚函数</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">FinalAthlete</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">SportsMan</span> <span class="token comment">// 不允许继承final修饰的类</span></span>
<span class="token punctuation">&#123;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="5-3-overide"><a href="#5-3-overide" class="headerlink" title="5.3 overide"></a>5.3 overide</h3><p><code>override关键字</code>确保在派生类中声明的重写函数与基类的虚函数有<strong>相同的签名</strong>，同时也明确<code>表明</code>将会重写基类的虚函数，这样就可以保证重写的虚函数的正确性，也提高了代码的可读性，和<code>final</code>一样这个关键字要写到方法的后面。使用方法如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Object_My</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">print_a</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Object_My::print_a()"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">ClassA</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Object_My</span></span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">override</span>
    <span class="token punctuation">&#123;</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ClassA::print()"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Object_My <span class="token operator">*</span>obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ClassA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将子类对象指针指向父类对象,用来实现多态</span>
    obj<span class="token operator">-></span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment">// 子类虚函数表寻址,调用子类的print()函数</span>
    obj<span class="token operator">-></span><span class="token function">print_a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 调用父类的print_a()函数,因为子类没有重写该函数</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="6-模板的优化"><a href="#6-模板的优化" class="headerlink" title="6. 模板的优化"></a>6. 模板的优化</h2><h3 id="6-1-模板嵌套右尖括号的优化"><a href="#6-1-模板嵌套右尖括号的优化" class="headerlink" title="6.1 模板嵌套右尖括号的优化"></a>6.1 模板嵌套右尖括号的优化</h3><p>在泛型编程中，模板实例化有一个非常繁琐的地方，那就是<code>连续的两个右尖括号（&gt;&gt;）</code>会被编译器解析成<code>右移操作符</code>，而不是模板参数表的结束。我们先来看一段关于容器遍历的代码，在创建的类模板<code>Base</code>中提供了遍历容器的操作函数<code>traversal()</code>:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// test.cpp</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">class</span> <span class="token class-name">Base</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">traversal</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> t<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">auto</span> it <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> t<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>it<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>it <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>


<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v<span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    Base<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> b<span class="token punctuation">;</span>
    b<span class="token punctuation">.</span><span class="token function">traversal</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果使用<code>C++98/03</code>标准来编译上边的这段代码，就会得到如下的错误提示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">test.cpp:25:20: error: <span class="token string">'>>'</span> should be <span class="token string">'> >'</span> within a nested template argument list
     Base<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>int<span class="token operator">>></span> b<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>根据错误提示中描述模板的两个右尖括之间需要<strong>添加空格</strong>，这样写起来就非常的麻烦，<code>C++11</code>改进了编译器的解析规则，尽可能地将<code>多个右尖括号（&gt;）解析成模板参数结束符</code>，方便我们编写模板相关的代码。</p>
<p>上面的这段代码，在支持C++11的编译器中编译是没有任何问题的，如果使用g++直接编译需要加参数<code>-std=c++11</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">g++ test.cpp <span class="token parameter variable">-std</span><span class="token operator">=</span>c++11 <span class="token parameter variable">-o</span> app<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="6-2-默认模板参数"><a href="#6-2-默认模板参数" class="headerlink" title="6.2 默认模板参数"></a>6.2 默认模板参数</h3><p>在<code>C++98/03</code>标准中，<code>类模板</code>可以有默认的模板参数：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">=</span><span class="token keyword">int</span><span class="token punctuation">,</span> T t<span class="token operator">=</span><span class="token number">520</span><span class="token operator">></span>
<span class="token keyword">class</span> <span class="token class-name">Test</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"current value: "</span> <span class="token operator">&lt;&lt;</span> t <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Test<span class="token operator">&lt;</span><span class="token operator">></span> t<span class="token punctuation">;</span>
    t<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    Test<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token number">1024</span><span class="token operator">></span> t1<span class="token punctuation">;</span>
    t1<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>但是不支持函数的默认模板参数，在C++11中添加了对<code>函数模板</code>默认参数的支持:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">=</span><span class="token keyword">int</span><span class="token operator">></span>	<span class="token comment">// C++98/03不支持这种写法, C++11中支持这种写法</span>
<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"current value: "</span> <span class="token operator">&lt;&lt;</span> t <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">func</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>通过上面的例子可以得到如下结论：当<code>所有模板参数都有默认参数时，函数模板的调用如同一个普通函数</code>。但对于<code>类模板</code>而言，哪怕所有参数都有<strong>默认参数</strong>，在使用时也必须在模板名后跟随<code>&lt; &gt;</code>来实例化。</p>
<p><strong>另外：</strong>函数模板的默认模板参数在使用规则上和其他的默认参数也有一些不同，它没有必须写在<code>参数表最后的限制</code>。这样当默认模板参数和模板参数<code>自动推导</code>结合起来时，书写就显得非常灵活了。我们可以指定函数模板中的<strong>一部分模板参数使用默认参数，另一部分使用自动推导</strong>, 像下面的例子:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span> <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">,</span> T t <span class="token operator">=</span> <span class="token number">520</span><span class="token operator">></span>
<span class="token keyword">class</span> <span class="token class-name">Test</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"current value: "</span> <span class="token operator">&lt;&lt;</span> t <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span> <span class="token operator">=</span> <span class="token keyword">long</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">U</span> <span class="token operator">=</span> <span class="token keyword">int</span><span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">myTest</span><span class="token punctuation">(</span>T t <span class="token operator">=</span> <span class="token char">'A'</span><span class="token punctuation">,</span> U u <span class="token operator">=</span> <span class="token char">'B'</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"t = "</span> <span class="token operator">&lt;&lt;</span> t <span class="token operator">&lt;&lt;</span> <span class="token string">", u = "</span> <span class="token operator">&lt;&lt;</span> u <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 默认会将'A'和'B'转换为long, int类型</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span> y <span class="token operator">=</span> <span class="token number">10.0</span><span class="token punctuation">)</span> <span class="token comment">// 要么全部指定参数,要么将默认参数放在后面</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Test<span class="token operator">&lt;</span><span class="token operator">></span> t2<span class="token punctuation">;</span>
    t2<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    Test<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token number">1024</span><span class="token operator">></span> t1<span class="token punctuation">;</span>
    t1<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"==========\n"</span><span class="token punctuation">;</span>
    <span class="token function">myTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token comment">// 使用默认模板参数和默认函数参数</span>
    <span class="token function">myTest</span><span class="token punctuation">(</span><span class="token number">123L</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment">// 使用默认的 U 类型和自定义的 T 类型（long）</span>
    <span class="token generic-function"><span class="token function">myTest</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token char">'C'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment">// 使用自定义的 T 类型（char）和默认的 U 类型（int）</span>
    <span class="token generic-function"><span class="token function">myTest</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">,</span> <span class="token number">3.14f</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 完全指定模板参数和默认函数参数</span>

    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"==========\n"</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>       <span class="token comment">// 使用默认参数</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">25.0</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 自定义参数</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>对于上述调用，<strong>输出将是：</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">current value: <span class="token number">520</span>
current value: <span class="token number">1024</span>
<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>
t <span class="token operator">=</span> <span class="token number">65</span>, u <span class="token operator">=</span> <span class="token number">66</span>  // <span class="token string">'A'</span> 和 <span class="token string">'B'</span> 的 ASCII 值
t <span class="token operator">=</span> <span class="token number">123</span>, u <span class="token operator">=</span> <span class="token number">66</span> // <span class="token number">123</span> 是 long 类型，<span class="token string">'B'</span> 是 int 类型
t <span class="token operator">=</span> <span class="token number">67</span>, u <span class="token operator">=</span> <span class="token number">66</span>  // <span class="token string">'C'</span> 是 char 类型，<span class="token string">'B'</span> 是 int 类型
t <span class="token operator">=</span> <span class="token number">42</span>, u <span class="token operator">=</span> <span class="token number">3.14</span> // <span class="token number">42</span> 是 int 类型，3.14 是 float 类型
<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>
<span class="token number">20</span>
<span class="token number">45</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>当<code>默认模板参数</code>和<code>模板参数自动推导</code>同时使用时（<code>优先级从高到低</code>）：</p>
<ul>
<li><code>如果可以推导出参数类型则使用推导出的类型</code></li>
<li><code>如果函数模板无法推导出参数类型，那么编译器会使用默认模板参数</code></li>
<li><code>如果无法推导出模板参数类型并且没有设置默认模板参数，编译器就会报错。</code></li>
<li>当有多个模板类型却只指定少于实际的模板类型,从左到右依次赋值</li>
</ul>
<p>再看下面的例子:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token comment">// 函数模板定义</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">U</span> <span class="token operator">=</span> <span class="token keyword">char</span><span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>T arg1 <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">,</span> U arg2 <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"arg1: "</span> <span class="token operator">&lt;&lt;</span> arg1 <span class="token operator">&lt;&lt;</span> <span class="token string">", arg2: "</span> <span class="token operator">&lt;&lt;</span> arg2 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 模板函数调用</span>
    <span class="token function">func</span><span class="token punctuation">(</span><span class="token char">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">func</span><span class="token punctuation">(</span><span class="token number">97</span><span class="token punctuation">,</span> <span class="token char">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// func();    //编译报错,默认的模板参数不全,默认的函数参数不能用于类型推导</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="7-using关键字"><a href="#7-using关键字" class="headerlink" title="7. using关键字"></a>7. using关键字</h2><blockquote>
<p>在<code>C++11</code>之前, <code>using关键字</code>一般有两种用法:</p>
<ul>
<li>引入<code>命名空间</code>，这样可以使用命名空间里的函数和变量，防止命名冲突</li>
<li><strong>派生类</strong>使用基类的成员或者函数</li>
</ul>
</blockquote>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token comment">// using namespace std; // using声明命名空间后可以省略命名空间，直接使用cout</span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>cout<span class="token punctuation">;</span> <span class="token comment">// 也可以只使用using声明命名空间中的一个对象</span>
<span class="token keyword">class</span> <span class="token class-name">Base</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> a<span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Base::print()"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">using</span> Base<span class="token double-colon punctuation">::</span>a<span class="token punctuation">;</span>     <span class="token comment">// 继承父类的a成员</span>
    <span class="token keyword">using</span> Base<span class="token double-colon punctuation">::</span>print<span class="token punctuation">;</span> <span class="token comment">// 继承父类的print成员</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello, world!\n"</span><span class="token punctuation">;</span>
    Child c<span class="token punctuation">;</span>
    c<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出Child::print()</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="7-1-给类定义别名"><a href="#7-1-给类定义别名" class="headerlink" title="7.1 给类定义别名"></a>7.1 给类定义别名</h3><p><strong>在c++中</strong>，可以用 <code>typedef</code> 重定义一个类型，语法如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">typedef</span> 旧的类型名 新的类型名<span class="token punctuation">;</span>
<span class="token comment">// 使用举例</span>
<span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> uint_t<span class="token punctuation">;</span>

<span class="token keyword">unsigned</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
uint_t b <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>typedef</code> 重定义的类型并不是一个新的类型，仅仅只是<strong>原有的类型取了一个新的名字</strong>。和以前的声明语句一样，这里的声明符也可以包含类型修饰(例如<code>const</code>，<code>volatile</code>），从而也能由基本数据类型构造出**复合类型(指针或者数组)**来。C++11中规定了一种新的方法，使用别名声明(alias declaration)来定义类型的别名，即使用 <code>using</code>。</p>
<p>在使用的时候，关键字 <code>using</code> 作为别名声明的开始，其后紧跟别名和等号，其作用是把等号左侧的名字规定成等号右侧类型的别名。<code>类型别名和类型的名字等价，只要是类型的名字能出现的地方，就能使用类型别名。使用typedef定义的别名和使用using定义的别名在语义上是等效的。</code></p>
<p>使用using定义别名的语法格式是这样的：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">using</span> 新的类型 <span class="token operator">=</span> 旧的类型<span class="token punctuation">;</span>
<span class="token comment">// 使用举例</span>
<span class="token keyword">using</span> uint_t <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>通过<code>using</code>和<code>typedef</code>的语法格式可以看到二者的使用没有太大的区别，假设我们定义一个<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_27825451/article/details/103081289">函数指针</a>，<code>using</code>的优势就能凸显出来了，看一下下面的例子：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 使用typedef定义函数指针</span>
<span class="token keyword">typedef</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span>func_ptr<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 使用using定义函数指针</span>
<span class="token keyword">using</span> func_ptr1 <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token comment">// using定义别名</span>
<span class="token keyword">using</span> u_int <span class="token operator">=</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">;</span>
u_int a <span class="token operator">=</span> <span class="token number">64</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"add("</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> <span class="token string">")="</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">+</span> b <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">// 函数指针类型定义, 这两种方法同效果</span>
<span class="token keyword">typedef</span> <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>add_ptr<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">using</span> add_ptr_ <span class="token operator">=</span> <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    add_ptr func <span class="token operator">=</span> add<span class="token punctuation">;</span>
    <span class="token comment">// add_ptr_ func = add;</span>
    
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>add_func<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">=</span> add<span class="token punctuation">;</span>
    <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">,</span> <span class="token char">'c'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 不使用别名</span>
    <span class="token function">func</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">(</span><span class="token operator">*</span>func<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="7-2-给模板定义别名"><a href="#7-2-给模板定义别名" class="headerlink" title="7.2 给模板定义别名"></a>7.2 给模板定义别名</h3><p>使用<code>typedef重定义类</code>时很方便，但是它有一点限制，比如无法<code>重定义一个模板</code>，比如我们需要一个<code>固定以int类型为key的map</code>，它可以和很多类型的<code>value</code>值进行映射，如果使用<code>typedef</code>这样直接定义就非常麻烦:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">typedef</span> map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token operator">></span> map_s<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> map_i<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token operator">></span> map_d<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>在这种情况下我们就不自觉的想到了模板：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">typedef</span> map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> T<span class="token operator">></span> type<span class="token punctuation">;</span>	<span class="token comment">// error, 语法错误</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>使用<strong>typename不支持给模板定义别名</strong>，这个简单的需求仅通过<code>typedef</code>很难办到，需要添加一个<code>外敷类</code>：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;functional></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;map></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token comment">// 定义外敷类</span>
<span class="token keyword">struct</span> <span class="token class-name">MyMap</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">typedef</span> map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> T<span class="token operator">></span> type<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    MyMap<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token double-colon punctuation">::</span>type m<span class="token punctuation">;</span>
    m<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token function">make_pair</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"luffy"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    m<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token function">make_pair</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"ace"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    MyMap<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token double-colon punctuation">::</span>type m1<span class="token punctuation">;</span>
    m1<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    m1<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>通过上边的例子可以直观的感觉到，需求简单但是实现起来并不容易。在<code>C++11</code>中，新增了一个特性就是可以通过<code>使用using来为一个模板定义别名</code>，对于上面的需求可以写成这样：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/* 使用using为模板定义别名 */</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">using</span> MyMap <span class="token operator">=</span> map<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>完整的实例代码如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;map></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">struct</span> <span class="token class-name">MyContainer</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span>T <span class="token operator">&amp;</span>t<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> iter <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> iter <span class="token operator">!=</span> t<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> iter<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            cout <span class="token operator">&lt;&lt;</span> iter<span class="token operator">-></span>first <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> iter<span class="token operator">-></span>second <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token comment">/* 使用using为模板定义别名 */</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">using</span> MyMap <span class="token operator">=</span> map<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    MyMap<span class="token operator">&lt;</span>string<span class="token operator">></span> map<span class="token punctuation">;</span> <span class="token comment">// ok</span>
    map<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">pair</span><span class="token generic class-name"><span class="token operator">&lt;</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    map<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">pair</span><span class="token generic class-name"><span class="token operator">&lt;</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    map<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">pair</span><span class="token generic class-name"><span class="token operator">&lt;</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    MyContainer<span class="token operator">&lt;</span>MyMap<span class="token operator">&lt;</span>string<span class="token operator">>></span> c<span class="token punctuation">;</span> <span class="token comment">// ok</span>
    c<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment">// ok</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面的例子中通过使用<code>using给模板指定别名</code>，就可以基于别名非常方便的给<code>value</code>指定相应的类型，这样使编写的程序变得更加灵活，看起来也更加简洁一些。</p>
<p>最后在强调一点：<code>using</code>语法和<code>typedef</code>一样，并不会创建出新的类型，它们只是给<strong>某些类型定义了新的别名</strong>。<code>using相较于typedef的优势在于定义函数指针别名时看起来更加直观，并且可以给模板定义别名。</code></p>
<h2 id="8-委托构造和继承构造"><a href="#8-委托构造和继承构造" class="headerlink" title="8. 委托构造和继承构造"></a>8. 委托构造和继承构造</h2><h3 id="8-1-委托构造函数"><a href="#8-1-委托构造函数" class="headerlink" title="8.1 委托构造函数"></a>8.1 委托构造函数</h3><p>在一个类中，常常会<code>重载多个构造函数</code>以适应不同的需求，<strong>在C++11之前</strong>，即便是同一个类的构造函数之间也不能互相调用，而<strong>在C++11之后</strong>，提出了<code>委托构造函数的概念</code>: 委托构造函数允许使用同一个类中的一个构造函数调用其它的构造函数，从而简化相关变量的初始化。下面举例说明:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">enum</span> <span class="token class-name">Gender</span>
<span class="token punctuation">&#123;</span>
    Male<span class="token punctuation">,</span>
    Female
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Person</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> i_age<span class="token punctuation">;</span>
    string s_name<span class="token punctuation">;</span>
    Gender s_gender<span class="token punctuation">;</span>
    
    <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        i_age <span class="token operator">=</span> age<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">,</span> string name<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        i_age <span class="token operator">=</span> age<span class="token punctuation">;</span> <span class="token comment">// 冗余代码</span>
        s_name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">,</span> string name<span class="token punctuation">,</span> Gender gender<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        i_age <span class="token operator">=</span> age<span class="token punctuation">;</span>   <span class="token comment">// 冗余代码</span>
        s_name <span class="token operator">=</span> name<span class="token punctuation">;</span> <span class="token comment">// 冗余代码</span>
        s_gender <span class="token operator">=</span> gender<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上面的程序中有三个构造函数，但是这三个函数中都有重复的代码，在C++11之前构造函数是不能调用构造函数的，加入了委托构造之后，我们就可以轻松地完成代码的优化了：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">enum</span> <span class="token class-name">Gender</span>
<span class="token punctuation">&#123;</span>
    Male<span class="token punctuation">,</span>
    Female
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Person</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> i_age<span class="token punctuation">;</span>
    string s_name<span class="token punctuation">;</span>
    Gender s_gender <span class="token operator">=</span> Gender<span class="token double-colon punctuation">::</span>Male<span class="token punctuation">;</span>
    <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        i_age <span class="token operator">=</span> age<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">,</span> string name<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">Person</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>

        s_name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">,</span> string name<span class="token punctuation">,</span> Gender gender<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">Person</span><span class="token punctuation">(</span>age<span class="token punctuation">,</span> name<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>

        s_gender <span class="token operator">=</span> gender<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        string genderStr <span class="token operator">=</span> <span class="token punctuation">(</span>s_gender <span class="token operator">==</span> Male<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token string">"Male"</span> <span class="token operator">:</span> <span class="token string">"Female"</span><span class="token punctuation">;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"age: "</span> <span class="token operator">&lt;&lt;</span> i_age <span class="token operator">&lt;&lt;</span> <span class="token string">" name: "</span> <span class="token operator">&lt;&lt;</span> s_name <span class="token operator">&lt;&lt;</span> <span class="token string">" gender: "</span> <span class="token operator">&lt;&lt;</span> genderStr <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Person <span class="token function">p1</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token string">"luffy"</span><span class="token punctuation">,</span> Male<span class="token punctuation">)</span><span class="token punctuation">;</span>
    Person <span class="token function">p2</span><span class="token punctuation">(</span><span class="token number">25</span><span class="token punctuation">,</span> <span class="token string">"zoro1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Person <span class="token function">p3</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">,</span> <span class="token string">"sanji"</span><span class="token punctuation">,</span> Female<span class="token punctuation">)</span><span class="token punctuation">;</span>

    p1<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    p2<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    p3<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>注意事项：</code></p>
<ol>
<li><code>这种链式的构造函数调用不能形成一个闭环（死循环），否则会在运行期抛异常。</code></li>
<li><code>如果要进行多层构造函数的链式调用，建议将构造函数的调用的写在初始列表中而不是函数体内部，否则编译器会提示形参的重复定义。</code></li>
<li><code>在初始化列表中调用了代理构造函数初始化某个类成员变量之后，就不能在初始化列表中再次初始化这个变量了。</code></li>
</ol>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 错误, 使用了委托构造函数就不能再次m_max初始化了</span>
<span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">int</span> age_<span class="token punctuation">,</span> string name<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">Person</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">age</span><span class="token punctuation">(</span>age_<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">this</span><span class="token operator">-></span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="8-2-继承构造函数"><a href="#8-2-继承构造函数" class="headerlink" title="8.2 继承构造函数"></a>8.2 继承构造函数</h3><p><code>C++11中提供的继承构造函数</code>可以让<code>派生类直接使用基类的构造函数</code>，而无需自己再写构造函数，尤其是在基类有很多构造函数的情况下，可以极大地简化派生类构造函数的编写。先来看没有继承构造函数之前的处理方式：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Base</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">m_i</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">double</span> j<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">m_i</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_j</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">double</span> j<span class="token punctuation">,</span> string k<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">m_i</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_j</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_k</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

    <span class="token keyword">int</span> m_i<span class="token punctuation">;</span>
    <span class="token keyword">double</span> m_j<span class="token punctuation">;</span>
    string m_k<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Child</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">Base</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    <span class="token function">Child</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">double</span> j<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">Base</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    <span class="token function">Child</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">double</span> j<span class="token punctuation">,</span> string k<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">Base</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Child <span class="token function">c</span><span class="token punctuation">(</span><span class="token number">520</span><span class="token punctuation">,</span> <span class="token number">13.14</span><span class="token punctuation">,</span> <span class="token string">"i love you"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"int: "</span> <span class="token operator">&lt;&lt;</span> c<span class="token punctuation">.</span>m_i <span class="token operator">&lt;&lt;</span> <span class="token string">", double: "</span> 
         <span class="token operator">&lt;&lt;</span> c<span class="token punctuation">.</span>m_j <span class="token operator">&lt;&lt;</span> <span class="token string">", string: "</span> <span class="token operator">&lt;&lt;</span> c<span class="token punctuation">.</span>m_k <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>可以看出，<code>即便是子类中只需要使用和基类一样的函数体也需要重新声明一遍子类的构造函数</code>,这是非常繁琐的，C++11中通过添加继承构造函数这个新特性完美的解决了这个问题，使得代码更加精简。</p>
<p>继承构造函数的使用方法是这样的：通过使用<code>using 类名::构造函数名</code>（其实类名和构造函数名是一样的）来<code>声明使用基类的构造函数</code>，这样子类中就可以不定义相同的构造函数了，直接使用基类的构造函数来构造派生类对象。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Base</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">m_i</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">double</span> j<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">m_i</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_j</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">double</span> j<span class="token punctuation">,</span> string k<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">m_i</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_j</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_k</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

    <span class="token keyword">int</span> m_i<span class="token punctuation">;</span>
    <span class="token keyword">double</span> m_j<span class="token punctuation">;</span>
    string m_k<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">using</span> Base<span class="token double-colon punctuation">::</span>Base<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Child <span class="token function">c</span><span class="token punctuation">(</span><span class="token number">520</span><span class="token punctuation">,</span> <span class="token number">13.14</span><span class="token punctuation">,</span> <span class="token string">"i love you"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"int: "</span> <span class="token operator">&lt;&lt;</span> c<span class="token punctuation">.</span>m_i <span class="token operator">&lt;&lt;</span> <span class="token string">", double: "</span>
         <span class="token operator">&lt;&lt;</span> c<span class="token punctuation">.</span>m_j <span class="token operator">&lt;&lt;</span> <span class="token string">", string: "</span> <span class="token operator">&lt;&lt;</span> c<span class="token punctuation">.</span>m_k <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在修改之后的子类中，没有添加任何构造函数，而是添加了<code>using Base::Base;</code>这样就可以在子类中直接继承父类的所有的构造函数，通过他们去构造子类对象了。</p>
<p>另外如果在子类中隐藏了父类中的同名函数，也可以通过<code>using</code>的方式在子类中使用基类中的这些父类函数：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Base</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">m_i</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">double</span> j<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">m_i</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_j</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">double</span> j<span class="token punctuation">,</span> string k<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">m_i</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_j</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_k</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

    <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"base class: i = "</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    
    <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> string str<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"base class: i = "</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">", str = "</span> <span class="token operator">&lt;&lt;</span> str <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">int</span> m_i<span class="token punctuation">;</span>
    <span class="token keyword">double</span> m_j<span class="token punctuation">;</span>
    string m_k<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">using</span> Base<span class="token double-colon punctuation">::</span>Base<span class="token punctuation">;</span>
    <span class="token keyword">using</span> Base<span class="token double-colon punctuation">::</span>func<span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"child class: i'am luffy!!!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Child <span class="token function">c</span><span class="token punctuation">(</span><span class="token number">250</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    c<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    c<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token number">19</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    c<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token number">19</span><span class="token punctuation">,</span> <span class="token string">"luffy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上述示例代码输出的结果为：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">child class: i'am luffy<span class="token operator">!</span><span class="token operator">!</span><span class="token operator">!</span>
base class: i <span class="token operator">=</span> <span class="token number">19</span>
base class: i <span class="token operator">=</span> <span class="token number">19</span>, str <span class="token operator">=</span> luffy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>子类中的<code>func()函数</code>隐藏了<code>基类中的两个func()</code>，因此默认情况下通过子类对象只能调用无参的func()，在上面的子类代码中添加了<code>using Base::func;</code>之后，就可以通过子类对象直接调用父类中被隐藏的带参func()函数了。</p>
<h2 id="9-初始化列表"><a href="#9-初始化列表" class="headerlink" title="9. 初始化列表"></a>9. 初始化列表</h2><p>关于C++中的<code>变量，数组，对象</code>等都有<code>不同的初始化方法</code>，在这些繁琐的初始化方法中没有任何一种方式适用于所有的情况。为了统一初始化方式，并且让初始化行为具有确定的效果，在C++11中提出了<code>列表初始化</code>的概念。</p>
<h3 id="9-1-统一的初始化方式"><a href="#9-1-统一的初始化方式" class="headerlink" title="9.1 统一的初始化方式"></a>9.1 统一的初始化方式</h3><p>在C++98&#x2F;03中，对应普通数组和可以直接进行<code>内存拷贝（memcpy()）</code>的对象是可以使用列表初始化来初始化数据的</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 数组的初始化</span>
<span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">9</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">double</span> array1<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">1.2</span><span class="token punctuation">,</span> <span class="token number">1.3</span><span class="token punctuation">,</span> <span class="token number">1.4</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token comment">// 对象的初始化</span>
<span class="token keyword">struct</span> <span class="token class-name">Person</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> id<span class="token punctuation">;</span>
    <span class="token keyword">double</span> salary<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>zhang3<span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3000</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在<code>C++11</code>后,变得更加多样和灵活了,看一下下面的例子:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Test</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">const</span> Test <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Test <span class="token function">t1</span><span class="token punctuation">(</span><span class="token number">520</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 调用默认构造函数</span>
    Test t2 <span class="token operator">=</span> <span class="token number">520</span><span class="token punctuation">;</span>   <span class="token comment">// 520会被编译器自动转换为int类型，然后调用默认构造函数构建(临时)匿名对象,然后通过拷贝构造函数赋值给t2</span>
    Test t3 <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">520</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// c++11新特性：列表初始化</span>
    Test t4<span class="token punctuation">&#123;</span><span class="token number">520</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token comment">// c++11新特性：列表初始化</span>
    <span class="token keyword">int</span> a1 <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1314</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> a2<span class="token punctuation">&#123;</span><span class="token number">1314</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> arr1<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> arr2<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>既然<code>列表初始化</code>可以对普通类型和对象进行直接初始化，那么自然也可以对<code>使用new关键字</code>动态分配的对象进行列表初始化：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">&#123;</span><span class="token number">520</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">double</span> b <span class="token operator">=</span> <span class="token keyword">double</span><span class="token punctuation">&#123;</span><span class="token number">52.134</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
Test <span class="token operator">*</span>test <span class="token operator">=</span> <span class="token keyword">new</span> Test<span class="token punctuation">&#123;</span><span class="token number">50</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>不仅如此，还可以用在<code>函数的返回值</code>上，返回一个匿名对象</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Person</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">,</span> string name<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"id: "</span> <span class="token operator">&lt;&lt;</span> id <span class="token operator">&lt;&lt;</span> <span class="token string">", name: "</span> <span class="token operator">&lt;&lt;</span> name <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

Person <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span> <span class="token number">9527</span><span class="token punctuation">,</span> <span class="token string">"华安"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Person p <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>代码中的<code>return &#123; 9527, &quot;华安&quot; &#125;;</code>就相当于<code>return (9527, &quot;华安&quot; );</code>，直接返回了一个<code>匿名对象</code>。通过上面的几个例子可以看出在<strong>C++11使用列表初始化是非常便利的</strong>，它统一了各种对象的初始化方式，而且还让代码的书写更加简单清晰。</p>
<h3 id="9-2-列表初始化细节"><a href="#9-2-列表初始化细节" class="headerlink" title="9.2 列表初始化细节"></a>9.2 列表初始化细节</h3><p>在C++11中，只要是<code>聚合类型都能使用列表初始化</code>进行直接的初始化方式。(例如数组)</p>
<ul>
<li><code>普通数组本身可以看作一个聚合类型</code></li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> x<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">double</span> y<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
    <span class="token punctuation">&#123;</span><span class="token number">1.23</span><span class="token punctuation">,</span> <span class="token number">2.34</span><span class="token punctuation">,</span> <span class="token number">3.45</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
    <span class="token punctuation">&#123;</span><span class="token number">4.56</span><span class="token punctuation">,</span> <span class="token number">5.67</span><span class="token punctuation">,</span> <span class="token number">6.78</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
    <span class="token punctuation">&#123;</span><span class="token number">7.89</span><span class="token punctuation">,</span> <span class="token number">8.91</span><span class="token punctuation">,</span> <span class="token number">9.99</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> carry<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token char">'a'</span><span class="token punctuation">,</span> <span class="token char">'b'</span><span class="token punctuation">,</span> <span class="token char">'c'</span><span class="token punctuation">,</span> <span class="token char">'d'</span><span class="token punctuation">,</span> <span class="token char">'e'</span><span class="token punctuation">,</span> <span class="token char">'f'</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>string sarry<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token string">"world"</span><span class="token punctuation">,</span> <span class="token string">"nihao"</span><span class="token punctuation">,</span> <span class="token string">"shijie"</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="a-聚合体"><a href="#a-聚合体" class="headerlink" title="a. 聚合体"></a>a. 聚合体</h4><p>在C++中，<code>聚合体（Aggregate）</code>是指一种特殊的类类型，它满足以下条件：</p>
<ol>
<li>没有<code>用户定义的构造函数（即没有自定义的构造函数，包括默认构造函数）</code>。</li>
<li>没有<code>私有（private）或保护（protected）的非静态数据成员</code>。</li>
<li>没有<code>基类（即不是派生类）</code>。</li>
<li>没有<code>虚（virtual）函数</code>。</li>
</ol>
<p>聚合体的特点是可以使用列表初始化来初始化其成员，例如：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">Test</span> <span class="token comment">// 聚合体类型</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> x<span class="token punctuation">;</span>
    <span class="token keyword">int</span> y<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">Test2</span> <span class="token comment">// 非聚合体类型</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> x<span class="token punctuation">;</span>
    <span class="token keyword">int</span> y<span class="token punctuation">;</span>
    <span class="token function">Test2</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">x</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">y</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Test t1 <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token comment">// x=1, y=2</span>
    Test2 t2 <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// x=10, y=20</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p><code>Test2类的对象t2</code>使用初始化列表进行初始化，你会发现x，y的值并没有按照初始化列表中的来，这是因为<code>Test2类</code>中定义了一个自定义的构造函数（不在把它当作一个简单的类型的聚合），所以系统在使用初始化列表的时候，将会调用它定义的构造函数</p>
</li>
<li><p><code>对象t1是对一个自定义的聚合类型进行初始化，它将以拷贝的形式使用初始化列表中的数据来初始化T1结构体中的成员。</code></p>
</li>
</ul>
<p>聚合体类型可以使用初始化列表进行初始化，但还有一种情况是不支持的（在c++11）</p>
<ul>
<li>类中不能有使用<code>&#123;&#125;</code>和<code>=</code>直接初始化的<code>非静态数据成员</code>（从c++14开始就支持了）</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">T2</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> x<span class="token punctuation">;</span>
    <span class="token keyword">long</span> y<span class="token punctuation">;</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> z<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>t1<span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">100</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>		<span class="token comment">// ok</span>
<span class="token comment">// 静态成员的初始化</span>
<span class="token keyword">int</span> T2<span class="token double-colon punctuation">::</span>z <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">T3</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> x<span class="token punctuation">;</span>
    <span class="token keyword">double</span> y <span class="token operator">=</span> <span class="token number">1.34</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> z<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    T3 t<span class="token punctuation">&#123;</span><span class="token number">520</span><span class="token punctuation">,</span> <span class="token number">13.14</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>		<span class="token comment">// error, c++11不支持,从c++14开始就支持了</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="b-非聚合体"><a href="#b-非聚合体" class="headerlink" title="b. 非聚合体"></a>b. 非聚合体</h4><p>对于聚合类型的类可以直接使用列表初始化进行对象的初始化，<code>如果不满足聚合条件还想使用列表初始化其实也是可以的，需要在类的内部自定义一个构造函数, 在构造函数中使用初始化列表对类成员变量进行初始化</code>:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">T1</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> x<span class="token punctuation">;</span>
    <span class="token keyword">double</span> y<span class="token punctuation">;</span>
    <span class="token comment">// 在构造函数中使用初始化列表初始化类成员</span>
    <span class="token function">T1</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">double</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">x</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">y</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">z</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"x: "</span> <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> <span class="token string">", y: "</span> <span class="token operator">&lt;&lt;</span> y <span class="token operator">&lt;&lt;</span> <span class="token string">", z: "</span> <span class="token operator">&lt;&lt;</span> z <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> z<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    T1 t<span class="token punctuation">&#123;</span> <span class="token number">520</span><span class="token punctuation">,</span> <span class="token number">13.14</span><span class="token punctuation">,</span> <span class="token number">1314</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>	<span class="token comment">// ok, 基于构造函数使用初始化列表初始化类成员</span>
    t<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>另外，需要额外注意的是<code>聚合类型的定义并非递归的</code>，也就是说<code>当一个类的非静态成员是非聚合类型时，这个类也可能是聚合类型</code>，比如下面的这个例子：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">T1</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> x<span class="token punctuation">;</span>
    <span class="token keyword">double</span> y<span class="token punctuation">;</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> z<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">T2</span>
<span class="token punctuation">&#123;</span>
    T1 t1<span class="token punctuation">;</span>
    <span class="token keyword">long</span> x1<span class="token punctuation">;</span>
    <span class="token keyword">double</span> y1<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    T2 t2<span class="token punctuation">&#123;</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">520</span><span class="token punctuation">,</span> <span class="token number">13.14</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>可以看到，T1并非一个聚合类型，因为它有一个<code>private的非静态成员</code>。但是尽管T2有一个非聚合类型的非静态成员t1，T2依然是一个聚合类型，可以直接使用列表初始化的方式进行初始化。</p>
<p>最后强调一下t2对象的初始化过程，对于非聚合类型的成员t1做初始化的时候，可以直接写一对<code>空的大括号&#123;&#125;</code>，这相当于<code>调用是T1的无参构造函数</code>。</p>
<blockquote>
<p>对于一个聚合类型，使用<code>列表初始化相当于对其中的每个元素分别赋值</code>，而对于非聚合类型，则需要先自定义一个合适的构造函数，此时<code>使用列表初始化将会调用它对应的构造函数</code>。</p>
</blockquote>
<h3 id="9-3-std-initializer-list"><a href="#9-3-std-initializer-list" class="headerlink" title="9.3 std::initializer_list"></a>9.3 std::initializer_list</h3><p>在C++的STL容器中，可以进行<code>任意长度的相同类型数据的初始化</code>，使用初始化列表也只能进行固定参数的初始化，如果想要做到和STL一样有任意长度初始化的能力，可以使用std::initializer_list这个轻量级的类模板来实现。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v1<span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v2<span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>先来介绍一下这个<code>类模板</code>的一些特点：</p>
<ul>
<li>它是一个<code>轻量级的容器类型</code>，内部定义了迭代器iterator等容器必须的概念，遍历时得到的迭代器是<strong>只读的</strong>。</li>
<li>对于<code>std::initializer_list&lt;T&gt;</code>而言，它可以接收任意长度的初始化列表，但是要求元素必须是同种类型T</li>
<li>在<code>std::initializer_list</code>内部有三个成员接口：<code>size()</code>, <code>begin()</code>, <code>end()</code>。</li>
<li><code>std::initializer_list</code>对象只能被整体初始化或者赋值。</li>
</ul>
<blockquote>
<ol>
<li><strong>私有构造函数</strong></li>
</ol>
<ul>
<li><p><code>initializer_list</code> 类有一个<code>私有构造函数</code>，它接受两个参数：一个指向数组的指针和数组的长度。这个构造函数由编译器调用，用于初始化 <code>initializer_list</code> 对象。</p>
</li>
<li><p>这个构造函数的定义如下：</p>
  <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">constexpr</span> <span class="token function">initializer_list</span><span class="token punctuation">(</span>const_iterator __a<span class="token punctuation">,</span> size_type __l<span class="token punctuation">)</span>
<span class="token operator">:</span> <span class="token function">_M_array</span><span class="token punctuation">(</span>__a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_M_len</span><span class="token punctuation">(</span>__l<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>其中，<code>_M_array</code> 是指向列表中第一个元素的指针，<code>_M_len</code> 是列表中元素的数量。</p>
</li>
</ul>
<ol start="2">
<li><strong>编译器的隐式调用</strong></li>
</ol>
<ul>
<li><p>当你使用初始化列表语法 <code>&#123;1, 2, 3&#125;</code> 来创建 <code>initializer_list</code> 对象时，编译器会自动调用这个私有构造函数。编译器会生成一个临时数组，将 <code>&#123;1, 2, 3&#125;</code> 中的元素存储在这个数组中，然后将这个数组的指针和长度传递给私有构造函数。</p>
</li>
<li><p>例如：</p>
  <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">initializer_list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> l <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>编译器会生成类似以下的代码：</p>
  <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> __tmp<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
initializer_list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">l</span><span class="token punctuation">(</span>__tmp<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
</ul>
</blockquote>
<h4 id="a-作为普通函数参数"><a href="#a-作为普通函数参数" class="headerlink" title="a. 作为普通函数参数"></a>a. 作为普通函数参数</h4><p>如果想要自定义一个<code>函数并且接收任意个数的参数（变参函数）</code>，只需要将函数参数指定为<code>std::initializer_list</code>，使用<code>初始化列表&#123; &#125;</code>作为实参进行数据传递即可。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">traversal</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>initializer_list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> a<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>it<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>it <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    initializer_list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> list<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"current list size: "</span> <span class="token operator">&lt;&lt;</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token function">traversal</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>

    list <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">0</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"current list size: "</span> <span class="token operator">&lt;&lt;</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token function">traversal</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    
    list <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">9</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"current list size: "</span> <span class="token operator">&lt;&lt;</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token function">traversal</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token comment">////////////////////////////////////////////////////</span>
    <span class="token comment">////////////// 直接通过初始化列表传递数据 //////////////</span>
    <span class="token comment">////////////////////////////////////////////////////</span>
    <span class="token function">traversal</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token function">traversal</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> <span class="token number">11</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">13</span><span class="token punctuation">,</span><span class="token number">14</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">16</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>


    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>std::initializer_list</code>拥有<code>一个无参构造函数</code>，因此，它可以直接定义实例，此时将得到一个空的<code>std::initializer_list</code>，因为在遍历这种类型的容器的时候得到的是一个<code>只读的迭代器</code>，因此我们不能修改里边的数据。</p>
<p>在效率方面也无需担心，<code>std::initializer_list</code>的效率是非常高的，它的内部并不负责保存初始化列表中元素的拷贝，仅仅存储了初始化列表中元素的引用。</p>
<h4 id="b-作为构造函数参数"><a href="#b-作为构造函数参数" class="headerlink" title="b. 作为构造函数参数"></a>b. 作为构造函数参数</h4><p>自定义的类如果在构造对象的时候想要接收任意个数的实参，可以给构造函数指定为<code>std::initializer_list</code>类型，在自定义类的内部还是使用容器来存储接收的多个实参。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Test</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Test</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>initializer_list<span class="token operator">&lt;</span>string<span class="token operator">></span> list<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> list<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>it<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>it <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
            m_names<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token operator">*</span>it<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    vector<span class="token operator">&lt;</span>string<span class="token operator">></span> m_names<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Test <span class="token function">t</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> <span class="token string">"jack"</span><span class="token punctuation">,</span> <span class="token string">"lucy"</span><span class="token punctuation">,</span> <span class="token string">"tom"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Test <span class="token function">t1</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> <span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token string">"world"</span><span class="token punctuation">,</span> <span class="token string">"nihao"</span><span class="token punctuation">,</span> <span class="token string">"shijie"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="10-基于范围的for循环"><a href="#10-基于范围的for循环" class="headerlink" title="10. 基于范围的for循环"></a>10. 基于范围的for循环</h2><p>在C++98&#x2F;03之前，<code>不同的数组和容器有不同的遍历方式</code>，写法不统一，也不够简洁，而C++11基于范围的for循环可以以简洁、统一的方式来遍历容器和数组，用起来也更方便了。</p>
<h3 id="10-1-for循环的新语法"><a href="#10-1-for循环的新语法" class="headerlink" title="10.1 for循环的新语法"></a>10.1 for循环的新语法</h3><p>在介绍新的for循环语法之前，我们先来看传统的for循环的语法结构：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span><span class="token punctuation">(</span>表达式 <span class="token number">1</span><span class="token punctuation">;</span> 表达式 <span class="token number">2</span><span class="token punctuation">;</span> 表达式 <span class="token number">3</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 循环体</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>在介绍新语法之前，先来看一个使用迭代器遍历容器的例子：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> t<span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> t<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>it<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>it <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>我们在遍历的过程中需要给出容器的两端：开头（begin）和结尾（end），因为这种遍历方式不是基于范围来设计的。<code>在基于范围的for循环中，不需要再传递容器的两端，循环会自动以容器为范围展开，并且循环中也屏蔽掉了迭代器的遍历细节，直接抽取容器中的元素进行运算，使用这种方式进行循环遍历会让编码和维护变得更加简便。</code></p>
<p>C++11基于范围的for循环，语法格式：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span>declaration <span class="token operator">:</span> expression<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 循环体</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上面的语法格式中<code>declaration</code>表示遍历声明，在遍历过程中，当前被遍历到的元素会被存储到声明的变量中。<code>expression</code>是要遍历的对象，它可以是<code>表达式、容器、数组、初始化列表</code>等。</p>
<p>使用基于范围的for循环遍历容器，示例代码如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">:</span> v<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上面的例子中，<code>是将容器中遍历的当前元素拷贝到了声明的变量value中</code>，因此无法对容器中的元素进行写操作，如果需要在遍历过程中修改元素的值，需要使用引用。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;windows.h></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 设置控制台的输出代码页为 UTF-8</span>
    <span class="token function">SetConsoleOutputCP</span><span class="token punctuation">(</span>CP_UTF8<span class="token punctuation">)</span><span class="token punctuation">;</span>

    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> t<span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"遍历修改之前的容器: "</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>value <span class="token operator">:</span> t<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> value<span class="token operator">++</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    cout <span class="token operator">&lt;&lt;</span> endl
         <span class="token operator">&lt;&lt;</span> <span class="token string">"遍历修改之后的容器: "</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>value <span class="token operator">:</span> t<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> value <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>代码输出的结果：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">遍历修改之前的容器: <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span>
遍历修改之后的容器: <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span> <span class="token number">7</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>对容器的遍历过程中，如果<code>只是读数据</code>，不允许修改元素的值，可以使用<code>const</code>定义保存元素数据的变量，在定义的时候建议使用<code>const auto &amp;</code>，这样相对于<code>const auto</code>效率要更高一些。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> t<span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> value <span class="token operator">:</span> t<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> value <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="10-2-使用细节"><a href="#10-2-使用细节" class="headerlink" title="10.2 使用细节"></a>10.2 使用细节</h3><h4 id="a-关系型容器"><a href="#a-关系型容器" class="headerlink" title="a. 关系型容器"></a>a. 关系型容器</h4><p>使用基于范围的for循环有一些需要注意的细节，先来看一下对<code>关系型容器map</code>的遍历：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;map></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token operator">></span> m<span class="token punctuation">&#123;</span>
        <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"lucy"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"lily"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"tom"</span><span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

    <span class="token comment">// 基于范围的for循环方式</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> it <span class="token operator">:</span> m<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"id: "</span> <span class="token operator">&lt;&lt;</span> it<span class="token punctuation">.</span>first <span class="token operator">&lt;&lt;</span> <span class="token string">", name: "</span> <span class="token operator">&lt;&lt;</span> it<span class="token punctuation">.</span>second <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 普通的for循环方式</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">=</span> m<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> m<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>it<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"id: "</span> <span class="token operator">&lt;&lt;</span> it<span class="token operator">-></span>first <span class="token operator">&lt;&lt;</span> <span class="token string">", name: "</span> <span class="token operator">&lt;&lt;</span> it<span class="token operator">-></span>second <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上面的例子中使用两种方式对map进行了遍历，通过对比有两点需要注意的事项：</p>
<p><code>使用普通的for循环方式（基于迭代器）遍历关联性容器， auto自动推导出的是一个迭代器类型，需要使用迭代器的方式取出元素中的键值对（和指针的操作方法相同）</code>：</p>
<ul>
<li>it-&gt;first</li>
<li>it-&gt;second</li>
</ul>
<p><code>使用基于范围的for循环遍历关联性容器，auto自动推导出的类型是容器中的value_type，相当于一个对组（std::pair）对象，提取键值对的方式如下：</code></p>
<ul>
<li>it.first</li>
<li>it.second</li>
</ul>
<h4 id="b-元素只读"><a href="#b-元素只读" class="headerlink" title="b. 元素只读"></a>b. 元素只读</h4><p>通过对基于范围的for循环语法的介绍可以得知，在for循环内部声明一个变量的引用就可以修改遍历的表达式中的元素的值，但是这并不适用于所有的情况，对应<code>set容器</code>来说，<code>内部元素都是只读的</code>，这是由容器的特性决定的，因此在for循环中<code>auto&amp;</code>会被视为<code>const auto &amp; </code>。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;set></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> st<span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>item <span class="token operator">:</span> st<span class="token punctuation">)</span> 
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> item<span class="token operator">++</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>		<span class="token comment">// error, 不能给常量赋值</span>
        <span class="token comment">// 元素的值用于确定其在集合中的位置，并且集合要求元素是唯一的。如果允许修改元素的值，可能会破坏set的有序性和唯一性。</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>除此之外，在遍历关联型容器时也会出现同样的问题，基于范围的for循环中，虽然可以得到一个<code>std::pair引用</code>，但是我们是不能修改里边的<code>first</code>值的，也就是key值。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;map></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token operator">></span> m<span class="token punctuation">&#123;</span>
        <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"lucy"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"lily"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"tom"</span><span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> item <span class="token operator">:</span> m<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token comment">// item.first 是一个常量</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"id: "</span> <span class="token operator">&lt;&lt;</span> item<span class="token punctuation">.</span>first<span class="token operator">++</span> <span class="token operator">&lt;&lt;</span> <span class="token string">", name: "</span> <span class="token operator">&lt;&lt;</span> item<span class="token punctuation">.</span>second <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  <span class="token comment">// error</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="c-访问次数"><a href="#c-访问次数" class="headerlink" title="c. 访问次数"></a>c. 访问次数</h4><p>基于范围的for循环遍历的对象可以是一个<code>表达式或者容器/数组</code>等。假设我们对一个容器进行遍历，在遍历过程中for循环对这个容器的<code>访问频率</code>是一次还是多次呢？我们通过下面的例子验证一下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v<span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> <span class="token function">getRange</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"get vector range..."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> v<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> val <span class="token operator">:</span> <span class="token function">getRange</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> val <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>输出的结果如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">get vector range<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>从上面的结果中可以看到，不论基于范围的for循环迭代了多少次，<code>函数getRange()</code>只在第一次迭代之前被调用，得到这个容器对象之后就不会再去重新获取这个对象了。</p>
<blockquote>
<p>对应基于范围的for循环来说，冒号后边的表达式只会被执行一次。在得到遍历对象之后会先确定好迭代的范围，基于这个范围直接进行遍历。如果是普通的for循环，在每次迭代的时候都需要判断是否已经到了结束边界。</p>
</blockquote>
<h2 id="11-可调用对象包装器、绑定器"><a href="#11-可调用对象包装器、绑定器" class="headerlink" title="11. 可调用对象包装器、绑定器"></a>11. 可调用对象包装器、绑定器</h2><h3 id="11-1-可调用对象"><a href="#11-1-可调用对象" class="headerlink" title="11.1 可调用对象"></a>11.1 可调用对象</h3><p><strong>可调用对象（Callable）</strong> 是指可以像函数一样调用某些实体的对象。</p>
<ol>
<li>是一个<code>函数对象</code></li>
</ol>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">Func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"函数被调用"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<ol start="2">
<li><code>函数指针</code>，本质也是函数</li>
</ol>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">double</span> b<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">// 定义函数指针</span>
<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>func<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>print<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ol start="3">
<li><code>仿函数</code> - 重载了<code>()</code>操作符的类的对象</li>
</ol>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Test</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"hello world"</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token comment">// 3. 可调用对象--仿函数</span>
Test t1<span class="token punctuation">;</span>
<span class="token function">t1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ol start="4">
<li><code>是一个可被转换为函数指针的类对象   类型转换运算符</code> - 能够将<code>类对象转换为函数指针类型</code></li>
</ol>
<p><strong>类型转换运算符（Conversion Operator）</strong> 是一种可用于类的特殊成员函数，用于定义类到其他类型的隐式或显式转换。类型转换运算符的语法如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">operator</span> 类型<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li><strong>定义了如何将类对象转换为指定类型。</strong></li>
<li><strong>例如，可以将一个自定义类转换为内置数据类型或其他类类型。</strong></li>
</ul>
<blockquote>
<p><strong>示例：定义类型转换运算符</strong></p>
<p>假设有一个表示货币金额的类 <code>Money</code>，我们希望将其转换为 <code>double</code> 类型：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token operator">></span>#include <span class="token operator">&lt;</span>iostream<span class="token operator">></span>

<span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Money</span> <span class="token punctuation">&#123;</span>
<span class="token operator">></span><span class="token keyword">private</span><span class="token operator">:</span>
   <span class="token keyword">double</span> amount<span class="token punctuation">;</span>

<span class="token operator">></span><span class="token keyword">public</span><span class="token operator">:</span>
   <span class="token function">Money</span><span class="token punctuation">(</span><span class="token keyword">double</span> amt<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">amount</span><span class="token punctuation">(</span>amt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

   <span class="token comment">// 定义类型转换运算符，将 Money 转换为 double</span>
   <span class="token keyword">operator</span> <span class="token keyword">double</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span>
       <span class="token keyword">return</span> amount<span class="token punctuation">;</span>
   <span class="token punctuation">&#125;</span>
<span class="token operator">></span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token operator">></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
   Money <span class="token function">m</span><span class="token punctuation">(</span><span class="token number">100.5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

   <span class="token comment">// 使用类型转换运算符</span>
   <span class="token keyword">double</span> amount <span class="token operator">=</span> m<span class="token punctuation">;</span> <span class="token comment">// 调用 operator double()</span>

   std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Amount: "</span> <span class="token operator">&lt;&lt;</span> amount <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token operator">></span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>解释：</strong></p>
<ul>
<li>类 <code>Money</code> 中定义了 <code>operator double()</code>，允许将 <code>Money</code> 对象隐式转换为 <code>double</code>。</li>
<li>在 <code>main</code> 函数中，<code>double amount = m;</code> 触发了类型转换运算符，将 <code>Money</code> 对象 <code>m</code> 转换为 <code>double</code>。</li>
</ul>
<p><strong>隐式与显式转换</strong></p>
<ul>
<li>默认情况下，类型转换运算符允许隐式转换。</li>
<li>如果希望防止隐式转换，可以使用 <code>explicit</code> 关键字：</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token operator">></span><span class="token keyword">explicit</span> <span class="token keyword">operator</span> <span class="token keyword">double</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span>
   <span class="token keyword">return</span> amount<span class="token punctuation">;</span>
<span class="token operator">></span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>这样，需要显式转换（如 <code>double amount = static_cast&lt;double&gt;(m);</code>）才能进行转换。</p>
</blockquote>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">using</span> func_ptr <span class="token operator">=</span> <span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">Test</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> string b<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"name: "</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> <span class="token string">", age: "</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 将类对象转换为函数指针</span>
    <span class="token keyword">operator</span> <span class="token function">func_ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token comment">// 返回的要是 类的静态成员Test::print</span>
        <span class="token keyword">return</span> print<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Test t<span class="token punctuation">;</span>
    <span class="token comment">// 对象转换为函数指针, 并调用</span>
    <span class="token function">t</span><span class="token punctuation">(</span><span class="token number">19</span><span class="token punctuation">,</span> <span class="token string">"Monkey D. Luffy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ol start="5">
<li><code>是一个类成员函数指针或者类成员指针</code></li>
</ol>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">Test</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> string b<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"name: "</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> <span class="token string">", age: "</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">int</span> m_num<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 定义类成员函数指针指向类成员函数</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span>Test<span class="token double-colon punctuation">::</span><span class="token operator">*</span>func_ptr<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>Test<span class="token double-colon punctuation">::</span>print<span class="token punctuation">;</span>
    <span class="token comment">// 类成员指针指向类成员变量</span>
    <span class="token keyword">int</span> Test<span class="token double-colon punctuation">::</span><span class="token operator">*</span>obj_ptr <span class="token operator">=</span> <span class="token operator">&amp;</span>Test<span class="token double-colon punctuation">::</span>m_num<span class="token punctuation">;</span>

    Test t<span class="token punctuation">;</span>
    <span class="token comment">// 通过类成员函数指针调用类成员函数</span>
    <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token operator">*</span>func_ptr<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">19</span><span class="token punctuation">,</span> <span class="token string">"Monkey D. Luffy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 通过类成员指针初始化类成员变量</span>
    t<span class="token punctuation">.</span><span class="token operator">*</span>obj_ptr <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"number is: "</span> <span class="token operator">&lt;&lt;</span> t<span class="token punctuation">.</span>m_num <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上面的例子中满足条件的这些可调用对象对应的类型被统称为<code>可调用类型</code>。</p>
<p>C++中的可调用类型虽然具有比较统一的操作形式，但定义方式五花八门，这样在我们试图使用统一的方式保存，或者传递一个可调用对象时会十分繁琐。现在，<code>C++11通过提供 std::function 和 std::bind 统一了可调用对象的各种操作</code>。</p>
<h3 id="11-2-可调用对象包装器"><a href="#11-2-可调用对象包装器" class="headerlink" title="11.2 可调用对象包装器"></a>11.2 可调用对象包装器</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43798887/article/details/116571325">C++11的std::function源码解析_std::function 源码-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/66301236">libcxx 的 std::function 源码分析 - 知乎</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/560964284">STL源码分析之std::function - 知乎</a></p>
<p><code>std::function</code>是<code>可调用对象的包装器</code>。它是一个<code>类模板</code>，可以容纳<code>除了类(非静态)成员（函数）指针之外</code>的所有可调用对象。通过指定它的模板参数，它可以用统一的方式处理函数、函数对象、函数指针，并允许保存和延迟执行它们。</p>
<p><strong>基本用法</strong></p>
<p>使用<code>std::function</code>需要添加头文件<code>#include &lt;functional&gt;</code>，可调用对象包装器使用语法如下:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;functional></span></span>
std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span>返回值类型<span class="token punctuation">(</span>参数类型列表<span class="token punctuation">)</span><span class="token operator">></span> diy_name <span class="token operator">=</span> 可调用对象<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>下面的实例代码中演示了可调用对象包装器的基本使用方法：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;functional></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">using</span> f_ptr <span class="token operator">=</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">Func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"函数被调用"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">class</span> <span class="token class-name">Test</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> num<span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"hello world"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// 类型转换运算符 -- 返回值必须是 静态成员函数指针 这样才能在没有实例的情况下调用</span>
    <span class="token keyword">operator</span> <span class="token function">f_ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> static_print<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">static_print</span><span class="token punctuation">(</span>string msg<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"我是静态成员函数"</span> <span class="token operator">&lt;&lt;</span> msg <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">void</span> <span class="token function">normal_print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"我是非静态成员函数"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token keyword">const</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"chcp 65001"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 1. 可调用对象--函数</span>
    <span class="token function">Func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 2. 可调用对象--函数指针</span>
    <span class="token keyword">using</span> func_ptr <span class="token operator">=</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    func_ptr ptr1 <span class="token operator">=</span> Func<span class="token punctuation">;</span>
    <span class="token punctuation">(</span>ptr1<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">(</span><span class="token operator">*</span>ptr1<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 3. 可调用对象--仿函数</span>
    Test t1<span class="token punctuation">;</span>
    <span class="token function">t1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 4. 类型转换运算符 -> 能够将`类对象转换为函数指针类型`</span>
    string msg <span class="token operator">=</span> <span class="token string">"hhh"</span><span class="token punctuation">;</span>
    <span class="token function">t1</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 5. 类成员函数指针 / 类成员指针</span>
    <span class="token keyword">using</span> class_func_ptr <span class="token operator">=</span> <span class="token keyword">void</span> <span class="token punctuation">(</span>Test<span class="token double-colon punctuation">::</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    class_func_ptr ptr2 <span class="token operator">=</span> <span class="token operator">&amp;</span>Test<span class="token double-colon punctuation">::</span>normal_print<span class="token punctuation">;</span>

    <span class="token keyword">int</span> Test<span class="token double-colon punctuation">::</span><span class="token operator">*</span>class_member_ptr <span class="token operator">=</span> <span class="token operator">&amp;</span>Test<span class="token double-colon punctuation">::</span>num<span class="token punctuation">;</span>
    Test t2<span class="token punctuation">;</span>
    <span class="token punctuation">(</span>t2<span class="token punctuation">.</span><span class="token operator">*</span>ptr2<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 使用可调用对象包装器</span>
    <span class="token comment">// 1. 函数指针</span>
    function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span> f1 <span class="token operator">=</span> Func<span class="token punctuation">;</span>
    <span class="token comment">// 2. 仿函数</span>
    Test tt<span class="token punctuation">;</span>
    function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span> f2 <span class="token operator">=</span> tt<span class="token punctuation">;</span>
    <span class="token comment">// 3. 类型转换运算符</span>
    function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span><span class="token operator">></span> f3 <span class="token operator">=</span> tt<span class="token punctuation">;</span>
    <span class="token comment">// 4. 类静态函数</span>
    function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span><span class="token operator">></span> f4 <span class="token operator">=</span> <span class="token operator">&amp;</span>Test<span class="token double-colon punctuation">::</span>static_print<span class="token punctuation">;</span>
    <span class="token comment">// 调用</span>
    <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">f3</span><span class="token punctuation">(</span><span class="token string">"hhh"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">f4</span><span class="token punctuation">(</span><span class="token string">"hhh"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>通过测试代码可以得到结论：<code>std::function可以将可调用对象进行包装，得到一个统一的格式，包装完成得到的对象相当于一个函数指针</code>，和函数指针的使用方式相同，通过包装器对象就可以完成对包装的函数的调用了。</p>
<p><strong>作为回调函数使用</strong></p>
<p>因为<code>回调函数本身就是通过函数指针实现的，使用对象包装器可以取代函数指针的作用</code>，来看一下下面的例子：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;functional></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Test</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment">// 构造函数传入一个function包装器对象 并保存到成员变量中</span>
    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">const</span> function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span><span class="token operator">></span> <span class="token operator">&amp;</span>f<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">callback</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 执行回调函数</span>
    <span class="token keyword">void</span> <span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">callback</span><span class="token punctuation">(</span><span class="token string">"Hello World"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span><span class="token operator">></span> callback<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">TestB</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment">// 重载()运算符</span>
    <span class="token keyword">void</span>
    <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>string msg<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> msg <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    TestB testB<span class="token punctuation">;</span>

    <span class="token comment">// 重载了()运算符,所以对象当作函数使用</span>
    <span class="token function">testB</span><span class="token punctuation">(</span><span class="token string">"Hello World"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 仿函数通过包装器对象进行包装</span>

    Test <span class="token function">test</span><span class="token punctuation">(</span>testB<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 隐式转换为function包装器对象</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>通过上面的例子可以看出，使用对象包装器std::function可以非常方便的将仿函数转换为一个函数指针，通过进行函数指针的传递，在其他函数的合适的位置就可以调用这个包装好的仿函数了。</p>
<h3 id="11-3-bind绑定器"><a href="#11-3-bind绑定器" class="headerlink" title="11.3 bind绑定器"></a>11.3 bind绑定器</h3><p><code>std::bind用来将可调用对象与其参数一起进行绑定。绑定后的结果可以使用std::function进行保存，并延迟调用到任何我们需要的时候。</code>通俗来讲，它主要有两大作用：</p>
<ul>
<li>将<code>可调用对象与其参数一起绑定成一个仿函数</code>。</li>
<li><code>将多元（参数个数为n，n&gt;1）可调用对象转换为一元或者（n-1）元可调用对象，即只绑定部分参数</code>。</li>
</ul>
<p>绑定器函数使用语法格式如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 绑定非类成员函数/变量</span>
<span class="token keyword">auto</span> f <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span>可调用对象地址<span class="token punctuation">,</span> 绑定的参数<span class="token operator">/</span>占位符<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 绑定类成员函/变量</span>
<span class="token keyword">auto</span> f <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span>类函数<span class="token operator">/</span>成员地址<span class="token punctuation">,</span> 类实例对象地址<span class="token punctuation">,</span> 绑定的参数<span class="token operator">/</span>占位符<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>下面来看一个关于绑定器的实际使用的例子：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;functional></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">callFunc</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">const</span> function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token operator">&amp;</span> f<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">output</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">output_add</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">+</span> <span class="token number">10</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 使用绑定器绑定可调用对象和参数</span>
    <span class="token keyword">auto</span> f1 <span class="token operator">=</span> <span class="token function">bind</span><span class="token punctuation">(</span>output<span class="token punctuation">,</span> placeholders<span class="token double-colon punctuation">::</span>_1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">callFunc</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> f1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token keyword">auto</span> f2 <span class="token operator">=</span> <span class="token function">bind</span><span class="token punctuation">(</span>output_add<span class="token punctuation">,</span> placeholders<span class="token double-colon punctuation">::</span>_1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">callFunc</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> f2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>测试代码输出的结果:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">0</span> <span class="token number">2</span> <span class="token number">4</span> <span class="token number">6</span> <span class="token number">8</span>
<span class="token number">10</span> <span class="token number">12</span> <span class="token number">14</span> <span class="token number">16</span> <span class="token number">18</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>在上面的程序中，使用了std::bind绑定器，在函数外部通过绑定不同的函数，控制了最后执行的结果。<code>std::bind绑定器返回的是一个仿函数类型，得到的返回值可以直接赋值给一个std::function，在使用的时候我们并不需要关心绑定器的返回值类型，使用auto进行自动类型推导就可以了。</code></p>
<p><code>placeholders::_1</code>是一个占位符，<code>代表这个位置将在bind返回的仿0函数调用时被传入的第一个参数所替代。</code>同样还有其他的占位符<code>placeholders::_2、placeholders::_3、placeholders::_4、placeholders::_5等……</code></p>
<p>有了占位符的概念之后，使得std::bind的使用变得非常灵活:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;functional></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">output</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> y <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 使用绑定器绑定可调用对象和参数, 并调用得到的仿函数</span>
    <span class="token function">bind</span><span class="token punctuation">(</span>output<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">bind</span><span class="token punctuation">(</span>output<span class="token punctuation">,</span> placeholders<span class="token double-colon punctuation">::</span>_1<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">bind</span><span class="token punctuation">(</span>output<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> placeholders<span class="token double-colon punctuation">::</span>_1<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// error, 调用时没有第二个参数</span>
    <span class="token comment">// bind(output, 2, placeholders::_2)(10);</span>
    <span class="token comment">// 调用时第一个参数10被吞掉了，没有被使用</span>
    <span class="token function">bind</span><span class="token punctuation">(</span>output<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> placeholders<span class="token double-colon punctuation">::</span>_2<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">bind</span><span class="token punctuation">(</span>output<span class="token punctuation">,</span> placeholders<span class="token double-colon punctuation">::</span>_1<span class="token punctuation">,</span> placeholders<span class="token double-colon punctuation">::</span>_2<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">bind</span><span class="token punctuation">(</span>output<span class="token punctuation">,</span> placeholders<span class="token double-colon punctuation">::</span>_2<span class="token punctuation">,</span> placeholders<span class="token double-colon punctuation">::</span>_1<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>示例代码执行的结果:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>  <span class="token number">2</span>		// bind<span class="token punctuation">(</span>output, <span class="token number">1</span>, <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">10</span> <span class="token number">2</span>		// bind<span class="token punctuation">(</span>output, placeholders::_1, <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">2</span> <span class="token number">10</span>		// bind<span class="token punctuation">(</span>output, <span class="token number">2</span>, placeholders::_1<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">2</span> <span class="token number">20</span>		// bind<span class="token punctuation">(</span>output, <span class="token number">2</span>, placeholders::_2<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">10</span>, <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">10</span> <span class="token number">20</span>		// bind<span class="token punctuation">(</span>output, placeholders::_1, placeholders::_2<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">10</span>, <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">20</span> <span class="token number">10</span>		// bind<span class="token punctuation">(</span>output, placeholders::_2, placeholders::_1<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">10</span>, <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>通过测试可以看到，<code>std::bind可以直接绑定函数的所有参数，也可以仅绑定部分参数。在绑定部分参数的时候，通过使用std::placeholders来决定空位参数将会属于调用发生时的第几个参数。</code></p>
<p>可调用对象包装器<code>std::function是不能实现对类成员函数指针或者类成员指针的包装的</code>，但是通过<code>绑定器std::bind</code>的配合之后，就可以完美的解决这个问题了，再来看一个例子，然后再解释里边的细节：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;functional></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Test</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">output</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"x: "</span> <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> <span class="token string">", y: "</span> <span class="token operator">&lt;&lt;</span> y <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">int</span> m_number <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Test t<span class="token punctuation">;</span>
    <span class="token comment">// 绑定类成员函数</span>
    function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> f1 <span class="token operator">=</span> 
        <span class="token function">bind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Test<span class="token double-colon punctuation">::</span>output<span class="token punctuation">,</span> <span class="token operator">&amp;</span>t<span class="token punctuation">,</span> placeholders<span class="token double-colon punctuation">::</span>_1<span class="token punctuation">,</span> placeholders<span class="token double-colon punctuation">::</span>_2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 绑定类成员变量(公共)</span>
    function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token operator">></span> f2 <span class="token operator">=</span> <span class="token function">bind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Test<span class="token double-colon punctuation">::</span>m_number<span class="token punctuation">,</span> <span class="token operator">&amp;</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 调用</span>
    <span class="token function">f1</span><span class="token punctuation">(</span><span class="token number">520</span><span class="token punctuation">,</span> <span class="token number">1314</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">2333</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"t.m_number: "</span> <span class="token operator">&lt;&lt;</span> t<span class="token punctuation">.</span>m_number <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>示例代码输出的结果：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">x: <span class="token number">520</span>, y: <span class="token number">1314</span>
t.m_number: <span class="token number">2333</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>在用绑定器绑定类成员函数或者成员变量的时候需要将它们所属的实例对象一并传递到绑定器函数内部。<code>f1的类型是function&lt;void(int, int)&gt;，通过使用std::bind将Test的成员函数output的地址和对象t绑定，并转化为一个仿函数并存储到对象f1中</code>。</p>
<p><code>使用绑定器绑定的类成员变量m_number得到的仿函数被存储到了类型为function&lt;int&amp;(void)&gt;的包装器对象f2中，并且可以在需要的时候修改这个成员。其中int是绑定的类成员的类型，并且允许修改绑定的变量，因此需要指定为变量的引用，由于没有参数因此参数列表指定为void。</code></p>
<p>示例程序中是使用function包装器保存了bind返回的仿函数，如果不知道包装器的模板类型如何指定，可以直接使用auto进行类型的自动推导，这样使用起来会更容易一些。</p>
<h2 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h2><p>宏（Macro）是 C 和 C++ 等编程语言中预处理器的一种功能，用于在编译之前对代码进行文本替换。宏可以用来定义常量、简化重复代码或者实现一些条件编译功能。宏通常使用 <code>#define</code> 指令来定义。</p>
<p>以下是一些宏的基本特点和使用方式：</p>
<ol>
<li><p><strong>常量宏</strong>：<br>常量宏可以用于定义一些常量值。例如：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PI</span> <span class="token expression"><span class="token number">3.14159</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这种定义可以在代码中随处使用 <code>PI</code>，编译器在编译时会将 <code>PI</code> 替换为 <code>3.14159</code>。</p>
</li>
<li><p><strong>函数宏</strong>：<br>函数宏可以接受参数并进行替换，起到类似函数的效果。例如：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SQUARE</span><span class="token expression"><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>使用时，如果你写 <code>SQUARE(5)</code>，编译器会将其替换为 <code>((5) * (5))</code>。</p>
</li>
<li><p><strong>条件编译</strong>：<br>宏还可以用于条件编译。通过 <code>#ifdef</code>、<code>#ifndef</code>、<code>#if</code> 等指令，可以根据条件编译不同的代码块。例如：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">DEBUG</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">LOG</span><span class="token expression"><span class="token punctuation">(</span>x<span class="token punctuation">)</span> cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">LOG</span><span class="token expression"><span class="token punctuation">(</span>x<span class="token punctuation">)</span> </span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里，只有在定义了 <code>DEBUG</code> 的情况下，<code>LOG(x)</code> 才会输出日志信息。</p>
</li>
<li><p><strong>优势和劣势</strong>：</p>
<ul>
<li>优势：宏可以减少代码重复，提高可维护性，支持条件编译等功能。</li>
<li>劣势：宏在替换时没有类型检查，可能导致代码难以调试。此外，过度使用宏会使代码不易阅读和理解。</li>
</ul>
</li>
</ol>
<h2 id="左值引用和右值引用"><a href="#左值引用和右值引用" class="headerlink" title="左值引用和右值引用"></a>左值引用和右值引用</h2><p>在C++中，<code>左值引用（lvalue reference）</code>和<code>右值引用（rvalue reference）</code>是两种不同的引用类型，用于处理不同类型的数据和场景。</p>
<h3 id="左值引用（lvalue-reference）"><a href="#左值引用（lvalue-reference）" class="headerlink" title="左值引用（lvalue reference）"></a>左值引用（lvalue reference）</h3><p><strong>定义</strong>：<br>左值引用是C++中传统的引用类型，用法是 <code>T&amp;</code>，其中 <code>T</code> 是被引用的类型。</p>
<p><strong>特点</strong>：</p>
<ol>
<li><strong>绑定左值</strong>：左值引用只能绑定到左值。左值是具有持久存储的表达式，可以出现在赋值操作符的左侧(可以取地址的变量)。</li>
<li><strong>修改性</strong>：除非引用本身被声明为 <code>const</code>，否则可以通过左值引用来修改被引用的对象。</li>
<li><strong>语法</strong>：使用 <code>&amp;</code> 符号声明。</li>
</ol>
<p><strong>示例</strong>：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span><span class="token operator">&amp;</span> ref_a <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment">// 左值引用绑定到左值 a</span>

    ref_a <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span> <span class="token comment">// 修改 a 的值</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"a: "</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 输出 20</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="右值引用（rvalue-reference）"><a href="#右值引用（rvalue-reference）" class="headerlink" title="右值引用（rvalue reference）"></a>右值引用（rvalue reference）</h3><p><strong>定义</strong>：<br>右值引用是C++11引入的一种新的引用类型，用法是 <code>T&amp;&amp;</code>，其中 <code>T</code> 是被引用的类型。</p>
<p><strong>特点</strong>：</p>
<ol>
<li><strong>绑定右值</strong>：右值引用可以绑定到右值。右值是<code>临时对象或字面量</code>，不能出现在赋值操作符的左侧。</li>
<li><strong>移动语义</strong>：右值引用的主要目的是实现移动语义，允许资源从一个对象转移到另一个对象，从而提高性能和减少不必要的复制。</li>
<li><strong>语法</strong>：使用 <code>&amp;&amp;</code> 符号声明。</li>
</ol>
<p><strong>示例</strong>：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;utility></span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> ref_a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">// 右值引用绑定到右值 10(字面量)</span>

    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ref_a: "</span> <span class="token operator">&lt;&lt;</span> ref_a <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 输出 10</span>

    <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
    <span class="token comment">// 下面的代码会报错，因为右值引用不能绑定到左值</span>
    <span class="token comment">// int&amp;&amp; ref_b = b;</span>

    <span class="token comment">// 使用 std::move 将左值转换为右值</span>
    <span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> ref_c <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ref_c: "</span> <span class="token operator">&lt;&lt;</span> ref_c <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 输出 20</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"b: "</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>         <span class="token comment">// 输出 20，但 b 的值可能被移动后变为未定义</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="区别总结"><a href="#区别总结" class="headerlink" title="区别总结"></a>区别总结</h3><table>
<thead>
<tr>
<th>特性</th>
<th>左值引用 (<code>T&amp;</code>)</th>
<th>右值引用 (<code>T&amp;&amp;</code>)</th>
</tr>
</thead>
<tbody><tr>
<td>绑定对象</td>
<td>左值（持久存储的表达式）</td>
<td>右值（临时对象或字面量）</td>
</tr>
<tr>
<td>语法</td>
<td><code>T&amp;</code></td>
<td><code>T&amp;&amp;</code></td>
</tr>
<tr>
<td>移动语义</td>
<td>不支持</td>
<td>支持，用于资源转移</td>
</tr>
<tr>
<td>修改性</td>
<td>可以修改（除非是 <code>const</code>）</td>
<td>可以修改（除非是 <code>const</code>）</td>
</tr>
<tr>
<td>示例</td>
<td><code>int&amp; ref_a = a;</code></td>
<td><code>int&amp;&amp; ref_b = 10;</code></td>
</tr>
</tbody></table>
<h3 id="进一步理解"><a href="#进一步理解" class="headerlink" title="进一步理解"></a>进一步理解</h3><ul>
<li><strong>左值</strong>：可以出现在赋值操作符左侧的表达式。例如，变量 <code>a</code> 是左值。</li>
<li><strong>右值</strong>：不能出现在赋值操作符左侧的表达式。例如，字面量 <code>10</code> 是右值。</li>
<li>**<code>std::move</code>**：这是一个标准库函数，用于将左值转换为右值引用，从而允许资源的移动。</li>
</ul>
<p>通过理解左值引用和右值引用，你可以更有效地利用C++11的特性来编写高性能的代码。</p>
<h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><ul>
<li><strong>进程</strong>：是指程序的一次执行过程，是操作系统进行资源分配的基本单位。每个进程都有独立的地址空间、内存、数据栈和其他辅助数据结构等资源</li>
<li><strong>线程</strong>：是进程内的一个执行单元，<code>是 CPU 调度和分派的基本单位</code>。<code>线程是比进程更小的能独立运行的基本单位</code>。一个进程可以包含一个或多个线程，这些线程共享进程的资源</li>
</ul>
<p>进程和线程是操作系统中的两个核心概念，它们的主要区别如下：</p>
<h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. <strong>定义</strong></h3><ul>
<li><strong>进程</strong>：是指程序的一次执行过程，是操作系统进行资源分配的基本单位。每个进程都有独立的地址空间、内存、数据栈和其他辅助数据结构（如进程控制块）来跟踪其执行状态。</li>
<li><strong>线程</strong>：是进程内的一个执行单元，是 CPU 调度和分派的基本单位。线程是比进程更小的能独立运行的基本单位。一个进程可以包含一个或多个线程，这些线程共享进程的资源。</li>
</ul>
<h3 id="2-资源分配"><a href="#2-资源分配" class="headerlink" title="2. 资源分配"></a>2. <strong>资源分配</strong></h3><ul>
<li><strong>进程</strong>：每个进程都有独立的内存空间和系统资源（如文件描述符、信号量、内核对象等）。这种隔离性确保一个进程的崩溃不会直接影响到其他进程，提升了系统的稳定性和安全性。</li>
<li><strong>线程</strong>：线程共享同一进程的内存空间和资源，使得它们能够高效地交换数据和信息。但这也带来了风险：一个线程的错误可能导致整个进程崩溃，影响其他线程的正常运行。</li>
</ul>
<h3 id="3-上下文切换"><a href="#3-上下文切换" class="headerlink" title="3. 上下文切换"></a>3. <strong>上下文切换</strong></h3><ul>
<li><strong>进程上下文切换</strong>：进程切换涉及到保存和恢复大量的上下文信息，包括内存管理信息（如页表）、CPU寄存器和其他资源信息。这种切换开销较大，导致进程间的切换效率较低。</li>
<li><strong>线程上下文切换</strong>：线程切换相对轻便，因为它们共享同一进程的内存空间，只需保存和恢复少量信息（如寄存器状态和栈指针）。这种低开销使得线程在需要频繁切换执行上下文的高并发场景下更加高效。</li>
</ul>
<h3 id="4-通信方式"><a href="#4-通信方式" class="headerlink" title="4. 通信方式"></a>4. <strong>通信方式</strong></h3><ul>
<li><strong>进程间通信（IPC）</strong>：由于进程具有独立的内存空间，进程间的通信需要通过特定的IPC机制，如管道、消息队列、共享内存等。</li>
<li><strong>线程间通信</strong>：由于线程共享同一进程的内存，线程间的通信可以通过共享变量来实现，效率更高。但这也引入了并发访问的问题，需要通过同步机制（如互斥锁、信号量、条件变量等）来保证数据的一致性和正确性。</li>
</ul>
<h3 id="5-应用场景"><a href="#5-应用场景" class="headerlink" title="5. 应用场景"></a>5. <strong>应用场景</strong></h3><ul>
<li><strong>多进程</strong>：适用于需要高可靠性和隔离性的场景。例如，服务器的每个请求可以使用独立的进程，这样一个进程的崩溃不会影响到其他进程，增强了系统的稳定性和安全性。</li>
<li><strong>多线程</strong>：适用于需要快速响应和高效资源利用的场景。例如，图形用户界面应用程序通常使用多线程来处理用户输入、后台任务和界面更新，以提高用户体验和系统响应能力。</li>
</ul>
<h3 id="6-性能考虑"><a href="#6-性能考虑" class="headerlink" title="6. 性能考虑"></a>6. <strong>性能考虑</strong></h3><ul>
<li><strong>进程</strong>：由于进程的隔离性，虽然可以提供更好的安全性和稳定性，但也会引入较大的性能开销，特别是在需要频繁创建和销毁进程的场景。</li>
<li><strong>线程</strong>：线程在性能上更具优势，适合于高并发和高响应要求的应用场景。然而，线程间的共享资源管理和同步问题也可能导致复杂性和性能下降，尤其是在锁争用和上下文切换频繁的情况下。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://0zxm.github.io">0zxm</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://0zxm.github.io/2024/12/25/cpp11-xin-te-xing/">https://0zxm.github.io/2024/12/25/cpp11-xin-te-xing/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://0zxm.github.io" target="_blank">0zxm</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/c/">c++</a></div><div class="post-share"><div class="social-share" data-image="/img/cover1.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/wechat.png" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/01/01/qlabel-tian-jia-dian-ji-chu-li/" title="QLabel添加点击处理"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default_cover.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">QLabel添加点击处理</div></div><div class="info-2"><div class="info-item-1">Qt框架中添加QLabel的点击事件</div></div></div></a><a class="pagination-related" href="/2024/12/12/shu-ju-wa-jue-da-zuo-ye/" title="数据挖掘大作业"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">数据挖掘大作业</div></div><div class="info-2"><div class="info-item-1">数据挖掘课程大作业</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/02/14/cpp-mian-shi-ti/" title="Cpp面试题"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default_cover.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-14</div><div class="info-item-2">Cpp面试题</div></div><div class="info-2"><div class="info-item-1">面试题</div></div></div></a><a class="pagination-related" href="/2024/07/17/c-cheng-xu-she-ji/" title="C++程序设计"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover2.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-17</div><div class="info-item-2">C++程序设计</div></div><div class="info-2"><div class="info-item-1">c++编程</div></div></div></a><a class="pagination-related" href="/2025/01/09/cpp-wang-luo-tong-xin-zhi-feng-zhuang-http-xie-yi/" title="cpp网络通信之封装http协议"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover2.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-09</div><div class="info-item-2">cpp网络通信之封装http协议</div></div><div class="info-2"><div class="info-item-1">使用WinSock2的API封装出http协议便于使用</div></div></div></a><a class="pagination-related" href="/2025/01/07/c-wang-luo-tong-xin/" title="C++网络通信"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover2.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-07</div><div class="info-item-2">C++网络通信</div></div><div class="info-2"><div class="info-item-1">c++多种方式实现网络通信</div></div></div></a><a class="pagination-related" href="/2024/06/21/suan-fa/" title="算法"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover2.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-21</div><div class="info-item-2">算法</div></div><div class="info-2"><div class="info-item-1">算法课笔记</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/favicon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">0zxm</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">51</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">59</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/0zxm"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/0zxm" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:m15813109801@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="http://0zxm.github.io" target="_blank" title="博客"><i class="fab fa-algolia" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-c-%E5%8E%9F%E5%A7%8B%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-text">1.c++原始字面量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-text">1.1 什么是字面量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%8E%9F%E5%A7%8B%E5%AD%97%E9%9D%A2%E9%87%8F%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7"><span class="toc-text">1.2 原始字面量的必要性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%8C%87%E9%92%88%E7%A9%BA%E5%80%BC%E7%B1%BB%E5%9E%8Bnullptr"><span class="toc-text">2.指针空值类型nullptr</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E5%92%8C%E6%98%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2%E7%9A%84%E5%BF%85%E8%A6%81"><span class="toc-text">2.1 隐式转换和显式转换的必要</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-constexpr%E6%96%B0%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">3.constexpr新关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-const%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">3.1 const关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-constexpr%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">3.2 constexpr常量表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%87%BD%E6%95%B0"><span class="toc-text">3.3 常量表达式函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a-%E4%BF%AE%E9%A5%B0%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0"><span class="toc-text">a. 修饰普通函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-text">b. 修饰成员函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c-%E4%BF%AE%E9%A5%B0%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0"><span class="toc-text">c. 修饰模板函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#d-%E4%BF%AE%E9%A5%B0%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">d. 修饰构造函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-auto%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC"><span class="toc-text">4.auto类型推导</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-auto%E7%9A%84%E6%8E%A8%E5%AF%BC%E8%A7%84%E5%88%99"><span class="toc-text">4.1 auto的推导规则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a-%E8%87%AA%E5%8A%A8%E5%AD%98%E5%82%A8%E6%9C%9F"><span class="toc-text">a. 自动存储期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-auto%E7%9A%84%E6%8E%A8%E5%AF%BC%E8%A7%84%E5%88%99"><span class="toc-text">b. auto的推导规则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-auto%E7%9A%84%E9%99%90%E5%88%B6"><span class="toc-text">4.2 auto的限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-auto%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">4.3 auto的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-decltype%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">4.4 decltype关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-decltype%E7%9A%84%E6%8E%A8%E5%AF%BC%E8%A7%84%E5%88%99"><span class="toc-text">4.5 decltype的推导规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-decltype%E5%9C%A8%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">4.6 decltype在泛型编程的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%90%8E%E7%BD%AE-%E5%A3%B0%E6%98%8E%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B"><span class="toc-text">4.7 返回类型的后置(声明返回类型?)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-final%E5%92%8Coverride"><span class="toc-text">5. final和override</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-final-%E4%BF%AE%E9%A5%B0%E5%87%BD%E6%95%B0"><span class="toc-text">5.1 final 修饰函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-final-%E4%BF%AE%E9%A5%B0%E7%B1%BB"><span class="toc-text">5.2 final 修饰类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-overide"><span class="toc-text">5.3 overide</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%A8%A1%E6%9D%BF%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-text">6. 模板的优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E6%A8%A1%E6%9D%BF%E5%B5%8C%E5%A5%97%E5%8F%B3%E5%B0%96%E6%8B%AC%E5%8F%B7%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-text">6.1 模板嵌套右尖括号的优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E9%BB%98%E8%AE%A4%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0"><span class="toc-text">6.2 默认模板参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-using%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">7. using关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E7%BB%99%E7%B1%BB%E5%AE%9A%E4%B9%89%E5%88%AB%E5%90%8D"><span class="toc-text">7.1 给类定义别名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E7%BB%99%E6%A8%A1%E6%9D%BF%E5%AE%9A%E4%B9%89%E5%88%AB%E5%90%8D"><span class="toc-text">7.2 给模板定义别名</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%A7%94%E6%89%98%E6%9E%84%E9%80%A0%E5%92%8C%E7%BB%A7%E6%89%BF%E6%9E%84%E9%80%A0"><span class="toc-text">8. 委托构造和继承构造</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-%E5%A7%94%E6%89%98%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">8.1 委托构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-%E7%BB%A7%E6%89%BF%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">8.2 继承构造函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="toc-text">9. 初始化列表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-%E7%BB%9F%E4%B8%80%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E5%BC%8F"><span class="toc-text">9.1 统一的初始化方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BB%86%E8%8A%82"><span class="toc-text">9.2 列表初始化细节</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a-%E8%81%9A%E5%90%88%E4%BD%93"><span class="toc-text">a. 聚合体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-%E9%9D%9E%E8%81%9A%E5%90%88%E4%BD%93"><span class="toc-text">b. 非聚合体</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-std-initializer-list"><span class="toc-text">9.3 std::initializer_list</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a-%E4%BD%9C%E4%B8%BA%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-text">a. 作为普通函数参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-%E4%BD%9C%E4%B8%BA%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-text">b. 作为构造函数参数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E5%9F%BA%E4%BA%8E%E8%8C%83%E5%9B%B4%E7%9A%84for%E5%BE%AA%E7%8E%AF"><span class="toc-text">10. 基于范围的for循环</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-for%E5%BE%AA%E7%8E%AF%E7%9A%84%E6%96%B0%E8%AF%AD%E6%B3%95"><span class="toc-text">10.1 for循环的新语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82"><span class="toc-text">10.2 使用细节</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a-%E5%85%B3%E7%B3%BB%E5%9E%8B%E5%AE%B9%E5%99%A8"><span class="toc-text">a. 关系型容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-%E5%85%83%E7%B4%A0%E5%8F%AA%E8%AF%BB"><span class="toc-text">b. 元素只读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c-%E8%AE%BF%E9%97%AE%E6%AC%A1%E6%95%B0"><span class="toc-text">c. 访问次数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1%E5%8C%85%E8%A3%85%E5%99%A8%E3%80%81%E7%BB%91%E5%AE%9A%E5%99%A8"><span class="toc-text">11. 可调用对象包装器、绑定器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1-%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1"><span class="toc-text">11.1 可调用对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1%E5%8C%85%E8%A3%85%E5%99%A8"><span class="toc-text">11.2 可调用对象包装器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-3-bind%E7%BB%91%E5%AE%9A%E5%99%A8"><span class="toc-text">11.3 bind绑定器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8F"><span class="toc-text">宏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E5%92%8C%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-text">左值引用和右值引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%EF%BC%88lvalue-reference%EF%BC%89"><span class="toc-text">左值引用（lvalue reference）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%EF%BC%88rvalue-reference%EF%BC%89"><span class="toc-text">右值引用（rvalue reference）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB%E6%80%BB%E7%BB%93"><span class="toc-text">区别总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E4%B8%80%E6%AD%A5%E7%90%86%E8%A7%A3"><span class="toc-text">进一步理解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">进程和线程的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89"><span class="toc-text">1. 定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D"><span class="toc-text">2. 资源分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-text">3. 上下文切换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-text">4. 通信方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">5. 应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%80%A7%E8%83%BD%E8%80%83%E8%99%91"><span class="toc-text">6. 性能考虑</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/02/15/pyqt-xie-yi-ge-dai-ban-cheng-xu/" title="pyqt写一个待办程序"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="pyqt写一个待办程序"/></a><div class="content"><a class="title" href="/2025/02/15/pyqt-xie-yi-ge-dai-ban-cheng-xu/" title="pyqt写一个待办程序">pyqt写一个待办程序</a><time datetime="2025-02-15T05:34:39.000Z" title="发表于 2025-02-15 13:34:39">2025-02-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/02/14/cpp-mian-shi-ti/" title="Cpp面试题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default_cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Cpp面试题"/></a><div class="content"><a class="title" href="/2025/02/14/cpp-mian-shi-ti/" title="Cpp面试题">Cpp面试题</a><time datetime="2025-02-14T03:02:20.000Z" title="发表于 2025-02-14 11:02:20">2025-02-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/15/django-he-vue3-qian-hou-duan-fen-chi-kai-fa/" title="Django和Vue3前后端补充知识点"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Django和Vue3前后端补充知识点"/></a><div class="content"><a class="title" href="/2025/01/15/django-he-vue3-qian-hou-duan-fen-chi-kai-fa/" title="Django和Vue3前后端补充知识点">Django和Vue3前后端补充知识点</a><time datetime="2025-01-15T05:51:37.000Z" title="发表于 2025-01-15 13:51:37">2025-01-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/12/vue3-typescript/" title="Vue3+Typescript"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Vue3+Typescript"/></a><div class="content"><a class="title" href="/2025/01/12/vue3-typescript/" title="Vue3+Typescript">Vue3+Typescript</a><time datetime="2025-01-12T05:46:38.000Z" title="发表于 2025-01-12 13:46:38">2025-01-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/12/qt-liu-lan-qi-yin-qing-de-shi-yong-he-wang-luo-qing-qiu/" title="Qt浏览器引擎的使用和网络请求"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Qt浏览器引擎的使用和网络请求"/></a><div class="content"><a class="title" href="/2025/01/12/qt-liu-lan-qi-yin-qing-de-shi-yong-he-wang-luo-qing-qiu/" title="Qt浏览器引擎的使用和网络请求">Qt浏览器引擎的使用和网络请求</a><time datetime="2025-01-12T03:04:20.000Z" title="发表于 2025-01-12 11:04:20">2025-01-12</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/footer.jpg);"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By 0zxm</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }
      
      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>