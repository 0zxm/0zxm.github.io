<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>cpp11新特性 | 0zxm</title><meta name="author" content="0zxm"><meta name="copyright" content="0zxm"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="c++11版本语法的新特性">
<meta property="og:type" content="article">
<meta property="og:title" content="cpp11新特性">
<meta property="og:url" content="https://0zxm.github.io/2024/12/25/cpp11-xin-te-xing/index.html">
<meta property="og:site_name" content="0zxm">
<meta property="og:description" content="c++11版本语法的新特性">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://0zxm.github.io/img/default_cover.jpg">
<meta property="article:published_time" content="2024-12-25T12:52:06.000Z">
<meta property="article:modified_time" content="2025-01-06T13:20:35.736Z">
<meta property="article:author" content="0zxm">
<meta property="article:tag" content="c++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://0zxm.github.io/img/default_cover.jpg"><link rel="shortcut icon" href="/favicon.png"><link rel="canonical" href="https://0zxm.github.io/2024/12/25/cpp11-xin-te-xing/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        if (name && globalFn[key][name]) return
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"prismjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: 0zxm","link":"链接: ","source":"来源: 0zxm","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'cpp11新特性',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-01-06 21:20:35'
}</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/favicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">45</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">56</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/src/"><i class="fa-fw fas fa-cloud"></i><span> 资源</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo/"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/default_cover.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">0zxm</span></a><a class="nav-page-title" href="/"><span class="site-name">cpp11新特性</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/src/"><i class="fa-fw fas fa-cloud"></i><span> 资源</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo/"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">cpp11新特性</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-12-25T12:52:06.000Z" title="发表于 2024-12-25 20:52:06">2024-12-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-01-06T13:20:35.736Z" title="更新于 2025-01-06 21:20:35">2025-01-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/c/">c++</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">14.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>57分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1bX4y1G7ks/">bilibili教程</a></p>
<p><a target="_blank" rel="noopener" href="https://subingwen.cn/cpp/constexpr/#1-1-const">部分引用自</a></p>
<h2 id="1-c-原始字面量"><a href="#1-c-原始字面量" class="headerlink" title="1.c++原始字面量"></a>1.c++原始字面量</h2><h3 id="1-1-什么是字面量"><a href="#1-1-什么是字面量" class="headerlink" title="1.1 什么是字面量"></a>1.1 什么是字面量</h3><p>在编程语言中，“字面量”（Literal）是指在源代码中直接表示某一固定值的符号。字面量是编程语言中最基本的数据表示方式之一，它们是编译时已知的常量值，不需要通过变量或其他表达式计算得到。以下是一些常见的字面量类型：</p>
<ol>
<li><p><strong>数值字面量</strong>：直接表示数字的字面量，如整数、浮点数等。</p>
<ul>
<li>整数：<code>123</code>，<code>0xFF</code>（十六进制），<code>0b1010</code>（二进制）等。</li>
<li>浮点数：<code>3.14</code>，<code>2.5e-3</code>（科学记数法）等。</li>
</ul>
</li>
<li><p><strong>字符字面量</strong>：用单引号括起来的单个字符，如 <code>&#39;A&#39;</code>、<code>&#39;5&#39;</code>、<code>&#39;\n&#39;</code>（换行符）等。</p>
</li>
<li><p><strong>字符串字面量</strong>：用双引号括起来的字符序列，如 <code>&quot;Hello, World!&quot;</code>。</p>
</li>
<li><p><strong>布尔字面量</strong>：表示逻辑值的字面量，如 <code>true</code> 和 <code>false</code>。</p>
</li>
<li><p><strong>空字面量</strong>：表示空值的字面量，如 C++11 中的 <code>nullptr</code>。</p>
</li>
<li><p><strong>复合字面量</strong>：某些语言支持复合字面量，如数组或结构体的初始化。</p>
<ul>
<li>数组：<code>int arr[] = &#123;1, 2, 3&#125;;</code></li>
<li>结构体：<code>Point p = &#123;10, 20&#125;;</code></li>
</ul>
</li>
</ol>
<p>字面量在编程中非常重要，因为它们提供了一种简洁的方式来表示和使用常量值。在编译过程中，字面量会被替换为它们对应的值，这有助于提高代码的可读性和效率。</p>
<h3 id="1-2-原始字面量的必要性"><a href="#1-2-原始字面量的必要性" class="headerlink" title="1.2 原始字面量的必要性"></a>1.2 原始字面量的必要性</h3><p><code>字符串&quot;h\t&quot;</code>会产生歧义,因为<code>\</code>在c++中是转义字符,<code>\t</code>可以表示制表符,所以输出可能不是你想的预期结果</p>
<ul>
<li>反斜杠可以将原始字符转成有特殊含义的字符,<code>\r</code>,<code>\n</code>,<code>\t</code>分别表示回车,换行以及制表符</li>
<li>反斜杠同样可以将有特殊含义的字符转成原始字符,例如<code>\\t</code>在输出的时候将会被看作一个普通的t来输出</li>
</ul>
<p>所以,使用原始字面量就很有必要了,在c++11及以后的版本中,可以使用<code>R&quot;xxx(你想输出的原始字符串的内容)xxx&quot;</code>来输出不会被转义的字符串常量,其中xxx是对原始字面量的描述,在编译时会被省略.</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    string s1 <span class="token operator">=</span> <span class="token string">"hello \
    world"</span><span class="token punctuation">;</span> <span class="token comment">// 使用连接符连接多个字符串</span>

    string s2 <span class="token operator">=</span> <span class="token raw-string string">R"(hello
    world)"</span><span class="token punctuation">;</span> <span class="token comment">// 使用原始字符串字面量的时候可以不用加连接符,语法不会错</span>

    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token raw-string string">R"(h\ello world)"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>           <span class="token comment">// 原始字面量</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token raw-string string">R"hello(h\ello world)hello"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 描述内容必须一样,并且不能为中文</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"h\t"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>                                 <span class="token comment">// 不使用原始字面量</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"h\\t"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>                                <span class="token comment">// 使用两个反斜杠转义</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="2-指针空值类型nullptr"><a href="#2-指针空值类型nullptr" class="headerlink" title="2.指针空值类型nullptr"></a>2.指针空值类型nullptr</h2><p><code>NULL</code> 是一个在 C 和 C++ 编程语言中广泛使用的宏定义，它表示一个空指针常量，即一个不指向任何对象或函数的指针。<code>NULL</code> 的值通常是 <code>0</code>（在大多数平台上），但这个定义允许编译器和运行时系统识别它是一个空指针，而不是一个普通的整数。</p>
<p>在 C 语言中，<code>NULL</code> 被定义在 <code>&lt;stddef.h&gt;</code> 或 <code>&lt;stdlib.h&gt;</code> 头文件中，而在 C++ 中，它被定义在 <code>&lt;cstddef&gt;</code> 或 <code>&lt;cstdlib&gt;</code> 头文件中。<code>NULL</code> 的定义如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NULL</span> <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>或者在 C++ 中：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/* A null pointer constant.  */</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token function">defined</span> <span class="token punctuation">(</span>_STDDEF_H<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">defined</span> <span class="token punctuation">(</span>__need_NULL<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">undef</span> <span class="token expression"><span class="token constant">NULL</span>		</span><span class="token comment">/* in case &lt;stdio.h> has defined it. */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token function">defined</span><span class="token punctuation">(</span>__GNUG__<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> __GNUG__ <span class="token operator">>=</span> <span class="token number">3</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NULL</span> <span class="token expression">__null</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span>   <span class="token comment">/* G++ */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">__cplusplus</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NULL</span> <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span>   <span class="token comment">/* C++ */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">_WIN64</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NULL</span> <span class="token expression"><span class="token number">0</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NULL</span> <span class="token expression"><span class="token number">0LL</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span>  <span class="token comment">/* W64 */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span>  <span class="token comment">/* C++ */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span>  <span class="token comment">/* G++ */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span>	<span class="token comment">/* NULL not defined and &lt;stddef.h> or need NULL.  */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">undef</span>	<span class="token expression">__need_NULL</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在 C++11 及以后的版本中，<code>NULL</code> 被 <code>nullptr</code> 取代，因为 <code>nullptr</code> 是一个类型安全的关键字，它只能被用来表示空指针。<code>nullptr</code> 的类型是 <code>std::nullptr_t</code>，它是一个特殊的指针类型，可以被隐式转换为任何指针类型或引用类型，但不能转换为其他类型。</p>
<p>在给<code>int*</code>变量初始化的时候会被自动转成<code>int*</code>类型</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"func(int p) called"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"func(char* p) called"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token keyword">const</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>ptr1 <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">// 空指针,会被隐式转换</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>ptr1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> ptr1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 输出 0</span>
    <span class="token keyword">double</span> <span class="token operator">*</span>ptr2 <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>ptr3 <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>ptr4 <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token comment">// void * ptr4 = (void *)0;</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>ptr <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span> <span class="token comment">// 自动隐式转换成 "int *" 类型</span>

    <span class="token comment">// int *ptr5 = ptr4;     //"void *" 类型的值不能用于初始化 "int *" 类型的实体C/C++,这在C++11中是不允许的</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>ptr5 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span>ptr4<span class="token punctuation">;</span> <span class="token comment">// 显式类型转换</span>

    <span class="token function">func</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用func(int p)函数</span>
    <span class="token comment">// func(NULL); // 还是使用 func(int p)函数，因为NULL是其实是一个(void *)0</span>

    <span class="token comment">// 所以想调用func(char* p)函数，需要使用nullptr关键字</span>
    <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用func(char* p)函数</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>使用 <code>NULL</code> 或 <code>nullptr</code> 而不是直接使用 <code>0</code> 作为空指针的理由是：</p>
<ol>
<li><strong>类型安全</strong>：<code>NULL</code> 和 <code>nullptr</code> 提供了类型安全的空指针表示，它们明确地告诉编译器这是一个指针值，而不是一个整数。</li>
<li><strong>可移植性</strong>：不同的系统和编译器可能有不同的空指针表示，使用 <code>NULL</code> 或 <code>nullptr</code> 可以确保代码的可移植性。</li>
<li><strong>清晰性</strong>：在代码中使用 <code>NULL</code> 或 <code>nullptr</code> 可以提高代码的可读性，让其他开发者更容易理解代码的意图。</li>
<li><strong>避免歧义</strong>：在某些上下文中，<code>0</code> 可能被解释为整数，而 <code>NULL</code> 或 <code>nullptr</code> 明确表示这是一个空指针。</li>
</ol>
<h3 id="2-1-隐式转换和显式转换的必要"><a href="#2-1-隐式转换和显式转换的必要" class="headerlink" title="2.1 隐式转换和显式转换的必要"></a>2.1 隐式转换和显式转换的必要</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stddef.h></span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression"><span class="token constant">NULL</span></span></span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"NULL is defined as: "</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">NULL</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// NULL is defined as: 0</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>

    <span class="token comment">// void *ptr = NULL;</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>ptr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// ptr就是把0转化为指向void类型的指针,类似于内存0???</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>ptr2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span>ptr<span class="token punctuation">;</span> <span class="token comment">// ptr2就是指向0的int指针</span>
    <span class="token comment">// int *ptr5 = ptr;         // 不合法, 因为ptr5的类型是int*，而ptr的类型是void*,需要进行类型转换</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ptr: "</span> <span class="token operator">&lt;&lt;</span> ptr <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ptr2: "</span> <span class="token operator">&lt;&lt;</span> ptr2 <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token comment">// std::cout &lt;&lt; "ptr5: " &lt;&lt; ptr5 &lt;&lt; std::endl;</span>

    <span class="token keyword">int</span> <span class="token operator">*</span>ptr_i <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">// NULL相当于0</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>ptr_i_ <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression"><span class="token constant">NULL</span></span></span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"NULL is defined as: "</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">NULL</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="3-constexpr新关键字"><a href="#3-constexpr新关键字" class="headerlink" title="3.constexpr新关键字"></a>3.constexpr新关键字</h2><h3 id="3-1-const关键字"><a href="#3-1-const关键字" class="headerlink" title="3.1 const关键字"></a>3.1 const关键字</h3><p>在C++11之前只有<code>const关键字</code>，从功能上来说这个关键字有双重语义：<code>变量只读</code>，<code>修饰常量</code>，举一个简单的例子：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> num<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">const</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">24</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> array<span class="token punctuation">[</span>num<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment">// 报错，num是一个只读变量，不是常量 因为const修饰参数</span>
    <span class="token keyword">int</span> array1<span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token comment">// ok，count是一个常量</span>

    <span class="token keyword">int</span> a1 <span class="token operator">=</span> <span class="token number">520</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> a2 <span class="token operator">=</span> <span class="token number">250</span><span class="token punctuation">;</span>
   	<span class="token keyword">int</span> array2<span class="token punctuation">[</span>a1<span class="token punctuation">]</span><span class="token punctuation">;</span>				<span class="token comment">// 报错, 定义数组不能使用变量</span>
    
    <span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> b <span class="token operator">=</span> a1<span class="token punctuation">;</span>
    b <span class="token operator">=</span> a2<span class="token punctuation">;</span>                         <span class="token comment">// 报错</span>
    a1 <span class="token operator">=</span> <span class="token number">1314</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"b: "</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>     <span class="token comment">// 输出结果为1314</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>函数 <code>void func(const int num)</code> 的参数 <code>num</code> 表示这个变量是只读的，但不是常量，因此使用 <code>int array[num];</code> 这种方式定义一个数组，编译器是会报错的，提示 <code>num不可用作为常量来使用。</code></li>
<li><code>const int count = 24;</code>中的<code>count</code>却是一个常量，因此可以使用这个常量来定义一个静态数组。</li>
</ul>
<p>另外，<code>变量只读并不等价于常量</code>，二者是两个概念不能混为一谈，分析一下这句测试代码<code>const int&amp; b = a1;</code></p>
<ul>
<li>b是一个常量的引用，所以 <code>b</code> 引用的变量是不能被修改的，也就是说 <code>b = a2; </code> 这句代码语法是错误的。</li>
<li>语句的<code>const</code> 对于 <code>变量a1</code> 是没有任何约束的，a1 的值变了 b 的值也就变了</li>
<li>引用b是<code>只读的</code>，但是并不能保证它的值是不可改变的，也就是说它不是常量。</li>
</ul>
<h3 id="3-2-constexpr常量表达式"><a href="#3-2-constexpr常量表达式" class="headerlink" title="3.2 constexpr常量表达式"></a>3.2 constexpr常量表达式</h3><p>在C++11中添加了一个新的关键字 <code>constexpr</code>，这个关键字是用来修饰 <code>常量表达式</code> 的。所谓常量表达式，指的就是<code>由多个（≥1）常量（值不会改变）组成并且在编译过程中就得到计算结果的表达式</code>。</p>
<p>在介绍<code>gcc/g++工作流程</code>的时候说过，C++ 程序从编写完毕到执行分为四个阶段：<code>预处理</code>、 <code>编译</code>、<code>汇编</code>和<code>链接</code>4个阶段，得到可执行程序之后就可以运行了。需要额外强调的是，<code>常量表达式和非常量表达式的计算时机不同，非常量表达式只能在程序运行阶段计算出结果，但是常量表达式的计算往往发生在程序的编译阶段，这可以极大提高程序的执行效率，因为表达式只需要在编译阶段计算一次，节省了每次程序运行时都需要计算一次的时间。</code></p>
<p>那么问题来了，<code>编译器如何识别</code>表达式是不是常量表达式呢？在C++11中添加了 <code>constexpr</code> 关键字之后就可以在程序中使用它来修饰常量表达式，用来提高程序的执行效率。在使用中建议将 <code>const</code> 和 <code>constexpr</code> 的功能区分开，即凡是表达<code>“只读”语义</code>的场景都使用 <code>const</code>，表达<code>“常量”语义</code>的场景都使用 <code>constexpr</code>。</p>
<p>在定义常量的时候,使用<code>const</code>和<code>constexpr</code>都可以:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>          <span class="token comment">// 常量表达式</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> doubled <span class="token operator">=</span> num <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 常量表达式</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">constexpr</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>     <span class="token comment">// 常量表达式</span>
<span class="token keyword">constexpr</span> <span class="token keyword">int</span> b <span class="token operator">=</span> a <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment">// 常量表达式</span>
<span class="token keyword">constexpr</span> <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 报错 => 不能作为常量表达式,因为func()在运行时才会返回值,所以不能在编译时确定值</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>对于C++内置类型的数据,可以直接使用<code>constexpr</code>修饰,但是对于<code>自定义数据类型</code>,例如 <code>struct</code> 和 <code>class</code> 定义的结构体和类,直接使用 <code>constexpr </code>是不行的</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/* 这样会报错: constexpr无效 */</span>
<span class="token keyword">constexpr</span> <span class="token keyword">struct</span> <span class="token class-name">Person</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> age<span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果要定义一个<code>结构体/类常量对象</code>，可以这样写：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Test</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> id<span class="token punctuation">;</span>
    <span class="token keyword">int</span> num<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">constexpr</span> Test t<span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token keyword">constexpr</span> <span class="token keyword">int</span> id <span class="token operator">=</span> t<span class="token punctuation">.</span>id<span class="token punctuation">;</span>
    <span class="token keyword">constexpr</span> <span class="token keyword">int</span> num <span class="token operator">=</span> t<span class="token punctuation">.</span>num<span class="token punctuation">;</span>
    <span class="token comment">// 报错，不能修改常量</span>
    t<span class="token punctuation">.</span>num <span class="token operator">+=</span> <span class="token number">100</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"id: "</span> <span class="token operator">&lt;&lt;</span> id <span class="token operator">&lt;&lt;</span> <span class="token string">", num: "</span> <span class="token operator">&lt;&lt;</span> num <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在第13行的代码中<code>t.num += 100;</code>的操作是<strong>错误的</strong>，<strong>对象t是一个常量</strong>，因此它的成员也是常量，<code>常量是不能被修改的</code>。</p>
<h3 id="3-3-常量表达式函数"><a href="#3-3-常量表达式函数" class="headerlink" title="3.3 常量表达式函数"></a>3.3 常量表达式函数</h3><p>为了提高C++程序的执行效率，我们可以将程序中值不需要发生变化的变量定义为常量，也可以使用<code>constexpr</code>修饰某些特定函数的返回值，这种函数被称作<code>常量表达式函数</code>，这些函数主要包括以下几种：<code>普通函数/类成员函数</code>、<code>类的构造函数</code>、<code>模板函数</code>。</p>
<h4 id="a-修饰普通函数"><a href="#a-修饰普通函数" class="headerlink" title="a. 修饰普通函数"></a>a. 修饰普通函数</h4><p><code>constexpr</code>并不能任意函数的返回值，使这些函数成为<code>常量表达式函数</code>，必须满足以下条件：</p>
<ol>
<li><code>函数必须要有返回值</code>，并且<strong>return返回的表达式必须是常量表达式</strong></li>
</ol>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// error，不是常量表达式函数</span>
<span class="token keyword">constexpr</span> <span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"a: "</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// error，不是常量表达式函数</span>
<span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> a<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><strong>函数func1()没有返回值</strong>，不满足常量表达式函数要求</li>
<li><strong>函数func2()返回值不是常量表达式</strong>，不满足常量表达式函数要求</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/12/25/cpp11-xin-te-xing/constexpr%E4%B8%8D%E5%90%8C%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC.png" alt="image-20241225232916249"></p>
<p>由此可见在<code>更新的C++标准</code>里边放宽了对 <code>constexpr</code> 的语法限制。</p>
<ol start="2">
<li><code>函数在使用之前,必须有与之相对应的定义</code></li>
</ol>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">constexpr</span> <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// error</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">constexpr</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> a<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在测试程序<code>constexpr int num = func1();</code>中，还没有定义<code>func1()</code>就直接调用了，应该将<code>func1()</code>函数的定义放到<code>main()</code>函数的上边。</p>
<ol start="3">
<li>整个函数的函数体中，<code>不</code>能出现<code>非常量表达式</code>之外的语句（<code>using 指令、typedef 语句以及 static_assert 断言、return语句除外</code>）。</li>
</ol>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// error</span>
<span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">constexpr</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
    <span class="token keyword">constexpr</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> b<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"i: "</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// ok</span>
<span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">using</span> mytype <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">;</span>
    <span class="token keyword">constexpr</span> mytype a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
    <span class="token keyword">constexpr</span> mytype b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token keyword">constexpr</span> mytype c <span class="token operator">=</span> a <span class="token operator">*</span> b<span class="token punctuation">;</span>
    <span class="token keyword">return</span> c <span class="token operator">-</span> <span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在C++中，<code>constexpr</code>函数要求函数体中所有的操作都必须是常量表达式。这意味着函数体中不能包含任何运行时的操作，比如I&#x2F;O操作（如<code>cout</code>），以及任何依赖于非常量值的操作。</p>
<ul>
<li><code>func1()</code>函数中包含了一个<code>for</code>循环，并且在循环体内使用了<code>cout</code>进行输出。<code>cout</code>是一个运行时的I&#x2F;O操作，不是常量表达式，因此会导致<code>constexpr</code>函数的定义失败。即使<code>for</code>循环本身可能是基于常量表达式的，但由于包含了非<code>constexpr</code>的操作（<code>cout</code>），整个函数都不能被标记为<code>constexpr</code>。</li>
<li><code>func2()</code>函数中没有包含任何运行时的操作，所有的计算都是在编译时完成的，因此它可以被标记为<code>constexpr</code>。</li>
</ul>
<blockquote>
<p>以上三条规则不仅对于普通的函数生效，并且对于类的成员函数同样生效</p>
</blockquote>
<h4 id="b-修饰成员函数"><a href="#b-修饰成员函数" class="headerlink" title="b. 修饰成员函数"></a>b. 修饰成员函数</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Test</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">constexpr</span> <span class="token keyword">int</span> var <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">5</span> <span class="token operator">*</span> var<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Test t<span class="token punctuation">;</span>
    <span class="token keyword">constexpr</span> <span class="token keyword">int</span> num <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"num: "</span> <span class="token operator">&lt;&lt;</span> num <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="c-修饰模板函数"><a href="#c-修饰模板函数" class="headerlink" title="c. 修饰模板函数"></a>c. 修饰模板函数</h4><p>在C++中，”模板函数”指的是一种允许函数在编译时根据给定的参数类型生成特定实现的机制。这种机制使得同一个函数可以用于不同的数据类型，而不需要为每种类型编写不同的函数代码。</p>
<p>函数模板的基本语法如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">myFunction</span><span class="token punctuation">(</span>T param<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 函数体，使用T作为参数类型</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>这里的<code>template &lt;typename T&gt;</code>声明了一个模板，其中<code>T</code>是一个类型参数，可以在调用函数时指定。<code>typename</code>关键字用于指定<code>T</code>是一个类型。你也可以使用<code>class</code>关键字代替<code>typename</code>，但在现代C++中，<code>typename</code>是首选。</p>
<p>函数模板的使用示例：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
T <span class="token function">max</span><span class="token punctuation">(</span>T a<span class="token punctuation">,</span> T b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>a <span class="token operator">></span> b<span class="token punctuation">)</span> <span class="token operator">?</span> a <span class="token operator">:</span> b<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 使用int类型调用</span>
<span class="token keyword">int</span> maxInt <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 使用double类型调用</span>
<span class="token keyword">double</span> maxDouble <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token number">3.14</span><span class="token punctuation">,</span> <span class="token number">2.71</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在这个例子中，<code>max</code>函数模板可以根据传入的参数类型自动实例化出<code>int</code>和<code>double</code>版本的<code>max</code>函数。</p>
<p>函数模板也可以接受多个类型参数：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T1</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">T2</span><span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">printPair</span><span class="token punctuation">(</span><span class="token keyword">const</span> T1<span class="token operator">&amp;</span> a<span class="token punctuation">,</span> <span class="token keyword">const</span> T2<span class="token operator">&amp;</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">" and "</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 使用</span>
<span class="token function">printPair</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">3.14</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这里，<code>printPair</code>函数模板接受两个参数，这两个参数可以是不同的类型。</p>
<p>函数模板也可以使用非类型模板参数，这些参数在编译时必须是常量：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">int</span> N<span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">printArray</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">)</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 使用</span>
<span class="token keyword">int</span> myArray<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token function">printArray</span><span class="token punctuation">(</span>myArray<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在这个例子中，<code>printArray</code>函数模板接受一个数组，并使用非类型模板参数<code>N</code>来指定数组的大小。</p>
<blockquote>
<p>C++11 语法中，<code>constexpr</code> 可以修饰函数模板，但由于模板中类型的不确定性，因此函数模板实例化后的模板函数是否符合常量表达式函数的要求也是不确定的。<code>如果 constexpr 修饰的模板函数实例化结果不满足常量表达式函数的要求，则 constexpr 会被自动忽略，即该函数就等同于一个普通函数。</code></p>
</blockquote>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> name<span class="token punctuation">;</span>
    <span class="token keyword">int</span> age<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token comment">// 定义函数模板</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">constexpr</span> T <span class="token function">dispaly</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> t<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">struct</span> <span class="token class-name">Person</span> p <span class="token punctuation">&#123;</span> <span class="token string">"luffy"</span><span class="token punctuation">,</span> <span class="token number">19</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token comment">//普通函数</span>
    <span class="token keyword">struct</span> <span class="token class-name">Person</span> ret <span class="token operator">=</span> <span class="token function">dispaly</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"luffy's name: "</span> <span class="token operator">&lt;&lt;</span> ret<span class="token punctuation">.</span>name <span class="token operator">&lt;&lt;</span> <span class="token string">", age: "</span> <span class="token operator">&lt;&lt;</span> ret<span class="token punctuation">.</span>age <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token comment">//常量表达式函数</span>
    <span class="token keyword">constexpr</span> <span class="token keyword">int</span> ret1 <span class="token operator">=</span> <span class="token function">dispaly</span><span class="token punctuation">(</span><span class="token number">250</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> ret1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token keyword">constexpr</span> <span class="token keyword">struct</span> <span class="token class-name">Person</span> p1 <span class="token punctuation">&#123;</span> <span class="token string">"luffy"</span><span class="token punctuation">,</span> <span class="token number">19</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// 使用constexpr修饰， p1是一个常量表达式</span>
    <span class="token keyword">constexpr</span> <span class="token keyword">struct</span> <span class="token class-name">Person</span> p2 <span class="token operator">=</span> <span class="token function">dispaly</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"luffy's name: "</span> <span class="token operator">&lt;&lt;</span> p2<span class="token punctuation">.</span>name <span class="token operator">&lt;&lt;</span> <span class="token string">", age: "</span> <span class="token operator">&lt;&lt;</span> p2<span class="token punctuation">.</span>age <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上面示例程序中定义了一个函数模板 <code>display()</code>，但由于其返回值类型未定，因此在实例化之前无法判断其是否符合常量表达式函数的要求：</p>
<ul>
<li><code>struct Person ret = dispaly(p);</code> 由于参数<code>p</code>是变量，所以实例化后的函数不是常量表达式函数，此时<code>constexpr</code>是无效的</li>
<li><code>constexpr int ret1 = dispaly(250);</code> 参数是常量，符合常量表达式函数的要求，此时<code>constexpr</code>是有效的</li>
<li><code>constexpr struct Person p2 = dispaly(p1);</code> 参数是常量，符合常量表达式函数的要求，此时<code>constexpr</code>是有效的</li>
</ul>
<h4 id="d-修饰构造函数"><a href="#d-修饰构造函数" class="headerlink" title="d. 修饰构造函数"></a>d. 修饰构造函数</h4><p>在C++中，<code>constexpr</code>构造函数允许在编译时初始化对象，这意味着构造函数创建的对象可以被用作常量表达式的一部分。这对于创建在编译时就需要确定值的<code>常量对象</code>非常有用。</p>
<ol>
<li><strong>构造函数的参数必须是常量表达式</strong>：<ul>
<li><code>constexpr</code> 构造函数的参数应当是可以在编译时求值的常量。例如，基本数据类型的常量、常量变量和字面量等。</li>
</ul>
</li>
<li><strong>函数体必须包含允许的操作</strong>：<ul>
<li><code>constexpr</code> 构造函数的函数体必须仅包含可以在编译时执行的表达式。这意味着不能使用诸如动态内存分配、输入输出等运行时操作。</li>
</ul>
</li>
<li><strong>以常量对象的形式使用</strong>：<ul>
<li>构造函数的结果必须是用于创建一个常量对象，可以是 <code>constexpr</code> 变量或用 <code>constexpr</code> 表达式初始化的对象。</li>
</ul>
</li>
<li><strong>返回类型</strong>：<ul>
<li><code>constexpr</code> 构造函数的返回类型必须是该类类型，即生成的对象类型</li>
</ul>
</li>
</ol>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>

<span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment">// 常量表达式构造函数</span>
    <span class="token keyword">constexpr</span> <span class="token function">Point</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">x_</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">y_</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

    <span class="token comment">// 获取 x 和 y 的常量成员函数</span>
    <span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> x_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>
    <span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">getY</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> y_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> x_<span class="token punctuation">;</span>
    <span class="token keyword">int</span> y_<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 在编译时创建常量对象</span>
    <span class="token keyword">constexpr</span> Point <span class="token function">p</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 输出常量对象的值</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Point: ("</span> <span class="token operator">&lt;&lt;</span> p<span class="token punctuation">.</span><span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span> <span class="token operator">&lt;&lt;</span> p<span class="token punctuation">.</span><span class="token function">getY</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">")"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="4-auto类型推导"><a href="#4-auto类型推导" class="headerlink" title="4.auto类型推导"></a>4.auto类型推导</h2><p>在C++11中，可以使用<code>auto</code>来自动推测变量的类型，还可以结合使用<code>decltype</code>关键字来推测函数或者表达式的返回值。允许程序员编写更灵活和通用的代码，尤其是在模板编程中。通过<code>decltype</code>，我们可以避免显式指定类型，从而减少代码的复杂性，并提高代码的可读性和可维护性。</p>
<h3 id="4-1-auto的推导规则"><a href="#4-1-auto的推导规则" class="headerlink" title="4.1 auto的推导规则"></a>4.1 auto的推导规则</h3><p>在<code>C++11之前</code>，<code>auto</code>关键字用于声明<code>自动存储期</code>的变量，但由于非<code>static</code>的局部变量默认就是自动存储期的，所以这个关键字的使用变得不那么常见。</p>
<p>C++11引入了新的<code>auto</code>关键字用法，它主要用于<code>自动类型推导</code>，使得程序员可以不必显式声明变量的类型，而让编译器根据<code>变量的初始值</code>自动推导出类型。</p>
<h4 id="a-自动存储期"><a href="#a-自动存储期" class="headerlink" title="a. 自动存储期"></a>a. 自动存储期</h4><p>在C++中，<code>自动存储期（Automatic Storage Duration）</code>是指变量的生命周期，它描述了变量在程序执行过程中存在的时间。具有自动存储期的变量通常是在函数或代码块内部定义的局部变量，它们在定义它们的代码块被执行时创建，在代码块执行结束时销毁。</p>
<p>以下是自动存储期的一些特点：</p>
<ol>
<li><p><strong>局部作用域</strong>：</p>
<ul>
<li>自动存储期的变量具有局部作用域，它们只能在定义它们的函数或代码块内部被访问。</li>
</ul>
</li>
<li><p><strong>栈内存分配</strong>：</p>
<ul>
<li>这些变量通常在栈（stack）上分配内存。当函数被调用时，局部变量的内存被分配；当函数返回时，这些内存被释放。</li>
</ul>
</li>
<li><p><strong>生命周期</strong>：</p>
<ul>
<li>自动存储期的变量的生命周期仅限于它们被定义的代码块。一旦代码块执行结束，这些变量就会被销毁，它们的内存空间会被回收。</li>
</ul>
</li>
<li><p><strong>初始化</strong>：</p>
<ul>
<li>在C++中，局部变量（具有自动存储期的变量）不会自动初始化。如果它们没有被显式初始化，它们的值是未定义的。</li>
</ul>
</li>
<li><p><strong>与静态存储期的区别</strong>：</p>
<ul>
<li>与自动存储期相对的是静态存储期（Static Storage Duration），具有静态存储期的变量在程序的整个运行期间都存在，它们通常在全局区域或在函数外部定义。</li>
</ul>
</li>
<li><p><strong>例子</strong>：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> localVariable<span class="token punctuation">;</span> <span class="token comment">// 自动存储期的局部变量，未初始化，其值是未定义的</span>
    localVariable <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">// 初始化后，可以安全使用</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这个例子中，<code>localVariable</code>是一个局部变量，它具有自动存储期。它只在<code>function</code>函数内部有效，并且在函数结束时被销毁。</p>
</li>
</ol>
<h4 id="b-auto的推导规则"><a href="#b-auto的推导规则" class="headerlink" title="b. auto的推导规则"></a>b. auto的推导规则</h4><p>C++11 中 auto 并不代表一种实际的数据类型，只是一个类型声明的 “占位符”，auto并不是万能的在任意场景下都能够推导出变量的实际类型，<code>使用auto声明的变量必须要进行初始化，以让编译器推导出它的实际类型，在编译时将auto占位符替换为真正的类型</code>。使用语法如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> 变量名 <span class="token operator">=</span> 变量值<span class="token punctuation">;</span> 

<span class="token keyword">auto</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token comment">// x会被推导为int类型</span>
<span class="token keyword">auto</span> y <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span>      <span class="token comment">// y会被推导为double类型</span>
<span class="token keyword">auto</span> z <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>   <span class="token comment">// z会被推导为const char[]类型</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>不仅如此，auto还可以和指针、引用结合起来使用也可以带上<code>const</code>、<code>volatile限定符</code>，在不同的场景下有对应的推导规则，规则内容如下：</p>
<ul>
<li>当变量<strong>不是指针或者引用类型</strong>时，推导的结果中不会保留<code>const</code>、<code>volatile</code>关键字</li>
<li>当变量<strong>是指针或者引用类型</strong>时，推导的结果中会保留<code>const</code>、<code>volatile</code>关键字</li>
<li><code>volatile</code>关键字用于告诉编译器该变量可能会被程序之外的因素（如硬件或其他线程）改变，因此编译器需要在每次访问该变量时从内存中重新读取其值，而不是使用寄存器中的值。</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> temp <span class="token operator">=</span> <span class="token number">150</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> <span class="token operator">*</span>a <span class="token operator">=</span> <span class="token operator">&amp;</span>temp<span class="token punctuation">;</span>   <span class="token comment">// 变量a的数据类型为 int*，因此auto关键字被推导为 int类型</span>
<span class="token keyword">auto</span> b <span class="token operator">=</span> <span class="token operator">&amp;</span>temp<span class="token punctuation">;</span>    <span class="token comment">// 变量b的数据类型为 int*，因此auto关键字被推导为 int*类型</span>
<span class="token keyword">auto</span> <span class="token operator">&amp;</span>c <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token comment">// 变量c的数据类型为 int&amp;，因此auto关键字被推导为 int类型</span>
<span class="token keyword">auto</span> d <span class="token operator">=</span> temp<span class="token punctuation">;</span>     <span class="token comment">// 变量d的数据类型为 int，因此auto关键字被推导为 int类型</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> tmp <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">auto</span> a1 <span class="token operator">=</span> tmp<span class="token punctuation">;</span>       
<span class="token keyword">auto</span> a2 <span class="token operator">=</span> a1<span class="token punctuation">;</span>              
<span class="token keyword">const</span> <span class="token keyword">auto</span> <span class="token operator">&amp;</span>a3 <span class="token operator">=</span> tmp<span class="token punctuation">;</span>      
<span class="token keyword">auto</span> <span class="token operator">&amp;</span>a4 <span class="token operator">=</span> a3<span class="token punctuation">;</span>             <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>变量<strong>a1</strong>的数据类型为 <code>const int</code>，因此auto关键字被推导为 <code>int类型</code></li>
<li>变量<strong>a2</strong>的数据类型为 <code>int</code>，但是a2<code>没有声明为指针或引用</code>因此 const属性被去掉, auto被推导为 <code>int</code></li>
<li>变量<strong>a3</strong>的数据类型为 <code>const int&amp;</code>，a3被声明为<code>引用</code>因此 const属性被保留，auto关键字被推导为 <code>int类型</code></li>
<li>变量<strong>a4</strong>的数据类型为 <code>const int&amp;</code>，a4被声明为<code>引用</code>因此 const属性被保留，auto关键字被推导为 <code>const int类型</code></li>
</ul>
<h3 id="4-2-auto的限制"><a href="#4-2-auto的限制" class="headerlink" title="4.2 auto的限制"></a>4.2 auto的限制</h3><p><code>auto</code>的类型推导并不是万能的，对于在<code>编译时无法完成类型推导的情况</code>，不能使用自动推导</p>
<ol>
<li><code>auto</code>不能作为函数的参数使用，因为C++中，函数参数的类型必须在编译时已知。<code>auto</code>是一个类型推导关键字，它依赖于初始化表达式来确定具体的类型，这意味着<code>auto</code>需要在变量声明时立即跟随一个初始化表达式，以便编译器可以推导出类型。</li>
</ol>
<blockquote>
<p>因为只有在函数调用的时候才函数参数传递实参，auto 要求必须要给修饰的变量赋值，因此二者矛盾</p>
</blockquote>
  <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">auto</span> a<span class="token punctuation">,</span> <span class="token keyword">auto</span> b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">// 错误</span>
    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<ol start="2">
<li><code>auto</code>不能用于<code>非静态成员</code>的初始化，这是因为<code>非静态成员</code>是属于类的实例对象的，而对象需要在程序运行时才会被创建，所以不能使用自动类型推导</li>
</ol>
  <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">auto</span> age <span class="token operator">=</span> <span class="token number">18</span><span class="token punctuation">;</span> <span class="token comment">// 错误</span>
    <span class="token keyword">static</span> <span class="token keyword">auto</span> name <span class="token operator">=</span> <span class="token string">"Tom"</span><span class="token punctuation">;</span> <span class="token comment">// 错误，类的静态非常量成员不允许在类内部直接初始化</span>
    <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">auto</span> sex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 正确，</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ol start="3">
<li>不能使用<code>auto</code>关键字<code>定义数组</code></li>
</ol>
  <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// 定义数组</span>
    <span class="token keyword">auto</span> t1 <span class="token operator">=</span> array<span class="token punctuation">;</span>               <span class="token comment">// ok, t1被推导为 int* 类型</span>
    <span class="token keyword">auto</span> t2<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">;</span>             <span class="token comment">// error, auto无法定义数组</span>
    <span class="token keyword">auto</span> t3<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>   <span class="token comment">// error, auto无法定义数组</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ol start="4">
<li>不能用于<code>模板参数的推导</code>，在C++中，<code>auto</code>关键字用于自动类型推导，但它不能用于模板参数的推导。这是因为模板参数需要在编译时就确定，而<code>auto</code>的类型推导依赖于初始化表达式的类型，这通常在模板实例化时已经太晚了。</li>
</ol>
  <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">struct</span> <span class="token class-name">Test</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Test<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span> t<span class="token punctuation">;</span>
    Test<span class="token operator">&lt;</span><span class="token keyword">auto</span><span class="token operator">></span> t1 <span class="token operator">=</span> t<span class="token punctuation">;</span> <span class="token comment">// error, 无法推导出模板类型</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="4-3-auto的应用"><a href="#4-3-auto的应用" class="headerlink" title="4.3 auto的应用"></a>4.3 auto的应用</h3><p><code>auto</code> 关键字在 C++ 中主要用于自动类型推导，它可以在多种场景下简化代码和提高代码的可读性。以下是一些常见的应用场景：</p>
<ol>
<li><code>遍历容器</code></li>
</ol>
<p>当遍历标准库容器（如 <code>std::vector</code>、<code>std::list</code>、<code>std::map</code> 等）时，<code>auto</code> 可以用来简化迭代器的类型。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> vec <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">=</span> vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> vec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>it<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>it <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">// 输出：1 2 3 4 5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ol start="2">
<li><code>简化复杂类型</code></li>
</ol>
<p>对于复杂的类型，如嵌套的模板或自定义类型的嵌套定义，<code>auto</code> 可以减少代码的复杂性。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>map<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> myMap<span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> pair <span class="token operator">:</span> myMap<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> pair<span class="token punctuation">.</span>first <span class="token operator">&lt;&lt;</span> <span class="token string">": "</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> num <span class="token operator">:</span> pair<span class="token punctuation">.</span>second<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> num <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ol start="3">
<li><code>函数返回值</code></li>
</ol>
<p>当函数返回复杂类型时，<code>auto</code> 可以用来简化函数调用。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">getVector</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">auto</span> vec <span class="token operator">=</span> <span class="token function">getVector</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// vec 的类型被推导为 std::vector&lt;int></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ol start="4">
<li><code>Lambda 表达式</code></li>
</ol>
<p>在 Lambda 表达式中，<code>auto</code> 可以用来推导捕获的变量类型。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> lambda <span class="token operator">=</span> <span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> x<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<ol start="5">
<li><code>初始化列表</code></li>
</ol>
<p>使用花括号初始化列表时，<code>auto</code> 可以用来推导数组或 <code>std::vector</code> 的类型。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> arr <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// arr 的类型被推导为 std::initializer_list&lt;int></span>
<span class="token keyword">auto</span> vec <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// vec 的类型被推导为 std::vector&lt;int></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<ol start="6">
<li><code>智能指针</code></li>
</ol>
<p>当使用智能指针如 <code>std::unique_ptr</code> 或 <code>std::shared_ptr</code> 时，<code>auto</code> 可以简化类型声明。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> ptr <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_unique</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ptr 的类型被推导为 std::unique_ptr&lt;int></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ol start="7">
<li><code>泛型编程</code></li>
</ol>
<p>在模板编程中，<code>auto</code> 可以用来推导模板实例化的具体类型。在使用模板的时候，很多情况下我们不知道变量应该定义为什么类型</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">T1</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">T2</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">static</span> string <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token string">"hello, world"</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">auto</span> val <span class="token operator">=</span> <span class="token class-name">A</span><span class="token double-colon punctuation">::</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"val: "</span> <span class="token operator">&lt;&lt;</span> val <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token generic-function"><span class="token function">func</span><span class="token generic class-name"><span class="token operator">&lt;</span>T1<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token generic-function"><span class="token function">func</span><span class="token generic class-name"><span class="token operator">&lt;</span>T2<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ol start="8">
<li><code>错误处理</code></li>
</ol>
<p>在处理异常和错误代码时，<code>auto</code> 可以用来简化错误类型的处理。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> error <span class="token operator">=</span> <span class="token function">someFunctionThatReturnsErrorCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>error <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    std<span class="token double-colon punctuation">::</span>cerr <span class="token operator">&lt;&lt;</span> <span class="token string">"Error occurred: "</span> <span class="token operator">&lt;&lt;</span> error <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="4-4-decltype关键字"><a href="#4-4-decltype关键字" class="headerlink" title="4.4 decltype关键字"></a>4.4 decltype关键字</h3><p><code>decltype</code>的作用是在不需要或者不能进行<code>表达式的计算</code>的时候，希望能够得到表达式的<code>结果类型</code>，这个时候就可以运用到<code>decltype关键字</code>了，语法如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">decltype</span> <span class="token punctuation">(</span>表达式<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><code>decltype</code>是<code>declare type</code>声明类型的缩写，其推导是在<code>编译期</code>完成的，它只用于表达式类型的推导，不会在内部进行计算表达式的值。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">auto</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token keyword">decltype</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> b <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>               <span class="token comment">// int</span>
    <span class="token keyword">decltype</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> c <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>            <span class="token comment">// int</span>
    <span class="token keyword">decltype</span><span class="token punctuation">(</span>b <span class="token operator">*</span> <span class="token number">10.25</span> <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">)</span> d <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token comment">// double</span>

    <span class="token comment">// 输出类型</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Type of a: "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Type of b: "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Type of c: "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Type of d: "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="4-5-decltype的推导规则"><a href="#4-5-decltype的推导规则" class="headerlink" title="4.5 decltype的推导规则"></a>4.5 decltype的推导规则</h3><ol>
<li>表达式为<code>普通变量</code>或者<code>普通表达式</code>或者<code>类表达式(有类的限定的或者对象参与的)</code>，在这种情况下，使用<strong>decltype推导出的类型和表达式的类型是一致的</strong>。</li>
</ol>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Test</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    string text<span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">110</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">99</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>y <span class="token operator">=</span> x<span class="token punctuation">;</span>
    <span class="token keyword">decltype</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> a <span class="token operator">=</span> x<span class="token punctuation">;</span>
    <span class="token keyword">decltype</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> b <span class="token operator">=</span> x<span class="token punctuation">;</span>
    <span class="token keyword">decltype</span><span class="token punctuation">(</span>Test<span class="token double-colon punctuation">::</span>value<span class="token punctuation">)</span> c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    Test t<span class="token punctuation">;</span>
    <span class="token keyword">decltype</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>text<span class="token punctuation">)</span> d <span class="token operator">=</span> <span class="token string">"hello, world"</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>变量<code>a</code>被推导为 <code>int</code>类型</li>
<li>变量<code>b</code>被推导为 <code>const int &amp;</code> 类型</li>
<li>变量<code>c</code>被推导为 <code>const int</code> 类型</li>
<li>变量<code>d</code>被推导为 <code>string</code> 类型</li>
</ul>
<ol start="2">
<li>表达式是<code>函数调用</code>，使用 <strong>decltype 推导出的类型和函数返回值一致。</strong>(有一个特殊,纯右值)</li>
</ol>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token comment">//函数声明</span>
<span class="token keyword">int</span> <span class="token function">func_int</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">// 返回值为 int</span>
<span class="token keyword">int</span><span class="token operator">&amp;</span> <span class="token function">func_int_r</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">// 返回值为 int&amp;</span>
<span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> <span class="token function">func_int_rr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 返回值为 int&amp;&amp;</span>

<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token function">func_cint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 返回值为 const int</span>
<span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> <span class="token function">func_cint_r</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 返回值为 const int&amp;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> <span class="token function">func_cint_rr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 返回值为 const int&amp;&amp;</span>

<span class="token keyword">const</span> Test <span class="token function">func_ctest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 返回值为 const Test</span>

<span class="token comment">//decltype类型推导</span>
<span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">func_int</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>		
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">func_int_r</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> b <span class="token operator">=</span> n<span class="token punctuation">;</span>	
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">func_int_rr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>	
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">func_cint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> d <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>	
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">func_cint_r</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> e <span class="token operator">=</span> n<span class="token punctuation">;</span>	
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">func_cint_rr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> f <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>	
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">func_ctest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> g <span class="token operator">=</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>变量<code>a</code>被推导为 <code>int </code>类型</li>
<li>变量<code>b</code>被推导为 <code>int&amp; </code>类型</li>
<li>变量<code>c</code>被推导为 <code>int&amp;&amp;</code> 类型</li>
<li>变量<code>d</code>被推导为 <code>int</code> 类型</li>
<li>变量<code>e</code>被推导为 <code>const int &amp;</code> 类型</li>
<li>变量<code>f</code>被推导为 <code>const int &amp;&amp;</code> 类型</li>
<li>变量<code>g</code>被推导为 <code>const Test</code> 类型</li>
</ul>
<p>函数 <code>func_cint()</code> 返回的是一个<code>纯右值</code>（<strong>在表达式执行结束后不再存在的数据，也就是临时性的数据，或者例如字面量</strong>），<code>对于纯右值而言，只有类类型可以携带const</code>、<code>volatile限定符</code>，除此之外需要忽略掉这两个限定符，因此推导出的变量 <code>d</code> 的类型为 <code>int</code> 而不是 <code>const int</code>。</p>
<ol start="3">
<li><code>表达式是一个左值，或者被括号( )包围</code>，使用 <code>decltype</code> 推导出的是表达式类型的引用（如果有<code>const、volatile限定符</code>不能忽略）。</li>
</ol>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Test</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> num<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">const</span> Test obj<span class="token punctuation">;</span>
    <span class="token comment">//带有括号的表达式</span>
    <span class="token comment">// a : int</span>
    <span class="token keyword">decltype</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>num<span class="token punctuation">)</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">// b : const int&amp;</span>
    <span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>
    <span class="token comment">//加法表达式</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> m <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">// c : int </span>
    <span class="token keyword">decltype</span><span class="token punctuation">(</span>n <span class="token operator">+</span> m<span class="token punctuation">)</span> c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">// n+m最后保存在n中,n是可以取地址的左值,所以 d : int&amp;</span>
    <span class="token keyword">decltype</span><span class="token punctuation">(</span>n <span class="token operator">=</span> n <span class="token operator">+</span> m<span class="token punctuation">)</span> d <span class="token operator">=</span> n<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="4-6-decltype在泛型编程的应用"><a href="#4-6-decltype在泛型编程的应用" class="headerlink" title="4.6 decltype在泛型编程的应用"></a>4.6 decltype在泛型编程的应用</h3><p>关于decltype的应用多出现在<code>泛型编程</code>中。比如我们编写一个类模板，在里边添加遍历容器的函数，操作如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;list></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">class</span> <span class="token class-name">Container</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> c<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>m_it <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> m_it <span class="token operator">!=</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>m_it<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>m_it <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token operator">?</span><span class="token operator">?</span><span class="token operator">?</span> m_it<span class="token punctuation">;</span>  <span class="token comment">// 这里不能确定迭代器类型</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">const</span> list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> lst<span class="token punctuation">;</span>
    Container<span class="token operator">&lt;</span><span class="token keyword">const</span> list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> obj<span class="token punctuation">;</span>
    obj<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span>lst<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在程序的<strong>第17行</strong>出了问题，关于迭代器变量一共有两种类型：<code>只读（T::const_iterator）</code>和<code>读写（T::iterator）</code>，有了<code>decltype</code>就可以完美的解决这个问题了，当 T 是一个 非 const 容器得到一个 T::iterator，当 T 是一个 const 容器时就会得到一个<code>T::const_iterator</code>。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;list></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">class</span> <span class="token class-name">Container</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> c<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>m_it <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> m_it <span class="token operator">!=</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>m_it<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>m_it <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> m_it<span class="token punctuation">;</span>  <span class="token comment">// 这里不能确定迭代器类型</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">const</span> list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> lst<span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    Container<span class="token operator">&lt;</span><span class="token keyword">const</span> list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> obj<span class="token punctuation">;</span>
    obj<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span>lst<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p><code>decltype(*T*().begin()) iter; // 推导出对应的容器的迭代器类型</code></p>
</blockquote>
<h3 id="4-7-返回类型的后置-声明返回类型"><a href="#4-7-返回类型的后置-声明返回类型" class="headerlink" title="4.7 返回类型的后置(声明返回类型?)"></a>4.7 返回类型的后置(声明返回类型?)</h3><p>在泛型编程中，可能需要通过<code>参数的运算</code>来得到<code>返回值的类型</code>，比如下面这个场景：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token comment">// R->返回值类型, T->参数1类型, U->参数2类型</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">R</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">U</span><span class="token operator">></span>
R <span class="token function">add</span><span class="token punctuation">(</span>T t<span class="token punctuation">,</span> U u<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> t <span class="token operator">+</span> u<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">520</span><span class="token punctuation">;</span>
    <span class="token keyword">double</span> y <span class="token operator">=</span> <span class="token number">13.14</span><span class="token punctuation">;</span>
    <span class="token comment">// auto z = add&lt;decltype(x + y), int, double>(x, y);</span>
    <span class="token keyword">auto</span> z <span class="token operator">=</span> <span class="token generic-function"><span class="token function">add</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>x <span class="token operator">+</span> y<span class="token punctuation">)</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 简化之后的写法</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"z: "</span> <span class="token operator">&lt;&lt;</span> z <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>关于返回值，从上面的代码可以推断出和表达式 <code>t+u</code> 的结果类型是一样的，因此可以通过通过<code>decltype</code>进行推导，关于模板函数的参数<code>t</code>和<code>u</code>可以通过实参自动推导出来，因此在程序中就也可以不写。虽然通过上述方式问题被解决了，但是解决方案有点过于理想化，因为对于调用者来说，是不知道函数内部执行了什么样的处理动作的。(如例子中的 <code>t + u</code>,自然也不能通过<code>decltype</code>来声明表达式类型)</p>
<p>因此如果要想解决这个问题就得直接在 <code>add()</code> 函数身上做文章，自然而然地想到在<code>函数声明</code>的时候使用<strong>decltype来推导返回值类型</strong></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">U</span><span class="token operator">></span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span>t<span class="token operator">+</span>u<span class="token punctuation">)</span> <span class="token function">add</span><span class="token punctuation">(</span>T t<span class="token punctuation">,</span> U u<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> t <span class="token operator">+</span> u<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>但这样显然是错误的,因为decltype中的 t 和 u 都是函数参数，直接这样写相当于变量还没有定义就直接用上了，这时候变量还不存在，有点心急了。</p>
</blockquote>
<p>在C++11中增加了<code>返回类型后置语法</code>，说明白一点就是将<code>decltype和auto结合起来完成返回类型的推导</code>。其语法格式如下:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 符号 -> 后边跟随的是函数返回值的类型</span>
<span class="token keyword">auto</span> <span class="token function">func</span><span class="token punctuation">(</span>参数<span class="token number">1</span><span class="token punctuation">,</span> 参数<span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>参数表达式<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>通过对上述返回类型后置语法代码的分析，得到结论：<code>auto 会追踪 decltype() 推导出的类型</code>，因此上边的<code>add()函数</code>可以做如下的修改：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">U</span><span class="token operator">></span>
<span class="token comment">// 返回类型后置语法</span>
<span class="token keyword">auto</span> <span class="token function">add</span><span class="token punctuation">(</span>T t<span class="token punctuation">,</span> U u<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>t<span class="token operator">+</span>u<span class="token punctuation">)</span>  <span class="token comment">// 声明函数时就设定返回的类型由t+u推导出来</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> t <span class="token operator">+</span> u<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">520</span><span class="token punctuation">;</span>
    <span class="token keyword">double</span> y <span class="token operator">=</span> <span class="token number">13.14</span><span class="token punctuation">;</span>
    <span class="token comment">// auto z = add&lt;int, double>(x, y);</span>
    <span class="token keyword">auto</span> z <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// 简化之后的写法</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"z: "</span> <span class="token operator">&lt;&lt;</span> z <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>为了进一步说明这个语法，我们再看一个例子：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span><span class="token operator">&amp;</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>i<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> i<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">double</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">double</span> <span class="token operator">&amp;</span>d<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    d <span class="token operator">=</span> d <span class="token operator">+</span> <span class="token number">100</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> d<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token comment">// 返回类型后置语法</span>
<span class="token keyword">auto</span> <span class="token function">myFunc</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> t<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">test</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token function">test</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">520</span><span class="token punctuation">;</span>
    <span class="token keyword">double</span> y <span class="token operator">=</span> <span class="token number">13.14</span><span class="token punctuation">;</span>
    <span class="token comment">// auto z = myFunc&lt;int>(x);</span>
    <span class="token keyword">auto</span> z <span class="token operator">=</span> <span class="token function">myFunc</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">// 简化之后的写法</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"z: "</span> <span class="token operator">&lt;&lt;</span> z <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token comment">// auto z = myFunc&lt;double>(y);</span>
    <span class="token keyword">auto</span> z1 <span class="token operator">=</span> <span class="token function">myFunc</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 简化之后的写法</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"z1: "</span> <span class="token operator">&lt;&lt;</span> z1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在这个例子中，通过<code>decltype结合返回值后置</code>语法很容易推导出来, <code>test(t)</code>函数可能出现的返回值类型，并将其作用到了函数<code>myFunc()</code>上。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 输出结果</span>
z<span class="token operator">:</span> <span class="token number">520</span>
z1<span class="token operator">:</span> <span class="token number">113.14</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h2 id="5-final和override"><a href="#5-final和override" class="headerlink" title="5. final和override"></a>5. final和override</h2><p>C++ 中增加了 <code>final 关键字</code>来 <code>限制某个类不能被继承</code>，或者<code>某个虚函数不能被重写</code>，和 <code>Java</code> 的 final 关键字的功能是类似的。<br>如果使用 final 修饰函数，只能<code>修饰虚函数</code>，并且 要把 <code>final关键字放到类或者函数的后面。</code></p>
<h3 id="5-1-final-修饰函数"><a href="#5-1-final-修饰函数" class="headerlink" title="5.1 final 修饰函数"></a>5.1 final 修饰函数</h3><p>如果使用<code>final</code>修饰函数，只能<code>修饰虚函数</code>，这样就能<strong>阻止子类重写父类的这个函数</strong>了：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Base class..."</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">final</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Child class..."</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">GrandChild</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Child</span></span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment">// 语法错误, 不允许重写</span>
    <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"GrandChild class..."</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="5-2-final-修饰类"><a href="#5-2-final-修饰类" class="headerlink" title="5.2 final 修饰类"></a>5.2 final 修饰类</h3><p>使用<code>final关键字</code>修饰过的类是<code>不允许被继承</code>的，也就是说这个类<strong>不能有派生类</strong>。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Person</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                                                 <span class="token comment">// 定义纯虚函数</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">finalRun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">final</span> <span class="token punctuation">&#123;</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Person::finalRun()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">// 定义final修饰的虚函数</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">SportsMan</span> <span class="token keyword">final</span> <span class="token operator">:</span> <span class="token keyword">public</span> Person
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">override</span> <span class="token punctuation">&#123;</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"SportsMan::run()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>
    <span class="token keyword">void</span> <span class="token function">finalRun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">override</span> <span class="token punctuation">&#123;</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"SportsMan::finalRun()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">// 无法重写final修饰的虚函数</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">FinalAthlete</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">SportsMan</span> <span class="token comment">// 不允许继承final修饰的类</span></span>
<span class="token punctuation">&#123;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="5-3-overide"><a href="#5-3-overide" class="headerlink" title="5.3 overide"></a>5.3 overide</h3><p><code>override关键字</code>确保在派生类中声明的重写函数与基类的虚函数有<strong>相同的签名</strong>，同时也明确<code>表明</code>将会重写基类的虚函数，这样就可以保证重写的虚函数的正确性，也提高了代码的可读性，和<code>final</code>一样这个关键字要写到方法的后面。使用方法如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Object_My</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">print_a</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Object_My::print_a()"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">ClassA</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Object_My</span></span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">override</span>
    <span class="token punctuation">&#123;</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ClassA::print()"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Object_My <span class="token operator">*</span>obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ClassA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将子类对象指针指向父类对象,用来实现多态</span>
    obj<span class="token operator">-></span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment">// 子类虚函数表寻址,调用子类的print()函数</span>
    obj<span class="token operator">-></span><span class="token function">print_a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 调用父类的print_a()函数,因为子类没有重写该函数</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="6-模板的优化"><a href="#6-模板的优化" class="headerlink" title="6. 模板的优化"></a>6. 模板的优化</h2><h3 id="6-1-模板嵌套右尖括号的优化"><a href="#6-1-模板嵌套右尖括号的优化" class="headerlink" title="6.1 模板嵌套右尖括号的优化"></a>6.1 模板嵌套右尖括号的优化</h3><p>在泛型编程中，模板实例化有一个非常繁琐的地方，那就是<code>连续的两个右尖括号（&gt;&gt;）</code>会被编译器解析成<code>右移操作符</code>，而不是模板参数表的结束。我们先来看一段关于容器遍历的代码，在创建的类模板<code>Base</code>中提供了遍历容器的操作函数<code>traversal()</code>:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// test.cpp</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">class</span> <span class="token class-name">Base</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">traversal</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> t<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">auto</span> it <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> t<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>it<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>it <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>


<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v<span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    Base<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> b<span class="token punctuation">;</span>
    b<span class="token punctuation">.</span><span class="token function">traversal</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果使用<code>C++98/03</code>标准来编译上边的这段代码，就会得到如下的错误提示：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">test.cpp:25:20: error: <span class="token string">'>>'</span> should be <span class="token string">'> >'</span> within a nested template argument list
     Base<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>int<span class="token operator">>></span> b<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>根据错误提示中描述模板的两个右尖括之间需要<strong>添加空格</strong>，这样写起来就非常的麻烦，<code>C++11</code>改进了编译器的解析规则，尽可能地将<code>多个右尖括号（&gt;）解析成模板参数结束符</code>，方便我们编写模板相关的代码。</p>
<p>上面的这段代码，在支持C++11的编译器中编译是没有任何问题的，如果使用g++直接编译需要加参数<code>-std=c++11</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">g++ test.cpp <span class="token parameter variable">-std</span><span class="token operator">=</span>c++11 <span class="token parameter variable">-o</span> app<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="6-2-默认模板参数"><a href="#6-2-默认模板参数" class="headerlink" title="6.2 默认模板参数"></a>6.2 默认模板参数</h3><p>在<code>C++98/03</code>标准中，<code>类模板</code>可以有默认的模板参数：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">=</span><span class="token keyword">int</span><span class="token punctuation">,</span> T t<span class="token operator">=</span><span class="token number">520</span><span class="token operator">></span>
<span class="token keyword">class</span> <span class="token class-name">Test</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"current value: "</span> <span class="token operator">&lt;&lt;</span> t <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Test<span class="token operator">&lt;</span><span class="token operator">></span> t<span class="token punctuation">;</span>
    t<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    Test<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token number">1024</span><span class="token operator">></span> t1<span class="token punctuation">;</span>
    t1<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>但是不支持函数的默认模板参数，在C++11中添加了对<code>函数模板</code>默认参数的支持:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">=</span><span class="token keyword">int</span><span class="token operator">></span>	<span class="token comment">// C++98/03不支持这种写法, C++11中支持这种写法</span>
<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"current value: "</span> <span class="token operator">&lt;&lt;</span> t <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">func</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>通过上面的例子可以得到如下结论：当<code>所有模板参数都有默认参数时，函数模板的调用如同一个普通函数</code>。但对于<code>类模板</code>而言，哪怕所有参数都有<strong>默认参数</strong>，在使用时也必须在模板名后跟随<code>&lt; &gt;</code>来实例化。</p>
<p><strong>另外：</strong>函数模板的默认模板参数在使用规则上和其他的默认参数也有一些不同，它没有必须写在<code>参数表最后的限制</code>。这样当默认模板参数和模板参数<code>自动推导</code>结合起来时，书写就显得非常灵活了。我们可以指定函数模板中的<strong>一部分模板参数使用默认参数，另一部分使用自动推导</strong>, 像下面的例子:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span> <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">,</span> T t <span class="token operator">=</span> <span class="token number">520</span><span class="token operator">></span>
<span class="token keyword">class</span> <span class="token class-name">Test</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"current value: "</span> <span class="token operator">&lt;&lt;</span> t <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span> <span class="token operator">=</span> <span class="token keyword">long</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">U</span> <span class="token operator">=</span> <span class="token keyword">int</span><span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">myTest</span><span class="token punctuation">(</span>T t <span class="token operator">=</span> <span class="token char">'A'</span><span class="token punctuation">,</span> U u <span class="token operator">=</span> <span class="token char">'B'</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"t = "</span> <span class="token operator">&lt;&lt;</span> t <span class="token operator">&lt;&lt;</span> <span class="token string">", u = "</span> <span class="token operator">&lt;&lt;</span> u <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 默认会将'A'和'B'转换为long, int类型</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span> y <span class="token operator">=</span> <span class="token number">10.0</span><span class="token punctuation">)</span> <span class="token comment">// 要么全部指定参数,要么将默认参数放在后面</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Test<span class="token operator">&lt;</span><span class="token operator">></span> t2<span class="token punctuation">;</span>
    t2<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    Test<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token number">1024</span><span class="token operator">></span> t1<span class="token punctuation">;</span>
    t1<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"==========\n"</span><span class="token punctuation">;</span>
    <span class="token function">myTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token comment">// 使用默认模板参数和默认函数参数</span>
    <span class="token function">myTest</span><span class="token punctuation">(</span><span class="token number">123L</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment">// 使用默认的 U 类型和自定义的 T 类型（long）</span>
    <span class="token generic-function"><span class="token function">myTest</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token char">'C'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment">// 使用自定义的 T 类型（char）和默认的 U 类型（int）</span>
    <span class="token generic-function"><span class="token function">myTest</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">,</span> <span class="token number">3.14f</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 完全指定模板参数和默认函数参数</span>

    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"==========\n"</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>       <span class="token comment">// 使用默认参数</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">25.0</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 自定义参数</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>对于上述调用，<strong>输出将是：</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">current value: <span class="token number">520</span>
current value: <span class="token number">1024</span>
<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>
t <span class="token operator">=</span> <span class="token number">65</span>, u <span class="token operator">=</span> <span class="token number">66</span>  // <span class="token string">'A'</span> 和 <span class="token string">'B'</span> 的 ASCII 值
t <span class="token operator">=</span> <span class="token number">123</span>, u <span class="token operator">=</span> <span class="token number">66</span> // <span class="token number">123</span> 是 long 类型，<span class="token string">'B'</span> 是 int 类型
t <span class="token operator">=</span> <span class="token number">67</span>, u <span class="token operator">=</span> <span class="token number">66</span>  // <span class="token string">'C'</span> 是 char 类型，<span class="token string">'B'</span> 是 int 类型
t <span class="token operator">=</span> <span class="token number">42</span>, u <span class="token operator">=</span> <span class="token number">3.14</span> // <span class="token number">42</span> 是 int 类型，3.14 是 float 类型
<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>
<span class="token number">20</span>
<span class="token number">45</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>当<code>默认模板参数</code>和<code>模板参数自动推导</code>同时使用时（<code>优先级从高到低</code>）：</p>
<ul>
<li><code>如果可以推导出参数类型则使用推导出的类型</code></li>
<li><code>如果函数模板无法推导出参数类型，那么编译器会使用默认模板参数</code></li>
<li><code>如果无法推导出模板参数类型并且没有设置默认模板参数，编译器就会报错。</code></li>
<li>当有多个模板类型却只指定少于实际的模板类型,从左到右依次赋值</li>
</ul>
<p>再看下面的例子:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token comment">// 函数模板定义</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">U</span> <span class="token operator">=</span> <span class="token keyword">char</span><span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>T arg1 <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">,</span> U arg2 <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"arg1: "</span> <span class="token operator">&lt;&lt;</span> arg1 <span class="token operator">&lt;&lt;</span> <span class="token string">", arg2: "</span> <span class="token operator">&lt;&lt;</span> arg2 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 模板函数调用</span>
    <span class="token function">func</span><span class="token punctuation">(</span><span class="token char">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">func</span><span class="token punctuation">(</span><span class="token number">97</span><span class="token punctuation">,</span> <span class="token char">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// func();    //编译报错,默认的模板参数不全,默认的函数参数不能用于类型推导</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="7-using关键字"><a href="#7-using关键字" class="headerlink" title="7. using关键字"></a>7. using关键字</h2><blockquote>
<p>在<code>C++11</code>之前, <code>using关键字</code>一般有两种用法:</p>
<ul>
<li>引入<code>命名空间</code>，这样可以使用命名空间里的函数和变量，防止命名冲突</li>
<li><strong>派生类</strong>使用基类的成员或者函数</li>
</ul>
</blockquote>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token comment">// using namespace std; // using声明命名空间后可以省略命名空间，直接使用cout</span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>cout<span class="token punctuation">;</span> <span class="token comment">// 也可以只使用using声明命名空间中的一个对象</span>
<span class="token keyword">class</span> <span class="token class-name">Base</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> a<span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Base::print()"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">using</span> Base<span class="token double-colon punctuation">::</span>a<span class="token punctuation">;</span>     <span class="token comment">// 继承父类的a成员</span>
    <span class="token keyword">using</span> Base<span class="token double-colon punctuation">::</span>print<span class="token punctuation">;</span> <span class="token comment">// 继承父类的print成员</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello, world!\n"</span><span class="token punctuation">;</span>
    Child c<span class="token punctuation">;</span>
    c<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出Child::print()</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="7-1-给类定义别名"><a href="#7-1-给类定义别名" class="headerlink" title="7.1 给类定义别名"></a>7.1 给类定义别名</h3><p><strong>在c++中</strong>，可以用 <code>typedef</code> 重定义一个类型，语法如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">typedef</span> 旧的类型名 新的类型名<span class="token punctuation">;</span>
<span class="token comment">// 使用举例</span>
<span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> uint_t<span class="token punctuation">;</span>

<span class="token keyword">unsigned</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
uint_t b <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>typedef</code> 重定义的类型并不是一个新的类型，仅仅只是<strong>原有的类型取了一个新的名字</strong>。和以前的声明语句一样，这里的声明符也可以包含类型修饰(例如<code>const</code>，<code>volatile</code>），从而也能由基本数据类型构造出**复合类型(指针或者数组)**来。C++11中规定了一种新的方法，使用别名声明(alias declaration)来定义类型的别名，即使用 <code>using</code>。</p>
<p>在使用的时候，关键字 <code>using</code> 作为别名声明的开始，其后紧跟别名和等号，其作用是把等号左侧的名字规定成等号右侧类型的别名。<code>类型别名和类型的名字等价，只要是类型的名字能出现的地方，就能使用类型别名。使用typedef定义的别名和使用using定义的别名在语义上是等效的。</code></p>
<p>使用using定义别名的语法格式是这样的：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">using</span> 新的类型 <span class="token operator">=</span> 旧的类型<span class="token punctuation">;</span>
<span class="token comment">// 使用举例</span>
<span class="token keyword">using</span> uint_t <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>通过<code>using</code>和<code>typedef</code>的语法格式可以看到二者的使用没有太大的区别，假设我们定义一个<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_27825451/article/details/103081289">函数指针</a>，<code>using</code>的优势就能凸显出来了，看一下下面的例子：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 使用typedef定义函数指针</span>
<span class="token keyword">typedef</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span>func_ptr<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 使用using定义函数指针</span>
<span class="token keyword">using</span> func_ptr1 <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token comment">// using定义别名</span>
<span class="token keyword">using</span> u_int <span class="token operator">=</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">;</span>
u_int a <span class="token operator">=</span> <span class="token number">64</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"add("</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> <span class="token string">")="</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">+</span> b <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">// 函数指针类型定义, 这两种方法同效果</span>
<span class="token keyword">typedef</span> <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>add_ptr<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">using</span> add_ptr_ <span class="token operator">=</span> <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    add_ptr func <span class="token operator">=</span> add<span class="token punctuation">;</span>
    <span class="token comment">// add_ptr_ func = add;</span>
    
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>add_func<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">=</span> add<span class="token punctuation">;</span>
    <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">,</span> <span class="token char">'c'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 不使用别名</span>
    <span class="token function">func</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">(</span><span class="token operator">*</span>func<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="7-2-给模板定义别名"><a href="#7-2-给模板定义别名" class="headerlink" title="7.2 给模板定义别名"></a>7.2 给模板定义别名</h3><p>使用<code>typedef重定义类</code>时很方便，但是它有一点限制，比如无法<code>重定义一个模板</code>，比如我们需要一个<code>固定以int类型为key的map</code>，它可以和很多类型的<code>value</code>值进行映射，如果使用<code>typedef</code>这样直接定义就非常麻烦:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">typedef</span> map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token operator">></span> map_s<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> map_i<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token operator">></span> map_d<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>在这种情况下我们就不自觉的想到了模板：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">typedef</span> map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> T<span class="token operator">></span> type<span class="token punctuation">;</span>	<span class="token comment">// error, 语法错误</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>使用<strong>typename不支持给模板定义别名</strong>，这个简单的需求仅通过<code>typedef</code>很难办到，需要添加一个<code>外敷类</code>：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;functional></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;map></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token comment">// 定义外敷类</span>
<span class="token keyword">struct</span> <span class="token class-name">MyMap</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">typedef</span> map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> T<span class="token operator">></span> type<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    MyMap<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token double-colon punctuation">::</span>type m<span class="token punctuation">;</span>
    m<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token function">make_pair</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"luffy"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    m<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token function">make_pair</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"ace"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    MyMap<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token double-colon punctuation">::</span>type m1<span class="token punctuation">;</span>
    m1<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    m1<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>通过上边的例子可以直观的感觉到，需求简单但是实现起来并不容易。在<code>C++11</code>中，新增了一个特性就是可以通过<code>使用using来为一个模板定义别名</code>，对于上面的需求可以写成这样：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/* 使用using为模板定义别名 */</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">using</span> MyMap <span class="token operator">=</span> map<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>完整的实例代码如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;map></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">struct</span> <span class="token class-name">MyContainer</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span>T <span class="token operator">&amp;</span>t<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> iter <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> iter <span class="token operator">!=</span> t<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> iter<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            cout <span class="token operator">&lt;&lt;</span> iter<span class="token operator">-></span>first <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> iter<span class="token operator">-></span>second <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token comment">/* 使用using为模板定义别名 */</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">using</span> MyMap <span class="token operator">=</span> map<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    MyMap<span class="token operator">&lt;</span>string<span class="token operator">></span> map<span class="token punctuation">;</span> <span class="token comment">// ok</span>
    map<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">pair</span><span class="token generic class-name"><span class="token operator">&lt;</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    map<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">pair</span><span class="token generic class-name"><span class="token operator">&lt;</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    map<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">pair</span><span class="token generic class-name"><span class="token operator">&lt;</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    MyContainer<span class="token operator">&lt;</span>MyMap<span class="token operator">&lt;</span>string<span class="token operator">>></span> c<span class="token punctuation">;</span> <span class="token comment">// ok</span>
    c<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment">// ok</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面的例子中通过使用<code>using给模板指定别名</code>，就可以基于别名非常方便的给<code>value</code>指定相应的类型，这样使编写的程序变得更加灵活，看起来也更加简洁一些。</p>
<p>最后在强调一点：<code>using</code>语法和<code>typedef</code>一样，并不会创建出新的类型，它们只是给<strong>某些类型定义了新的别名</strong>。<code>using相较于typedef的优势在于定义函数指针别名时看起来更加直观，并且可以给模板定义别名。</code></p>
<h2 id="8-委托构造和继承构造"><a href="#8-委托构造和继承构造" class="headerlink" title="8. 委托构造和继承构造"></a>8. 委托构造和继承构造</h2><h3 id="8-1-委托构造函数"><a href="#8-1-委托构造函数" class="headerlink" title="8.1 委托构造函数"></a>8.1 委托构造函数</h3><p>在一个类中，常常会<code>重载多个构造函数</code>以适应不同的需求，<strong>在C++11之前</strong>，即便是同一个类的构造函数之间也不能互相调用，而<strong>在C++11之后</strong>，提出了<code>委托构造函数的概念</code>: 委托构造函数允许使用同一个类中的一个构造函数调用其它的构造函数，从而简化相关变量的初始化。下面举例说明:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">enum</span> <span class="token class-name">Gender</span>
<span class="token punctuation">&#123;</span>
    Male<span class="token punctuation">,</span>
    Female
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Person</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> i_age<span class="token punctuation">;</span>
    string s_name<span class="token punctuation">;</span>
    Gender s_gender<span class="token punctuation">;</span>
    
    <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        i_age <span class="token operator">=</span> age<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">,</span> string name<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        i_age <span class="token operator">=</span> age<span class="token punctuation">;</span> <span class="token comment">// 冗余代码</span>
        s_name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">,</span> string name<span class="token punctuation">,</span> Gender gender<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        i_age <span class="token operator">=</span> age<span class="token punctuation">;</span>   <span class="token comment">// 冗余代码</span>
        s_name <span class="token operator">=</span> name<span class="token punctuation">;</span> <span class="token comment">// 冗余代码</span>
        s_gender <span class="token operator">=</span> gender<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上面的程序中有三个构造函数，但是这三个函数中都有重复的代码，在C++11之前构造函数是不能调用构造函数的，加入了委托构造之后，我们就可以轻松地完成代码的优化了：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">enum</span> <span class="token class-name">Gender</span>
<span class="token punctuation">&#123;</span>
    Male<span class="token punctuation">,</span>
    Female
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Person</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> i_age<span class="token punctuation">;</span>
    string s_name<span class="token punctuation">;</span>
    Gender s_gender <span class="token operator">=</span> Gender<span class="token double-colon punctuation">::</span>Male<span class="token punctuation">;</span>
    <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        i_age <span class="token operator">=</span> age<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">,</span> string name<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">Person</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>

        s_name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">,</span> string name<span class="token punctuation">,</span> Gender gender<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">Person</span><span class="token punctuation">(</span>age<span class="token punctuation">,</span> name<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>

        s_gender <span class="token operator">=</span> gender<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        string genderStr <span class="token operator">=</span> <span class="token punctuation">(</span>s_gender <span class="token operator">==</span> Male<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token string">"Male"</span> <span class="token operator">:</span> <span class="token string">"Female"</span><span class="token punctuation">;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"age: "</span> <span class="token operator">&lt;&lt;</span> i_age <span class="token operator">&lt;&lt;</span> <span class="token string">" name: "</span> <span class="token operator">&lt;&lt;</span> s_name <span class="token operator">&lt;&lt;</span> <span class="token string">" gender: "</span> <span class="token operator">&lt;&lt;</span> genderStr <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Person <span class="token function">p1</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token string">"luffy"</span><span class="token punctuation">,</span> Male<span class="token punctuation">)</span><span class="token punctuation">;</span>
    Person <span class="token function">p2</span><span class="token punctuation">(</span><span class="token number">25</span><span class="token punctuation">,</span> <span class="token string">"zoro1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Person <span class="token function">p3</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">,</span> <span class="token string">"sanji"</span><span class="token punctuation">,</span> Female<span class="token punctuation">)</span><span class="token punctuation">;</span>

    p1<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    p2<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    p3<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>注意事项：</code></p>
<ol>
<li><code>这种链式的构造函数调用不能形成一个闭环（死循环），否则会在运行期抛异常。</code></li>
<li><code>如果要进行多层构造函数的链式调用，建议将构造函数的调用的写在初始列表中而不是函数体内部，否则编译器会提示形参的重复定义。</code></li>
<li><code>在初始化列表中调用了代理构造函数初始化某个类成员变量之后，就不能在初始化列表中再次初始化这个变量了。</code></li>
</ol>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 错误, 使用了委托构造函数就不能再次m_max初始化了</span>
<span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">int</span> age_<span class="token punctuation">,</span> string name<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">Person</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">age</span><span class="token punctuation">(</span>age_<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">this</span><span class="token operator">-></span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="8-2-继承构造函数"><a href="#8-2-继承构造函数" class="headerlink" title="8.2 继承构造函数"></a>8.2 继承构造函数</h3><p><code>C++11中提供的继承构造函数</code>可以让<code>派生类直接使用基类的构造函数</code>，而无需自己再写构造函数，尤其是在基类有很多构造函数的情况下，可以极大地简化派生类构造函数的编写。先来看没有继承构造函数之前的处理方式：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Base</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">m_i</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">double</span> j<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">m_i</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_j</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">double</span> j<span class="token punctuation">,</span> string k<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">m_i</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_j</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_k</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

    <span class="token keyword">int</span> m_i<span class="token punctuation">;</span>
    <span class="token keyword">double</span> m_j<span class="token punctuation">;</span>
    string m_k<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Child</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">Base</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    <span class="token function">Child</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">double</span> j<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">Base</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    <span class="token function">Child</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">double</span> j<span class="token punctuation">,</span> string k<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">Base</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Child <span class="token function">c</span><span class="token punctuation">(</span><span class="token number">520</span><span class="token punctuation">,</span> <span class="token number">13.14</span><span class="token punctuation">,</span> <span class="token string">"i love you"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"int: "</span> <span class="token operator">&lt;&lt;</span> c<span class="token punctuation">.</span>m_i <span class="token operator">&lt;&lt;</span> <span class="token string">", double: "</span> 
         <span class="token operator">&lt;&lt;</span> c<span class="token punctuation">.</span>m_j <span class="token operator">&lt;&lt;</span> <span class="token string">", string: "</span> <span class="token operator">&lt;&lt;</span> c<span class="token punctuation">.</span>m_k <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>可以看出，<code>即便是子类中只需要使用和基类一样的函数体也需要重新声明一遍子类的构造函数</code>,这是非常繁琐的，C++11中通过添加继承构造函数这个新特性完美的解决了这个问题，使得代码更加精简。</p>
<p>继承构造函数的使用方法是这样的：通过使用<code>using 类名::构造函数名</code>（其实类名和构造函数名是一样的）来<code>声明使用基类的构造函数</code>，这样子类中就可以不定义相同的构造函数了，直接使用基类的构造函数来构造派生类对象。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Base</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">m_i</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">double</span> j<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">m_i</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_j</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">double</span> j<span class="token punctuation">,</span> string k<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">m_i</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_j</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_k</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

    <span class="token keyword">int</span> m_i<span class="token punctuation">;</span>
    <span class="token keyword">double</span> m_j<span class="token punctuation">;</span>
    string m_k<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">using</span> Base<span class="token double-colon punctuation">::</span>Base<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Child <span class="token function">c</span><span class="token punctuation">(</span><span class="token number">520</span><span class="token punctuation">,</span> <span class="token number">13.14</span><span class="token punctuation">,</span> <span class="token string">"i love you"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"int: "</span> <span class="token operator">&lt;&lt;</span> c<span class="token punctuation">.</span>m_i <span class="token operator">&lt;&lt;</span> <span class="token string">", double: "</span>
         <span class="token operator">&lt;&lt;</span> c<span class="token punctuation">.</span>m_j <span class="token operator">&lt;&lt;</span> <span class="token string">", string: "</span> <span class="token operator">&lt;&lt;</span> c<span class="token punctuation">.</span>m_k <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在修改之后的子类中，没有添加任何构造函数，而是添加了<code>using Base::Base;</code>这样就可以在子类中直接继承父类的所有的构造函数，通过他们去构造子类对象了。</p>
<p>另外如果在子类中隐藏了父类中的同名函数，也可以通过<code>using</code>的方式在子类中使用基类中的这些父类函数：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Base</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">m_i</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">double</span> j<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">m_i</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_j</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">double</span> j<span class="token punctuation">,</span> string k<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">m_i</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_j</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_k</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

    <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"base class: i = "</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    
    <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> string str<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"base class: i = "</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">", str = "</span> <span class="token operator">&lt;&lt;</span> str <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">int</span> m_i<span class="token punctuation">;</span>
    <span class="token keyword">double</span> m_j<span class="token punctuation">;</span>
    string m_k<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">using</span> Base<span class="token double-colon punctuation">::</span>Base<span class="token punctuation">;</span>
    <span class="token keyword">using</span> Base<span class="token double-colon punctuation">::</span>func<span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"child class: i'am luffy!!!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Child <span class="token function">c</span><span class="token punctuation">(</span><span class="token number">250</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    c<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    c<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token number">19</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    c<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token number">19</span><span class="token punctuation">,</span> <span class="token string">"luffy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上述示例代码输出的结果为：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">child class: i'am luffy<span class="token operator">!</span><span class="token operator">!</span><span class="token operator">!</span>
base class: i <span class="token operator">=</span> <span class="token number">19</span>
base class: i <span class="token operator">=</span> <span class="token number">19</span>, str <span class="token operator">=</span> luffy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>子类中的<code>func()函数</code>隐藏了<code>基类中的两个func()</code>，因此默认情况下通过子类对象只能调用无参的func()，在上面的子类代码中添加了<code>using Base::func;</code>之后，就可以通过子类对象直接调用父类中被隐藏的带参func()函数了。</p>
<h2 id="宏的使用"><a href="#宏的使用" class="headerlink" title="宏的使用"></a>宏的使用</h2><p>宏（Macro）是 C 和 C++ 等编程语言中预处理器的一种功能，用于在编译之前对代码进行文本替换。宏可以用来定义常量、简化重复代码或者实现一些条件编译功能。宏通常使用 <code>#define</code> 指令来定义。</p>
<p>以下是一些宏的基本特点和使用方式：</p>
<ol>
<li><p><strong>常量宏</strong>：<br>常量宏可以用于定义一些常量值。例如：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PI</span> <span class="token expression"><span class="token number">3.14159</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这种定义可以在代码中随处使用 <code>PI</code>，编译器在编译时会将 <code>PI</code> 替换为 <code>3.14159</code>。</p>
</li>
<li><p><strong>函数宏</strong>：<br>函数宏可以接受参数并进行替换，起到类似函数的效果。例如：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SQUARE</span><span class="token expression"><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>使用时，如果你写 <code>SQUARE(5)</code>，编译器会将其替换为 <code>((5) * (5))</code>。</p>
</li>
<li><p><strong>条件编译</strong>：<br>宏还可以用于条件编译。通过 <code>#ifdef</code>、<code>#ifndef</code>、<code>#if</code> 等指令，可以根据条件编译不同的代码块。例如：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">DEBUG</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">LOG</span><span class="token expression"><span class="token punctuation">(</span>x<span class="token punctuation">)</span> cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">LOG</span><span class="token expression"><span class="token punctuation">(</span>x<span class="token punctuation">)</span> </span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里，只有在定义了 <code>DEBUG</code> 的情况下，<code>LOG(x)</code> 才会输出日志信息。</p>
</li>
<li><p><strong>优势和劣势</strong>：</p>
<ul>
<li>优势：宏可以减少代码重复，提高可维护性，支持条件编译等功能。</li>
<li>劣势：宏在替换时没有类型检查，可能导致代码难以调试。此外，过度使用宏会使代码不易阅读和理解。</li>
</ul>
</li>
</ol>
<h2 id="左值引用和右值引用"><a href="#左值引用和右值引用" class="headerlink" title="左值引用和右值引用"></a>左值引用和右值引用</h2><p>在C++中，<code>左值引用（lvalue reference）</code>和<code>右值引用（rvalue reference）</code>是两种不同的引用类型，用于处理不同类型的数据和场景。</p>
<h3 id="左值引用（lvalue-reference）"><a href="#左值引用（lvalue-reference）" class="headerlink" title="左值引用（lvalue reference）"></a>左值引用（lvalue reference）</h3><p><strong>定义</strong>：<br>左值引用是C++中传统的引用类型，用法是 <code>T&amp;</code>，其中 <code>T</code> 是被引用的类型。</p>
<p><strong>特点</strong>：</p>
<ol>
<li><strong>绑定左值</strong>：左值引用只能绑定到左值。左值是具有持久存储的表达式，可以出现在赋值操作符的左侧(可以取地址的变量)。</li>
<li><strong>修改性</strong>：除非引用本身被声明为 <code>const</code>，否则可以通过左值引用来修改被引用的对象。</li>
<li><strong>语法</strong>：使用 <code>&amp;</code> 符号声明。</li>
</ol>
<p><strong>示例</strong>：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span><span class="token operator">&amp;</span> ref_a <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment">// 左值引用绑定到左值 a</span>

    ref_a <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span> <span class="token comment">// 修改 a 的值</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"a: "</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 输出 20</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="右值引用（rvalue-reference）"><a href="#右值引用（rvalue-reference）" class="headerlink" title="右值引用（rvalue reference）"></a>右值引用（rvalue reference）</h3><p><strong>定义</strong>：<br>右值引用是C++11引入的一种新的引用类型，用法是 <code>T&amp;&amp;</code>，其中 <code>T</code> 是被引用的类型。</p>
<p><strong>特点</strong>：</p>
<ol>
<li><strong>绑定右值</strong>：右值引用可以绑定到右值。右值是<code>临时对象或字面量</code>，不能出现在赋值操作符的左侧。</li>
<li><strong>移动语义</strong>：右值引用的主要目的是实现移动语义，允许资源从一个对象转移到另一个对象，从而提高性能和减少不必要的复制。</li>
<li><strong>语法</strong>：使用 <code>&amp;&amp;</code> 符号声明。</li>
</ol>
<p><strong>示例</strong>：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;utility></span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> ref_a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">// 右值引用绑定到右值 10(字面量)</span>

    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ref_a: "</span> <span class="token operator">&lt;&lt;</span> ref_a <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 输出 10</span>

    <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
    <span class="token comment">// 下面的代码会报错，因为右值引用不能绑定到左值</span>
    <span class="token comment">// int&amp;&amp; ref_b = b;</span>

    <span class="token comment">// 使用 std::move 将左值转换为右值</span>
    <span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> ref_c <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ref_c: "</span> <span class="token operator">&lt;&lt;</span> ref_c <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 输出 20</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"b: "</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>         <span class="token comment">// 输出 20，但 b 的值可能被移动后变为未定义</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="区别总结"><a href="#区别总结" class="headerlink" title="区别总结"></a>区别总结</h3><table>
<thead>
<tr>
<th>特性</th>
<th>左值引用 (<code>T&amp;</code>)</th>
<th>右值引用 (<code>T&amp;&amp;</code>)</th>
</tr>
</thead>
<tbody><tr>
<td>绑定对象</td>
<td>左值（持久存储的表达式）</td>
<td>右值（临时对象或字面量）</td>
</tr>
<tr>
<td>语法</td>
<td><code>T&amp;</code></td>
<td><code>T&amp;&amp;</code></td>
</tr>
<tr>
<td>移动语义</td>
<td>不支持</td>
<td>支持，用于资源转移</td>
</tr>
<tr>
<td>修改性</td>
<td>可以修改（除非是 <code>const</code>）</td>
<td>可以修改（除非是 <code>const</code>）</td>
</tr>
<tr>
<td>示例</td>
<td><code>int&amp; ref_a = a;</code></td>
<td><code>int&amp;&amp; ref_b = 10;</code></td>
</tr>
</tbody></table>
<h3 id="进一步理解"><a href="#进一步理解" class="headerlink" title="进一步理解"></a>进一步理解</h3><ul>
<li><strong>左值</strong>：可以出现在赋值操作符左侧的表达式。例如，变量 <code>a</code> 是左值。</li>
<li><strong>右值</strong>：不能出现在赋值操作符左侧的表达式。例如，字面量 <code>10</code> 是右值。</li>
<li>**<code>std::move</code>**：这是一个标准库函数，用于将左值转换为右值引用，从而允许资源的移动。</li>
</ul>
<p>通过理解左值引用和右值引用，你可以更有效地利用C++11的特性来编写高性能的代码。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://0zxm.github.io">0zxm</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://0zxm.github.io/2024/12/25/cpp11-xin-te-xing/">https://0zxm.github.io/2024/12/25/cpp11-xin-te-xing/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://0zxm.github.io" target="_blank">0zxm</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/c/">c++</a></div><div class="post-share"><div class="social-share" data-image="/img/default_cover.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/wechat.png" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/01/01/qlabel-tian-jia-dian-ji-chu-li/" title="QLabel添加点击处理"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">QLabel添加点击处理</div></div><div class="info-2"><div class="info-item-1">Qt框架中添加QLabel的点击事件</div></div></div></a><a class="pagination-related" href="/2024/12/12/shu-ju-wa-jue-da-zuo-ye/" title="数据挖掘大作业"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">数据挖掘大作业</div></div><div class="info-2"><div class="info-item-1">数据挖掘课程大作业</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/07/17/c-cheng-xu-she-ji/" title="C++程序设计"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover1.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-17</div><div class="info-item-2">C++程序设计</div></div><div class="info-2"><div class="info-item-1">c++编程</div></div></div></a><a class="pagination-related" href="/2024/07/17/c-wang-luo-tong-xin/" title="C++程序设计"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default_cover.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-17</div><div class="info-item-2">C++程序设计</div></div><div class="info-2"><div class="info-item-1">c++多种方式实现网络通信</div></div></div></a><a class="pagination-related" href="/2024/06/21/suan-fa/" title="算法"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover1.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-21</div><div class="info-item-2">算法</div></div><div class="info-2"><div class="info-item-1">算法课笔记</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/favicon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">0zxm</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">45</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">56</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/0zxm"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/0zxm" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:m15813109801@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="http://0zxm.github.io" target="_blank" title="博客"><i class="fab fa-algolia" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-c-%E5%8E%9F%E5%A7%8B%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-text">1.c++原始字面量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-text">1.1 什么是字面量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%8E%9F%E5%A7%8B%E5%AD%97%E9%9D%A2%E9%87%8F%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7"><span class="toc-text">1.2 原始字面量的必要性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%8C%87%E9%92%88%E7%A9%BA%E5%80%BC%E7%B1%BB%E5%9E%8Bnullptr"><span class="toc-text">2.指针空值类型nullptr</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E5%92%8C%E6%98%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2%E7%9A%84%E5%BF%85%E8%A6%81"><span class="toc-text">2.1 隐式转换和显式转换的必要</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-constexpr%E6%96%B0%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">3.constexpr新关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-const%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">3.1 const关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-constexpr%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">3.2 constexpr常量表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%87%BD%E6%95%B0"><span class="toc-text">3.3 常量表达式函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a-%E4%BF%AE%E9%A5%B0%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0"><span class="toc-text">a. 修饰普通函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-text">b. 修饰成员函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c-%E4%BF%AE%E9%A5%B0%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0"><span class="toc-text">c. 修饰模板函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#d-%E4%BF%AE%E9%A5%B0%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">d. 修饰构造函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-auto%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC"><span class="toc-text">4.auto类型推导</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-auto%E7%9A%84%E6%8E%A8%E5%AF%BC%E8%A7%84%E5%88%99"><span class="toc-text">4.1 auto的推导规则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a-%E8%87%AA%E5%8A%A8%E5%AD%98%E5%82%A8%E6%9C%9F"><span class="toc-text">a. 自动存储期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-auto%E7%9A%84%E6%8E%A8%E5%AF%BC%E8%A7%84%E5%88%99"><span class="toc-text">b. auto的推导规则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-auto%E7%9A%84%E9%99%90%E5%88%B6"><span class="toc-text">4.2 auto的限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-auto%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">4.3 auto的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-decltype%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">4.4 decltype关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-decltype%E7%9A%84%E6%8E%A8%E5%AF%BC%E8%A7%84%E5%88%99"><span class="toc-text">4.5 decltype的推导规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-decltype%E5%9C%A8%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">4.6 decltype在泛型编程的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%90%8E%E7%BD%AE-%E5%A3%B0%E6%98%8E%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B"><span class="toc-text">4.7 返回类型的后置(声明返回类型?)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-final%E5%92%8Coverride"><span class="toc-text">5. final和override</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-final-%E4%BF%AE%E9%A5%B0%E5%87%BD%E6%95%B0"><span class="toc-text">5.1 final 修饰函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-final-%E4%BF%AE%E9%A5%B0%E7%B1%BB"><span class="toc-text">5.2 final 修饰类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-overide"><span class="toc-text">5.3 overide</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%A8%A1%E6%9D%BF%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-text">6. 模板的优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E6%A8%A1%E6%9D%BF%E5%B5%8C%E5%A5%97%E5%8F%B3%E5%B0%96%E6%8B%AC%E5%8F%B7%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-text">6.1 模板嵌套右尖括号的优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E9%BB%98%E8%AE%A4%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0"><span class="toc-text">6.2 默认模板参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-using%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">7. using关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E7%BB%99%E7%B1%BB%E5%AE%9A%E4%B9%89%E5%88%AB%E5%90%8D"><span class="toc-text">7.1 给类定义别名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E7%BB%99%E6%A8%A1%E6%9D%BF%E5%AE%9A%E4%B9%89%E5%88%AB%E5%90%8D"><span class="toc-text">7.2 给模板定义别名</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%A7%94%E6%89%98%E6%9E%84%E9%80%A0%E5%92%8C%E7%BB%A7%E6%89%BF%E6%9E%84%E9%80%A0"><span class="toc-text">8. 委托构造和继承构造</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-%E5%A7%94%E6%89%98%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">8.1 委托构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-%E7%BB%A7%E6%89%BF%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">8.2 继承构造函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8F%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">宏的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E5%92%8C%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-text">左值引用和右值引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%EF%BC%88lvalue-reference%EF%BC%89"><span class="toc-text">左值引用（lvalue reference）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%EF%BC%88rvalue-reference%EF%BC%89"><span class="toc-text">右值引用（rvalue reference）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB%E6%80%BB%E7%BB%93"><span class="toc-text">区别总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E4%B8%80%E6%AD%A5%E7%90%86%E8%A7%A3"><span class="toc-text">进一步理解</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/01/05/mindspore-shou-xie-shu-zi-shi-bie/" title="Mindspore手写数字识别"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Mindspore手写数字识别"/></a><div class="content"><a class="title" href="/2025/01/05/mindspore-shou-xie-shu-zi-shi-bie/" title="Mindspore手写数字识别">Mindspore手写数字识别</a><time datetime="2025-01-05T11:41:03.000Z" title="发表于 2025-01-05 19:41:03">2025-01-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/01/tong-xin-yuan-fa-hua-tuo-yuan-ji-yuan-li/" title="同心圆法画椭圆及原理"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="同心圆法画椭圆及原理"/></a><div class="content"><a class="title" href="/2025/01/01/tong-xin-yuan-fa-hua-tuo-yuan-ji-yuan-li/" title="同心圆法画椭圆及原理">同心圆法画椭圆及原理</a><time datetime="2025-01-01T14:50:03.000Z" title="发表于 2025-01-01 22:50:03">2025-01-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/01/qlabel-tian-jia-dian-ji-chu-li/" title="QLabel添加点击处理"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="QLabel添加点击处理"/></a><div class="content"><a class="title" href="/2025/01/01/qlabel-tian-jia-dian-ji-chu-li/" title="QLabel添加点击处理">QLabel添加点击处理</a><time datetime="2025-01-01T11:45:39.000Z" title="发表于 2025-01-01 19:45:39">2025-01-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/25/cpp11-xin-te-xing/" title="cpp11新特性"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default_cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="cpp11新特性"/></a><div class="content"><a class="title" href="/2024/12/25/cpp11-xin-te-xing/" title="cpp11新特性">cpp11新特性</a><time datetime="2024-12-25T12:52:06.000Z" title="发表于 2024-12-25 20:52:06">2024-12-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/12/shu-ju-wa-jue-da-zuo-ye/" title="数据挖掘大作业"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据挖掘大作业"/></a><div class="content"><a class="title" href="/2024/12/12/shu-ju-wa-jue-da-zuo-ye/" title="数据挖掘大作业">数据挖掘大作业</a><time datetime="2024-12-12T09:12:17.000Z" title="发表于 2024-12-12 17:12:17">2024-12-12</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/footer.jpg);"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By 0zxm</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }
      
      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>